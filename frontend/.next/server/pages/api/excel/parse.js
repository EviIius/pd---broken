"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(() => {
var exports = {};
exports.id = "pages/api/excel/parse";
exports.ids = ["pages/api/excel/parse"];
exports.modules = {

/***/ "next/dist/compiled/next-server/pages-api.runtime.dev.js":
/*!**************************************************************************!*\
  !*** external "next/dist/compiled/next-server/pages-api.runtime.dev.js" ***!
  \**************************************************************************/
/***/ ((module) => {

module.exports = require("next/dist/compiled/next-server/pages-api.runtime.dev.js");

/***/ }),

/***/ "xlsx":
/*!***********************!*\
  !*** external "xlsx" ***!
  \***********************/
/***/ ((module) => {

module.exports = require("xlsx");

/***/ }),

/***/ "formidable":
/*!*****************************!*\
  !*** external "formidable" ***!
  \*****************************/
/***/ ((module) => {

module.exports = import("formidable");;

/***/ }),

/***/ "fs":
/*!*********************!*\
  !*** external "fs" ***!
  \*********************/
/***/ ((module) => {

module.exports = require("fs");

/***/ }),

/***/ "(api)/./node_modules/next/dist/build/webpack/loaders/next-route-loader/index.js?kind=PAGES_API&page=%2Fapi%2Fexcel%2Fparse&preferredRegion=&absolutePagePath=.%2Fpages%5Capi%5Cexcel%5Cparse.ts&middlewareConfigBase64=e30%3D!":
/*!********************************************************************************************************************************************************************************************************************************!*\
  !*** ./node_modules/next/dist/build/webpack/loaders/next-route-loader/index.js?kind=PAGES_API&page=%2Fapi%2Fexcel%2Fparse&preferredRegion=&absolutePagePath=.%2Fpages%5Capi%5Cexcel%5Cparse.ts&middlewareConfigBase64=e30%3D! ***!
  \********************************************************************************************************************************************************************************************************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.a(module, async (__webpack_handle_async_dependencies__, __webpack_async_result__) => { try {\n__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   config: () => (/* binding */ config),\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__),\n/* harmony export */   routeModule: () => (/* binding */ routeModule)\n/* harmony export */ });\n/* harmony import */ var next_dist_server_future_route_modules_pages_api_module_compiled__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! next/dist/server/future/route-modules/pages-api/module.compiled */ \"(api)/./node_modules/next/dist/server/future/route-modules/pages-api/module.compiled.js\");\n/* harmony import */ var next_dist_server_future_route_modules_pages_api_module_compiled__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(next_dist_server_future_route_modules_pages_api_module_compiled__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var next_dist_server_future_route_kind__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! next/dist/server/future/route-kind */ \"(api)/./node_modules/next/dist/server/future/route-kind.js\");\n/* harmony import */ var next_dist_build_templates_helpers__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! next/dist/build/templates/helpers */ \"(api)/./node_modules/next/dist/build/templates/helpers.js\");\n/* harmony import */ var _pages_api_excel_parse_ts__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./pages\\api\\excel\\parse.ts */ \"(api)/./pages/api/excel/parse.ts\");\nvar __webpack_async_dependencies__ = __webpack_handle_async_dependencies__([_pages_api_excel_parse_ts__WEBPACK_IMPORTED_MODULE_3__]);\n_pages_api_excel_parse_ts__WEBPACK_IMPORTED_MODULE_3__ = (__webpack_async_dependencies__.then ? (await __webpack_async_dependencies__)() : __webpack_async_dependencies__)[0];\n\n\n\n// Import the userland code.\n\n// Re-export the handler (should be the default export).\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ((0,next_dist_build_templates_helpers__WEBPACK_IMPORTED_MODULE_2__.hoist)(_pages_api_excel_parse_ts__WEBPACK_IMPORTED_MODULE_3__, \"default\"));\n// Re-export config.\nconst config = (0,next_dist_build_templates_helpers__WEBPACK_IMPORTED_MODULE_2__.hoist)(_pages_api_excel_parse_ts__WEBPACK_IMPORTED_MODULE_3__, \"config\");\n// Create and export the route module that will be consumed.\nconst routeModule = new next_dist_server_future_route_modules_pages_api_module_compiled__WEBPACK_IMPORTED_MODULE_0__.PagesAPIRouteModule({\n    definition: {\n        kind: next_dist_server_future_route_kind__WEBPACK_IMPORTED_MODULE_1__.RouteKind.PAGES_API,\n        page: \"/api/excel/parse\",\n        pathname: \"/api/excel/parse\",\n        // The following aren't used in production.\n        bundlePath: \"\",\n        filename: \"\"\n    },\n    userland: _pages_api_excel_parse_ts__WEBPACK_IMPORTED_MODULE_3__\n});\n\n//# sourceMappingURL=pages-api.js.map\n__webpack_async_result__();\n} catch(e) { __webpack_async_result__(e); } });//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwaSkvLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2J1aWxkL3dlYnBhY2svbG9hZGVycy9uZXh0LXJvdXRlLWxvYWRlci9pbmRleC5qcz9raW5kPVBBR0VTX0FQSSZwYWdlPSUyRmFwaSUyRmV4Y2VsJTJGcGFyc2UmcHJlZmVycmVkUmVnaW9uPSZhYnNvbHV0ZVBhZ2VQYXRoPS4lMkZwYWdlcyU1Q2FwaSU1Q2V4Y2VsJTVDcGFyc2UudHMmbWlkZGxld2FyZUNvbmZpZ0Jhc2U2ND1lMzAlM0QhIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7O0FBQXNHO0FBQ3ZDO0FBQ0w7QUFDMUQ7QUFDMEQ7QUFDMUQ7QUFDQSxpRUFBZSx3RUFBSyxDQUFDLHNEQUFRLFlBQVksRUFBQztBQUMxQztBQUNPLGVBQWUsd0VBQUssQ0FBQyxzREFBUTtBQUNwQztBQUNPLHdCQUF3QixnSEFBbUI7QUFDbEQ7QUFDQSxjQUFjLHlFQUFTO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsWUFBWTtBQUNaLENBQUM7O0FBRUQscUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9yZS1nZW50LWZyb250ZW5kLz8yMWZkIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IFBhZ2VzQVBJUm91dGVNb2R1bGUgfSBmcm9tIFwibmV4dC9kaXN0L3NlcnZlci9mdXR1cmUvcm91dGUtbW9kdWxlcy9wYWdlcy1hcGkvbW9kdWxlLmNvbXBpbGVkXCI7XG5pbXBvcnQgeyBSb3V0ZUtpbmQgfSBmcm9tIFwibmV4dC9kaXN0L3NlcnZlci9mdXR1cmUvcm91dGUta2luZFwiO1xuaW1wb3J0IHsgaG9pc3QgfSBmcm9tIFwibmV4dC9kaXN0L2J1aWxkL3RlbXBsYXRlcy9oZWxwZXJzXCI7XG4vLyBJbXBvcnQgdGhlIHVzZXJsYW5kIGNvZGUuXG5pbXBvcnQgKiBhcyB1c2VybGFuZCBmcm9tIFwiLi9wYWdlc1xcXFxhcGlcXFxcZXhjZWxcXFxccGFyc2UudHNcIjtcbi8vIFJlLWV4cG9ydCB0aGUgaGFuZGxlciAoc2hvdWxkIGJlIHRoZSBkZWZhdWx0IGV4cG9ydCkuXG5leHBvcnQgZGVmYXVsdCBob2lzdCh1c2VybGFuZCwgXCJkZWZhdWx0XCIpO1xuLy8gUmUtZXhwb3J0IGNvbmZpZy5cbmV4cG9ydCBjb25zdCBjb25maWcgPSBob2lzdCh1c2VybGFuZCwgXCJjb25maWdcIik7XG4vLyBDcmVhdGUgYW5kIGV4cG9ydCB0aGUgcm91dGUgbW9kdWxlIHRoYXQgd2lsbCBiZSBjb25zdW1lZC5cbmV4cG9ydCBjb25zdCByb3V0ZU1vZHVsZSA9IG5ldyBQYWdlc0FQSVJvdXRlTW9kdWxlKHtcbiAgICBkZWZpbml0aW9uOiB7XG4gICAgICAgIGtpbmQ6IFJvdXRlS2luZC5QQUdFU19BUEksXG4gICAgICAgIHBhZ2U6IFwiL2FwaS9leGNlbC9wYXJzZVwiLFxuICAgICAgICBwYXRobmFtZTogXCIvYXBpL2V4Y2VsL3BhcnNlXCIsXG4gICAgICAgIC8vIFRoZSBmb2xsb3dpbmcgYXJlbid0IHVzZWQgaW4gcHJvZHVjdGlvbi5cbiAgICAgICAgYnVuZGxlUGF0aDogXCJcIixcbiAgICAgICAgZmlsZW5hbWU6IFwiXCJcbiAgICB9LFxuICAgIHVzZXJsYW5kXG59KTtcblxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9cGFnZXMtYXBpLmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(api)/./node_modules/next/dist/build/webpack/loaders/next-route-loader/index.js?kind=PAGES_API&page=%2Fapi%2Fexcel%2Fparse&preferredRegion=&absolutePagePath=.%2Fpages%5Capi%5Cexcel%5Cparse.ts&middlewareConfigBase64=e30%3D!\n");

/***/ }),

/***/ "(api)/./pages/api/excel/parse.ts":
/*!**********************************!*\
  !*** ./pages/api/excel/parse.ts ***!
  \**********************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.a(module, async (__webpack_handle_async_dependencies__, __webpack_async_result__) => { try {\n__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   config: () => (/* binding */ config),\n/* harmony export */   \"default\": () => (/* binding */ handler)\n/* harmony export */ });\n/* harmony import */ var xlsx__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! xlsx */ \"xlsx\");\n/* harmony import */ var xlsx__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(xlsx__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var formidable__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! formidable */ \"formidable\");\n/* harmony import */ var fs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! fs */ \"fs\");\n/* harmony import */ var fs__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(fs__WEBPACK_IMPORTED_MODULE_2__);\nvar __webpack_async_dependencies__ = __webpack_handle_async_dependencies__([formidable__WEBPACK_IMPORTED_MODULE_1__]);\nformidable__WEBPACK_IMPORTED_MODULE_1__ = (__webpack_async_dependencies__.then ? (await __webpack_async_dependencies__)() : __webpack_async_dependencies__)[0];\n\n\n\n// Disable default body parser for file uploads\nconst config = {\n    api: {\n        bodyParser: false\n    }\n};\nfunction parseExcelFile(buffer, filename) {\n    console.log(\"Parsing Excel file:\", filename, \"Buffer size:\", buffer.length);\n    try {\n        const workbook = xlsx__WEBPACK_IMPORTED_MODULE_0__.read(buffer, {\n            type: \"buffer\",\n            cellFormula: true,\n            cellStyles: true,\n            cellDates: true,\n            cellNF: false\n        });\n        console.log(\"Workbook sheets found:\", workbook.SheetNames);\n        const sheets = workbook.SheetNames.map((sheetName, index)=>{\n            console.log(\"Processing sheet:\", sheetName);\n            const worksheet = workbook.Sheets[sheetName];\n            if (!worksheet) {\n                console.warn(\"Worksheet is empty:\", sheetName);\n                return null;\n            }\n            const jsonData = xlsx__WEBPACK_IMPORTED_MODULE_0__.utils.sheet_to_json(worksheet, {\n                header: 1,\n                raw: false,\n                defval: null,\n                blankrows: false\n            });\n            // Get the range of the worksheet\n            const range = worksheet[\"!ref\"] ? xlsx__WEBPACK_IMPORTED_MODULE_0__.utils.decode_range(worksheet[\"!ref\"]) : {\n                s: {\n                    r: 0,\n                    c: 0\n                },\n                e: {\n                    r: 0,\n                    c: 0\n                }\n            };\n            const rowCount = Math.max(jsonData.length, range.e.r + 1);\n            const columnCount = Math.max(range.e.c + 1, Math.max(...jsonData.map((row)=>row.length)));\n            console.log(`Sheet ${sheetName}: ${rowCount} rows, ${columnCount} columns`);\n            // Extract headers (first row) - handle empty rows\n            const headers = jsonData.length > 0 ? jsonData[0] || [] : [];\n            // Convert to our ExcelCell format with better error handling\n            const data = [];\n            for(let row = 0; row < rowCount; row++){\n                const rowData = [];\n                for(let col = 0; col < columnCount; col++){\n                    const cellAddress = xlsx__WEBPACK_IMPORTED_MODULE_0__.utils.encode_cell({\n                        r: row,\n                        c: col\n                    });\n                    const cell = worksheet[cellAddress];\n                    let cellValue = null;\n                    let cellType = \"empty\";\n                    let formula;\n                    if (cell) {\n                        try {\n                            if (cell.f) {\n                                formula = cell.f;\n                                cellType = \"formula\";\n                                cellValue = cell.v !== undefined ? cell.v : cell.w || \"\";\n                            } else if (cell.v !== undefined) {\n                                cellValue = cell.v;\n                                if (typeof cell.v === \"string\") cellType = \"string\";\n                                else if (typeof cell.v === \"number\") cellType = \"number\";\n                                else if (typeof cell.v === \"boolean\") cellType = \"boolean\";\n                                else if (cell.v instanceof Date || cell.t === \"d\") cellType = \"date\";\n                                else cellType = \"string\"; // fallback\n                            }\n                        } catch (cellError) {\n                            console.warn(`Error processing cell ${cellAddress}:`, cellError);\n                            cellValue = cell.w || cell.v || \"\";\n                            cellType = \"string\";\n                        }\n                    }\n                    rowData.push({\n                        value: cellValue,\n                        type: cellType,\n                        address: cellAddress,\n                        formula\n                    });\n                }\n                data.push(rowData);\n            }\n            // Analyze data types for each column with better detection\n            const dataTypes = headers.map((header, colIndex)=>{\n                const columnData = data.slice(1).map((row)=>row[colIndex]?.value).filter((v)=>v !== null && v !== undefined && v !== \"\");\n                const uniqueValues = Array.from(new Set(columnData));\n                // Determine data type with improved logic\n                let dataType = \"text\";\n                if (columnData.length > 0) {\n                    const numberCount = columnData.filter((v)=>typeof v === \"number\" || !isNaN(Number(v)) && v !== \"\").length;\n                    const dateCount = columnData.filter((v)=>{\n                        if (v instanceof Date) return true;\n                        if (typeof v === \"string\") {\n                            const dateTest = new Date(v);\n                            return !isNaN(dateTest.getTime()) && v.match(/\\d{1,4}[-\\/]\\d{1,2}[-\\/]\\d{1,4}/);\n                        }\n                        return false;\n                    }).length;\n                    if (numberCount / columnData.length > 0.7) dataType = \"number\";\n                    else if (dateCount / columnData.length > 0.7) dataType = \"date\";\n                }\n                return {\n                    columnIndex: colIndex,\n                    columnLetter: xlsx__WEBPACK_IMPORTED_MODULE_0__.utils.encode_col(colIndex),\n                    header: header || `Column ${colIndex + 1}`,\n                    dataType,\n                    sampleValues: uniqueValues.slice(0, 5),\n                    uniqueCount: uniqueValues.length,\n                    nullCount: data.slice(1).length - columnData.length\n                };\n            });\n            // Extract formula cells with better error handling\n            const formulaCells = [];\n            data.forEach((row, rowIndex)=>{\n                row.forEach((cell, colIndex)=>{\n                    if (cell.formula) {\n                        try {\n                            formulaCells.push({\n                                address: cell.address,\n                                formula: cell.formula,\n                                dependencies: extractFormulaDependencies(cell.formula),\n                                result: cell.value\n                            });\n                        } catch (formulaError) {\n                            console.warn(`Error processing formula in cell ${cell.address}:`, formulaError);\n                        }\n                    }\n                });\n            });\n            console.log(`Sheet ${sheetName} processed: ${formulaCells.length} formulas found`);\n            return {\n                id: `sheet_${index}`,\n                name: sheetName,\n                data,\n                headers,\n                rowCount,\n                columnCount,\n                dataTypes,\n                hasFormulas: formulaCells.length > 0,\n                formulaCells\n            };\n        }).filter((sheet)=>sheet !== null); // Remove any null sheets  \n        const finalWorkbook = {\n            id: `workbook_${Date.now()}`,\n            name: filename,\n            sheets,\n            uploadDate: new Date(),\n            fileSize: buffer.length,\n            lastModified: new Date()\n        };\n        console.log(\"Final workbook created:\", {\n            name: finalWorkbook.name,\n            sheetsCount: finalWorkbook.sheets.length,\n            totalFormulas: finalWorkbook.sheets.reduce((sum, s)=>sum + s.formulaCells.length, 0)\n        });\n        return finalWorkbook;\n    } catch (error) {\n        console.error(\"Error parsing Excel file:\", error);\n        throw new Error(`Failed to parse Excel file: ${error.message}`);\n    }\n}\nfunction extractFormulaDependencies(formula) {\n    // Simple regex to extract cell references like A1, B2, $A$1, etc.\n    const cellRefRegex = /\\$?[A-Z]+\\$?\\d+/g;\n    const matches = formula.match(cellRefRegex) || [];\n    return Array.from(new Set(matches));\n}\nasync function handler(req, res) {\n    if (req.method !== \"POST\") {\n        return res.status(405).json({\n            error: \"Method not allowed\"\n        });\n    }\n    try {\n        const form = new formidable__WEBPACK_IMPORTED_MODULE_1__.IncomingForm({\n            keepExtensions: true,\n            maxFileSize: 50 * 1024 * 1024,\n            multiples: true\n        });\n        const { files } = await new Promise((resolve, reject)=>{\n            form.parse(req, (err, fields, files)=>{\n                if (err) {\n                    console.error(\"Form parse error:\", err);\n                    reject(err);\n                } else {\n                    resolve({\n                        files\n                    });\n                }\n            });\n        });\n        console.log(\"Received files:\", Object.keys(files));\n        // Handle both single file and array of files\n        let excelFile = files.excel;\n        if (Array.isArray(excelFile)) {\n            excelFile = excelFile[0];\n        }\n        if (!excelFile) {\n            console.log(\"No excel file found in:\", files);\n            return res.status(400).json({\n                error: \"No Excel file uploaded\"\n            });\n        }\n        console.log(\"Processing file:\", excelFile.originalFilename, \"Size:\", excelFile.size);\n        // Read the file buffer\n        const buffer = fs__WEBPACK_IMPORTED_MODULE_2___default().readFileSync(excelFile.filepath);\n        // Parse the Excel file\n        const workbook = parseExcelFile(buffer, excelFile.originalFilename || \"unknown.xlsx\");\n        res.status(200).json(workbook);\n    } catch (error) {\n        console.error(\"Error parsing Excel file:\", error);\n        res.status(500).json({\n            error: \"Failed to parse Excel file\",\n            details: error.message\n        });\n    }\n}\n\n__webpack_async_result__();\n} catch(e) { __webpack_async_result__(e); } });//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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QUFDLEtBQUtDLElBQUksQ0FBQztnQkFBRVYsT0FBTztZQUF5QjtRQUNoRTtRQUVBbkcsUUFBUUMsR0FBRyxDQUFDLG9CQUFvQjBILFVBQVVHLGdCQUFnQixFQUFFLFNBQVNILFVBQVVJLElBQUk7UUFFbkYsdUJBQXVCO1FBQ3ZCLE1BQU1qSSxTQUFTTCxzREFBZSxDQUFDa0ksVUFBVU0sUUFBUTtRQUVqRCx1QkFBdUI7UUFDdkIsTUFBTTlILFdBQVdOLGVBQWVDLFFBQVE2SCxVQUFVRyxnQkFBZ0IsSUFBSTtRQUV0RXBCLElBQUlFLE1BQU0sQ0FBQyxLQUFLQyxJQUFJLENBQUMxRztJQUN2QixFQUFFLE9BQU9nRyxPQUFPO1FBQ2RuRyxRQUFRbUcsS0FBSyxDQUFDLDZCQUE2QkE7UUFDM0NPLElBQUlFLE1BQU0sQ0FBQyxLQUFLQyxJQUFJLENBQUM7WUFBRVYsT0FBTztZQUE4QitCLFNBQVMvQixNQUFNRSxPQUFPO1FBQUM7SUFDckY7QUFDRiIsInNvdXJjZXMiOlsid2VicGFjazovL3JlLWdlbnQtZnJvbnRlbmQvLi9wYWdlcy9hcGkvZXhjZWwvcGFyc2UudHM/MDhmYSJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBOZXh0QXBpUmVxdWVzdCwgTmV4dEFwaVJlc3BvbnNlIH0gZnJvbSAnbmV4dCc7XHJcbmltcG9ydCAqIGFzIFhMU1ggZnJvbSAneGxzeCc7XHJcbmltcG9ydCB7IEluY29taW5nRm9ybSwgRmlsZSBhcyBGb3JtaWRhYmxlRmlsZSB9IGZyb20gJ2Zvcm1pZGFibGUnO1xyXG5pbXBvcnQgZnMgZnJvbSAnZnMnO1xyXG5pbXBvcnQgeyBFeGNlbFdvcmtib29rLCBFeGNlbFdvcmtzaGVldCwgRXhjZWxDZWxsLCBDb2x1bW5EYXRhVHlwZSwgRm9ybXVsYUNlbGwgfSBmcm9tICcuLi8uLi8uLi90eXBlcy9leGNlbCc7XHJcblxyXG4vLyBEaXNhYmxlIGRlZmF1bHQgYm9keSBwYXJzZXIgZm9yIGZpbGUgdXBsb2Fkc1xyXG5leHBvcnQgY29uc3QgY29uZmlnID0ge1xyXG4gIGFwaToge1xyXG4gICAgYm9keVBhcnNlcjogZmFsc2UsXHJcbiAgfSxcclxufTtcclxuXHJcbmZ1bmN0aW9uIHBhcnNlRXhjZWxGaWxlKGJ1ZmZlcjogQnVmZmVyLCBmaWxlbmFtZTogc3RyaW5nKTogRXhjZWxXb3JrYm9vayB7XHJcbiAgY29uc29sZS5sb2coJ1BhcnNpbmcgRXhjZWwgZmlsZTonLCBmaWxlbmFtZSwgJ0J1ZmZlciBzaXplOicsIGJ1ZmZlci5sZW5ndGgpO1xyXG4gIFxyXG4gIHRyeSB7XHJcbiAgICBjb25zdCB3b3JrYm9vayA9IFhMU1gucmVhZChidWZmZXIsIHsgXHJcbiAgICAgIHR5cGU6ICdidWZmZXInLCBcclxuICAgICAgY2VsbEZvcm11bGE6IHRydWUsIFxyXG4gICAgICBjZWxsU3R5bGVzOiB0cnVlLFxyXG4gICAgICBjZWxsRGF0ZXM6IHRydWUsXHJcbiAgICAgIGNlbGxORjogZmFsc2VcclxuICAgIH0pO1xyXG4gICAgXHJcbiAgICBjb25zb2xlLmxvZygnV29ya2Jvb2sgc2hlZXRzIGZvdW5kOicsIHdvcmtib29rLlNoZWV0TmFtZXMpO1xyXG4gICAgXHJcbiAgICBjb25zdCBzaGVldHM6IEV4Y2VsV29ya3NoZWV0W10gPSB3b3JrYm9vay5TaGVldE5hbWVzLm1hcCgoc2hlZXROYW1lLCBpbmRleCkgPT4ge1xyXG4gICAgICBjb25zb2xlLmxvZygnUHJvY2Vzc2luZyBzaGVldDonLCBzaGVldE5hbWUpO1xyXG4gICAgICBjb25zdCB3b3Jrc2hlZXQgPSB3b3JrYm9vay5TaGVldHNbc2hlZXROYW1lXTtcclxuICAgICAgXHJcbiAgICAgIGlmICghd29ya3NoZWV0KSB7XHJcbiAgICAgICAgY29uc29sZS53YXJuKCdXb3Jrc2hlZXQgaXMgZW1wdHk6Jywgc2hlZXROYW1lKTtcclxuICAgICAgICByZXR1cm4gbnVsbDtcclxuICAgICAgfVxyXG4gICAgICBcclxuICAgICAgY29uc3QganNvbkRhdGEgPSBYTFNYLnV0aWxzLnNoZWV0X3RvX2pzb24od29ya3NoZWV0LCB7IFxyXG4gICAgICAgIGhlYWRlcjogMSwgXHJcbiAgICAgICAgcmF3OiBmYWxzZSwgXHJcbiAgICAgICAgZGVmdmFsOiBudWxsLFxyXG4gICAgICAgIGJsYW5rcm93czogZmFsc2VcclxuICAgICAgfSk7XHJcbiAgICAgIFxyXG4gICAgICAvLyBHZXQgdGhlIHJhbmdlIG9mIHRoZSB3b3Jrc2hlZXRcclxuICAgICAgY29uc3QgcmFuZ2UgPSB3b3Jrc2hlZXRbJyFyZWYnXSA/IFhMU1gudXRpbHMuZGVjb2RlX3JhbmdlKHdvcmtzaGVldFsnIXJlZiddKSA6IHsgczogeyByOiAwLCBjOiAwIH0sIGU6IHsgcjogMCwgYzogMCB9IH07XHJcbiAgICAgIGNvbnN0IHJvd0NvdW50ID0gTWF0aC5tYXgoanNvbkRhdGEubGVuZ3RoLCByYW5nZS5lLnIgKyAxKTtcclxuICAgICAgY29uc3QgY29sdW1uQ291bnQgPSBNYXRoLm1heChyYW5nZS5lLmMgKyAxLCBNYXRoLm1heCguLi5qc29uRGF0YS5tYXAoKHJvdzogYW55W10pID0+IHJvdy5sZW5ndGgpKSk7XHJcbiAgICAgIFxyXG4gICAgICBjb25zb2xlLmxvZyhgU2hlZXQgJHtzaGVldE5hbWV9OiAke3Jvd0NvdW50fSByb3dzLCAke2NvbHVtbkNvdW50fSBjb2x1bW5zYCk7ICAgICAgXHJcbiAgICAgIC8vIEV4dHJhY3QgaGVhZGVycyAoZmlyc3Qgcm93KSAtIGhhbmRsZSBlbXB0eSByb3dzXHJcbiAgICAgIGNvbnN0IGhlYWRlcnMgPSBqc29uRGF0YS5sZW5ndGggPiAwID8gKGpzb25EYXRhWzBdIGFzIHN0cmluZ1tdIHx8IFtdKSA6IFtdO1xyXG4gICAgICBcclxuICAgICAgLy8gQ29udmVydCB0byBvdXIgRXhjZWxDZWxsIGZvcm1hdCB3aXRoIGJldHRlciBlcnJvciBoYW5kbGluZ1xyXG4gICAgICBjb25zdCBkYXRhOiBFeGNlbENlbGxbXVtdID0gW107XHJcbiAgICAgIGZvciAobGV0IHJvdyA9IDA7IHJvdyA8IHJvd0NvdW50OyByb3crKykge1xyXG4gICAgICAgIGNvbnN0IHJvd0RhdGE6IEV4Y2VsQ2VsbFtdID0gW107XHJcbiAgICAgICAgZm9yIChsZXQgY29sID0gMDsgY29sIDwgY29sdW1uQ291bnQ7IGNvbCsrKSB7XHJcbiAgICAgICAgICBjb25zdCBjZWxsQWRkcmVzcyA9IFhMU1gudXRpbHMuZW5jb2RlX2NlbGwoeyByOiByb3csIGM6IGNvbCB9KTtcclxuICAgICAgICAgIGNvbnN0IGNlbGwgPSB3b3Jrc2hlZXRbY2VsbEFkZHJlc3NdO1xyXG4gICAgICAgICAgXHJcbiAgICAgICAgICBsZXQgY2VsbFZhbHVlID0gbnVsbDtcclxuICAgICAgICAgIGxldCBjZWxsVHlwZTogRXhjZWxDZWxsWyd0eXBlJ10gPSAnZW1wdHknO1xyXG4gICAgICAgICAgbGV0IGZvcm11bGE6IHN0cmluZyB8IHVuZGVmaW5lZDtcclxuICAgICAgICAgIFxyXG4gICAgICAgICAgaWYgKGNlbGwpIHtcclxuICAgICAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgICBpZiAoY2VsbC5mKSB7XHJcbiAgICAgICAgICAgICAgICBmb3JtdWxhID0gY2VsbC5mO1xyXG4gICAgICAgICAgICAgICAgY2VsbFR5cGUgPSAnZm9ybXVsYSc7XHJcbiAgICAgICAgICAgICAgICBjZWxsVmFsdWUgPSBjZWxsLnYgIT09IHVuZGVmaW5lZCA/IGNlbGwudiA6IGNlbGwudyB8fCAnJztcclxuICAgICAgICAgICAgICB9IGVsc2UgaWYgKGNlbGwudiAhPT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICAgICAgICBjZWxsVmFsdWUgPSBjZWxsLnY7XHJcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIGNlbGwudiA9PT0gJ3N0cmluZycpIGNlbGxUeXBlID0gJ3N0cmluZyc7XHJcbiAgICAgICAgICAgICAgICBlbHNlIGlmICh0eXBlb2YgY2VsbC52ID09PSAnbnVtYmVyJykgY2VsbFR5cGUgPSAnbnVtYmVyJztcclxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKHR5cGVvZiBjZWxsLnYgPT09ICdib29sZWFuJykgY2VsbFR5cGUgPSAnYm9vbGVhbic7XHJcbiAgICAgICAgICAgICAgICBlbHNlIGlmIChjZWxsLnYgaW5zdGFuY2VvZiBEYXRlIHx8IGNlbGwudCA9PT0gJ2QnKSBjZWxsVHlwZSA9ICdkYXRlJztcclxuICAgICAgICAgICAgICAgIGVsc2UgY2VsbFR5cGUgPSAnc3RyaW5nJzsgLy8gZmFsbGJhY2tcclxuICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0gY2F0Y2ggKGNlbGxFcnJvcikge1xyXG4gICAgICAgICAgICAgIGNvbnNvbGUud2FybihgRXJyb3IgcHJvY2Vzc2luZyBjZWxsICR7Y2VsbEFkZHJlc3N9OmAsIGNlbGxFcnJvcik7XHJcbiAgICAgICAgICAgICAgY2VsbFZhbHVlID0gY2VsbC53IHx8IGNlbGwudiB8fCAnJztcclxuICAgICAgICAgICAgICBjZWxsVHlwZSA9ICdzdHJpbmcnO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgICBcclxuICAgICAgICAgIHJvd0RhdGEucHVzaCh7XHJcbiAgICAgICAgICAgIHZhbHVlOiBjZWxsVmFsdWUsXHJcbiAgICAgICAgICAgIHR5cGU6IGNlbGxUeXBlLFxyXG4gICAgICAgICAgICBhZGRyZXNzOiBjZWxsQWRkcmVzcyxcclxuICAgICAgICAgICAgZm9ybXVsYSxcclxuICAgICAgICAgIH0pO1xyXG4gICAgICAgIH1cclxuICAgICAgICBkYXRhLnB1c2gocm93RGF0YSk7XHJcbiAgICAgIH1cclxuICAgICAgXHJcbiAgICAgIC8vIEFuYWx5emUgZGF0YSB0eXBlcyBmb3IgZWFjaCBjb2x1bW4gd2l0aCBiZXR0ZXIgZGV0ZWN0aW9uXHJcbiAgICAgIGNvbnN0IGRhdGFUeXBlczogQ29sdW1uRGF0YVR5cGVbXSA9IGhlYWRlcnMubWFwKChoZWFkZXIsIGNvbEluZGV4KSA9PiB7XHJcbiAgICAgICAgY29uc3QgY29sdW1uRGF0YSA9IGRhdGEuc2xpY2UoMSkubWFwKHJvdyA9PiByb3dbY29sSW5kZXhdPy52YWx1ZSkuZmlsdGVyKHYgPT4gdiAhPT0gbnVsbCAmJiB2ICE9PSB1bmRlZmluZWQgJiYgdiAhPT0gJycpO1xyXG4gICAgICAgIGNvbnN0IHVuaXF1ZVZhbHVlcyA9IEFycmF5LmZyb20obmV3IFNldChjb2x1bW5EYXRhKSk7XHJcbiAgICAgICAgXHJcbiAgICAgICAgLy8gRGV0ZXJtaW5lIGRhdGEgdHlwZSB3aXRoIGltcHJvdmVkIGxvZ2ljXHJcbiAgICAgICAgbGV0IGRhdGFUeXBlOiBDb2x1bW5EYXRhVHlwZVsnZGF0YVR5cGUnXSA9ICd0ZXh0JztcclxuICAgICAgICBpZiAoY29sdW1uRGF0YS5sZW5ndGggPiAwKSB7XHJcbiAgICAgICAgICBjb25zdCBudW1iZXJDb3VudCA9IGNvbHVtbkRhdGEuZmlsdGVyKHYgPT4gdHlwZW9mIHYgPT09ICdudW1iZXInIHx8ICghaXNOYU4oTnVtYmVyKHYpKSAmJiB2ICE9PSAnJykpLmxlbmd0aDtcclxuICAgICAgICAgIGNvbnN0IGRhdGVDb3VudCA9IGNvbHVtbkRhdGEuZmlsdGVyKHYgPT4ge1xyXG4gICAgICAgICAgICBpZiAodiBpbnN0YW5jZW9mIERhdGUpIHJldHVybiB0cnVlO1xyXG4gICAgICAgICAgICBpZiAodHlwZW9mIHYgPT09ICdzdHJpbmcnKSB7XHJcbiAgICAgICAgICAgICAgY29uc3QgZGF0ZVRlc3QgPSBuZXcgRGF0ZSh2KTtcclxuICAgICAgICAgICAgICByZXR1cm4gIWlzTmFOKGRhdGVUZXN0LmdldFRpbWUoKSkgJiYgdi5tYXRjaCgvXFxkezEsNH1bLVxcL11cXGR7MSwyfVstXFwvXVxcZHsxLDR9Lyk7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xyXG4gICAgICAgICAgfSkubGVuZ3RoO1xyXG4gICAgICAgICAgXHJcbiAgICAgICAgICBpZiAobnVtYmVyQ291bnQgLyBjb2x1bW5EYXRhLmxlbmd0aCA+IDAuNykgZGF0YVR5cGUgPSAnbnVtYmVyJztcclxuICAgICAgICAgIGVsc2UgaWYgKGRhdGVDb3VudCAvIGNvbHVtbkRhdGEubGVuZ3RoID4gMC43KSBkYXRhVHlwZSA9ICdkYXRlJztcclxuICAgICAgICB9XHJcbiAgICAgICAgXHJcbiAgICAgICAgcmV0dXJuIHsgICAgICAgIGNvbHVtbkluZGV4OiBjb2xJbmRleCxcclxuICAgICAgICBjb2x1bW5MZXR0ZXI6IFhMU1gudXRpbHMuZW5jb2RlX2NvbChjb2xJbmRleCksXHJcbiAgICAgICAgaGVhZGVyOiBoZWFkZXIgfHwgYENvbHVtbiAke2NvbEluZGV4ICsgMX1gLFxyXG4gICAgICAgIGRhdGFUeXBlLFxyXG4gICAgICAgIHNhbXBsZVZhbHVlczogdW5pcXVlVmFsdWVzLnNsaWNlKDAsIDUpLFxyXG4gICAgICAgIHVuaXF1ZUNvdW50OiB1bmlxdWVWYWx1ZXMubGVuZ3RoLFxyXG4gICAgICAgIG51bGxDb3VudDogZGF0YS5zbGljZSgxKS5sZW5ndGggLSBjb2x1bW5EYXRhLmxlbmd0aCxcclxuICAgICAgfTtcclxuICAgIH0pO1xyXG4gICAgXHJcbiAgICAvLyBFeHRyYWN0IGZvcm11bGEgY2VsbHMgd2l0aCBiZXR0ZXIgZXJyb3IgaGFuZGxpbmdcclxuICAgIGNvbnN0IGZvcm11bGFDZWxsczogRm9ybXVsYUNlbGxbXSA9IFtdO1xyXG4gICAgZGF0YS5mb3JFYWNoKChyb3csIHJvd0luZGV4KSA9PiB7XHJcbiAgICAgIHJvdy5mb3JFYWNoKChjZWxsLCBjb2xJbmRleCkgPT4ge1xyXG4gICAgICAgIGlmIChjZWxsLmZvcm11bGEpIHtcclxuICAgICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgIGZvcm11bGFDZWxscy5wdXNoKHtcclxuICAgICAgICAgICAgICBhZGRyZXNzOiBjZWxsLmFkZHJlc3MsXHJcbiAgICAgICAgICAgICAgZm9ybXVsYTogY2VsbC5mb3JtdWxhLFxyXG4gICAgICAgICAgICAgIGRlcGVuZGVuY2llczogZXh0cmFjdEZvcm11bGFEZXBlbmRlbmNpZXMoY2VsbC5mb3JtdWxhKSxcclxuICAgICAgICAgICAgICByZXN1bHQ6IGNlbGwudmFsdWUsXHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgfSBjYXRjaCAoZm9ybXVsYUVycm9yKSB7XHJcbiAgICAgICAgICAgIGNvbnNvbGUud2FybihgRXJyb3IgcHJvY2Vzc2luZyBmb3JtdWxhIGluIGNlbGwgJHtjZWxsLmFkZHJlc3N9OmAsIGZvcm11bGFFcnJvcik7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICB9KTtcclxuICAgIH0pO1xyXG4gICAgXHJcbiAgICBjb25zb2xlLmxvZyhgU2hlZXQgJHtzaGVldE5hbWV9IHByb2Nlc3NlZDogJHtmb3JtdWxhQ2VsbHMubGVuZ3RofSBmb3JtdWxhcyBmb3VuZGApO1xyXG4gICAgXHJcbiAgICByZXR1cm4ge1xyXG4gICAgICBpZDogYHNoZWV0XyR7aW5kZXh9YCxcclxuICAgICAgbmFtZTogc2hlZXROYW1lLFxyXG4gICAgICBkYXRhLFxyXG4gICAgICBoZWFkZXJzLFxyXG4gICAgICByb3dDb3VudCxcclxuICAgICAgY29sdW1uQ291bnQsXHJcbiAgICAgIGRhdGFUeXBlcyxcclxuICAgICAgaGFzRm9ybXVsYXM6IGZvcm11bGFDZWxscy5sZW5ndGggPiAwLFxyXG4gICAgICBmb3JtdWxhQ2VsbHMsXHJcbiAgICB9O1xyXG4gIH0pLmZpbHRlcihzaGVldCA9PiBzaGVldCAhPT0gbnVsbCk7IC8vIFJlbW92ZSBhbnkgbnVsbCBzaGVldHMgIFxyXG4gIGNvbnN0IGZpbmFsV29ya2Jvb2sgPSB7XHJcbiAgICBpZDogYHdvcmtib29rXyR7RGF0ZS5ub3coKX1gLFxyXG4gICAgbmFtZTogZmlsZW5hbWUsXHJcbiAgICBzaGVldHMsXHJcbiAgICB1cGxvYWREYXRlOiBuZXcgRGF0ZSgpLFxyXG4gICAgZmlsZVNpemU6IGJ1ZmZlci5sZW5ndGgsXHJcbiAgICBsYXN0TW9kaWZpZWQ6IG5ldyBEYXRlKCksXHJcbiAgfTtcclxuICBcclxuICBjb25zb2xlLmxvZygnRmluYWwgd29ya2Jvb2sgY3JlYXRlZDonLCB7XHJcbiAgICBuYW1lOiBmaW5hbFdvcmtib29rLm5hbWUsXHJcbiAgICBzaGVldHNDb3VudDogZmluYWxXb3JrYm9vay5zaGVldHMubGVuZ3RoLFxyXG4gICAgdG90YWxGb3JtdWxhczogZmluYWxXb3JrYm9vay5zaGVldHMucmVkdWNlKChzdW0sIHMpID0+IHN1bSArIHMuZm9ybXVsYUNlbGxzLmxlbmd0aCwgMClcclxuICB9KTtcclxuICBcclxuICByZXR1cm4gZmluYWxXb3JrYm9vaztcclxufSBjYXRjaCAoZXJyb3IpIHtcclxuICBjb25zb2xlLmVycm9yKCdFcnJvciBwYXJzaW5nIEV4Y2VsIGZpbGU6JywgZXJyb3IpO1xyXG4gIHRocm93IG5ldyBFcnJvcihgRmFpbGVkIHRvIHBhcnNlIEV4Y2VsIGZpbGU6ICR7ZXJyb3IubWVzc2FnZX1gKTtcclxufVxyXG59XHJcblxyXG5mdW5jdGlvbiBleHRyYWN0Rm9ybXVsYURlcGVuZGVuY2llcyhmb3JtdWxhOiBzdHJpbmcpOiBzdHJpbmdbXSB7XHJcbiAgLy8gU2ltcGxlIHJlZ2V4IHRvIGV4dHJhY3QgY2VsbCByZWZlcmVuY2VzIGxpa2UgQTEsIEIyLCAkQSQxLCBldGMuXHJcbiAgY29uc3QgY2VsbFJlZlJlZ2V4ID0gL1xcJD9bQS1aXStcXCQ/XFxkKy9nO1xyXG4gIGNvbnN0IG1hdGNoZXMgPSBmb3JtdWxhLm1hdGNoKGNlbGxSZWZSZWdleCkgfHwgW107XHJcbiAgcmV0dXJuIEFycmF5LmZyb20obmV3IFNldChtYXRjaGVzKSk7XHJcbn1cclxuXHJcbmV4cG9ydCBkZWZhdWx0IGFzeW5jIGZ1bmN0aW9uIGhhbmRsZXIocmVxOiBOZXh0QXBpUmVxdWVzdCwgcmVzOiBOZXh0QXBpUmVzcG9uc2UpIHtcclxuICBpZiAocmVxLm1ldGhvZCAhPT0gJ1BPU1QnKSB7XHJcbiAgICByZXR1cm4gcmVzLnN0YXR1cyg0MDUpLmpzb24oeyBlcnJvcjogJ01ldGhvZCBub3QgYWxsb3dlZCcgfSk7XHJcbiAgfVxyXG4gIFxyXG4gIHRyeSB7XHJcbiAgICBjb25zdCBmb3JtID0gbmV3IEluY29taW5nRm9ybSh7XHJcbiAgICAgIGtlZXBFeHRlbnNpb25zOiB0cnVlLFxyXG4gICAgICBtYXhGaWxlU2l6ZTogNTAgKiAxMDI0ICogMTAyNCwgLy8gNTBNQlxyXG4gICAgICBtdWx0aXBsZXM6IHRydWUsXHJcbiAgICB9KTtcclxuICAgIFxyXG4gICAgY29uc3QgeyBmaWxlcyB9ID0gYXdhaXQgbmV3IFByb21pc2U8eyBmaWxlczogYW55IH0+KChyZXNvbHZlLCByZWplY3QpID0+IHtcclxuICAgICAgZm9ybS5wYXJzZShyZXEsIChlcnIsIGZpZWxkcywgZmlsZXMpID0+IHtcclxuICAgICAgICBpZiAoZXJyKSB7XHJcbiAgICAgICAgICBjb25zb2xlLmVycm9yKCdGb3JtIHBhcnNlIGVycm9yOicsIGVycik7XHJcbiAgICAgICAgICByZWplY3QoZXJyKTtcclxuICAgICAgICB9IGVsc2Uge1xyXG4gICAgICAgICAgcmVzb2x2ZSh7IGZpbGVzIH0pO1xyXG4gICAgICAgIH1cclxuICAgICAgfSk7XHJcbiAgICB9KTtcclxuICAgIFxyXG4gICAgY29uc29sZS5sb2coJ1JlY2VpdmVkIGZpbGVzOicsIE9iamVjdC5rZXlzKGZpbGVzKSk7XHJcbiAgICBcclxuICAgIC8vIEhhbmRsZSBib3RoIHNpbmdsZSBmaWxlIGFuZCBhcnJheSBvZiBmaWxlc1xyXG4gICAgbGV0IGV4Y2VsRmlsZSA9IGZpbGVzLmV4Y2VsO1xyXG4gICAgaWYgKEFycmF5LmlzQXJyYXkoZXhjZWxGaWxlKSkge1xyXG4gICAgICBleGNlbEZpbGUgPSBleGNlbEZpbGVbMF07XHJcbiAgICB9XHJcbiAgICBcclxuICAgIGlmICghZXhjZWxGaWxlKSB7XHJcbiAgICAgIGNvbnNvbGUubG9nKCdObyBleGNlbCBmaWxlIGZvdW5kIGluOicsIGZpbGVzKTtcclxuICAgICAgcmV0dXJuIHJlcy5zdGF0dXMoNDAwKS5qc29uKHsgZXJyb3I6ICdObyBFeGNlbCBmaWxlIHVwbG9hZGVkJyB9KTtcclxuICAgIH1cclxuICAgIFxyXG4gICAgY29uc29sZS5sb2coJ1Byb2Nlc3NpbmcgZmlsZTonLCBleGNlbEZpbGUub3JpZ2luYWxGaWxlbmFtZSwgJ1NpemU6JywgZXhjZWxGaWxlLnNpemUpO1xyXG4gICAgXHJcbiAgICAvLyBSZWFkIHRoZSBmaWxlIGJ1ZmZlclxyXG4gICAgY29uc3QgYnVmZmVyID0gZnMucmVhZEZpbGVTeW5jKGV4Y2VsRmlsZS5maWxlcGF0aCk7XHJcbiAgICBcclxuICAgIC8vIFBhcnNlIHRoZSBFeGNlbCBmaWxlXHJcbiAgICBjb25zdCB3b3JrYm9vayA9IHBhcnNlRXhjZWxGaWxlKGJ1ZmZlciwgZXhjZWxGaWxlLm9yaWdpbmFsRmlsZW5hbWUgfHwgJ3Vua25vd24ueGxzeCcpO1xyXG4gICAgXHJcbiAgICByZXMuc3RhdHVzKDIwMCkuanNvbih3b3JrYm9vayk7XHJcbiAgfSBjYXRjaCAoZXJyb3IpIHtcclxuICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIHBhcnNpbmcgRXhjZWwgZmlsZTonLCBlcnJvcik7XHJcbiAgICByZXMuc3RhdHVzKDUwMCkuanNvbih7IGVycm9yOiAnRmFpbGVkIHRvIHBhcnNlIEV4Y2VsIGZpbGUnLCBkZXRhaWxzOiBlcnJvci5tZXNzYWdlIH0pO1xyXG4gIH1cclxufVxyXG4iXSwibmFtZXMiOlsiWExTWCIsIkluY29taW5nRm9ybSIsImZzIiwiY29uZmlnIiwiYXBpIiwiYm9keVBhcnNlciIsInBhcnNlRXhjZWxGaWxlIiwiYnVmZmVyIiwiZmlsZW5hbWUiLCJjb25zb2xlIiwibG9nIiwibGVuZ3RoIiwid29ya2Jvb2siLCJyZWFkIiwidHlwZSIsImNlbGxGb3JtdWxhIiwiY2VsbFN0eWxlcyIsImNlbGxEYXRlcyIsImNlbGxORiIsIlNoZWV0TmFtZXMiLCJzaGVldHMiLCJtYXAiLCJzaGVldE5hbWUiLCJpbmRleCIsIndvcmtzaGVldCIsIlNoZWV0cyIsIndhcm4iLCJqc29uRGF0YSIsInV0aWxzIiwic2hlZXRfdG9fanNvbiIsImhlYWRlciIsInJhdyIsImRlZnZhbCIsImJsYW5rcm93cyIsInJhbmdlIiwiZGVjb2RlX3JhbmdlIiwicyIsInIiLCJjIiwiZSIsInJvd0NvdW50IiwiTWF0aCIsIm1heCIsImNvbHVtbkNvdW50Iiwicm93IiwiaGVhZGVycyIsImRhdGEiLCJyb3dEYXRhIiwiY29sIiwiY2VsbEFkZHJlc3MiLCJlbmNvZGVfY2VsbCIsImNlbGwiLCJjZWxsVmFsdWUiLCJjZWxsVHlwZSIsImZvcm11bGEiLCJmIiwidiIsInVuZGVmaW5lZCIsInciLCJEYXRlIiwidCIsImNlbGxFcnJvciIsInB1c2giLCJ2YWx1ZSIsImFkZHJlc3MiLCJkYXRhVHlwZXMiLCJjb2xJbmRleCIsImNvbHVtbkRhdGEiLCJzbGljZSIsImZpbHRlciIsInVuaXF1ZVZhbHVlcyIsIkFycmF5IiwiZnJvbSIsIlNldCIsImRhdGFUeXBlIiwibnVtYmVyQ291bnQiLCJpc05hTiIsIk51bWJlciIsImRhdGVDb3VudCIsImRhdGVUZXN0IiwiZ2V0VGltZSIsIm1hdGNoIiwiY29sdW1uSW5kZXgiLCJjb2x1bW5MZXR0ZXIiLCJlbmNvZGVfY29sIiwic2FtcGxlVmFsdWVzIiwidW5pcXVlQ291bnQiLCJudWxsQ291bnQiLCJmb3JtdWxhQ2VsbHMiLCJmb3JFYWNoIiwicm93SW5kZXgiLCJkZXBlbmRlbmNpZXMiLCJleHRyYWN0Rm9ybXVsYURlcGVuZGVuY2llcyIsInJlc3VsdCIsImZvcm11bGFFcnJvciIsImlkIiwibmFtZSIsImhhc0Zvcm11bGFzIiwic2hlZXQiLCJmaW5hbFdvcmtib29rIiwibm93IiwidXBsb2FkRGF0ZSIsImZpbGVTaXplIiwibGFzdE1vZGlmaWVkIiwic2hlZXRzQ291bnQiLCJ0b3RhbEZvcm11bGFzIiwicmVkdWNlIiwic3VtIiwiZXJyb3IiLCJFcnJvciIsIm1lc3NhZ2UiLCJjZWxsUmVmUmVnZXgiLCJtYXRjaGVzIiwiaGFuZGxlciIsInJlcSIsInJlcyIsIm1ldGhvZCIsInN0YXR1cyIsImpzb24iLCJmb3JtIiwia2VlcEV4dGVuc2lvbnMiLCJtYXhGaWxlU2l6ZSIsIm11bHRpcGxlcyIsImZpbGVzIiwiUHJvbWlzZSIsInJlc29sdmUiLCJyZWplY3QiLCJwYXJzZSIsImVyciIsImZpZWxkcyIsIk9iamVjdCIsImtleXMiLCJleGNlbEZpbGUiLCJleGNlbCIsImlzQXJyYXkiLCJvcmlnaW5hbEZpbGVuYW1lIiwic2l6ZSIsInJlYWRGaWxlU3luYyIsImZpbGVwYXRoIiwiZGV0YWlscyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(api)/./pages/api/excel/parse.ts\n");

/***/ })

};
;

// load runtime
var __webpack_require__ = require("../../../webpack-api-runtime.js");
__webpack_require__.C(exports);
var __webpack_exec__ = (moduleId) => (__webpack_require__(__webpack_require__.s = moduleId))
var __webpack_exports__ = __webpack_require__.X(0, ["vendor-chunks/next"], () => (__webpack_exec__("(api)/./node_modules/next/dist/build/webpack/loaders/next-route-loader/index.js?kind=PAGES_API&page=%2Fapi%2Fexcel%2Fparse&preferredRegion=&absolutePagePath=.%2Fpages%5Capi%5Cexcel%5Cparse.ts&middlewareConfigBase64=e30%3D!")));
module.exports = __webpack_exports__;

})();