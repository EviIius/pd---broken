"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(() => {
var exports = {};
exports.id = "pages/api/excel/parse";
exports.ids = ["pages/api/excel/parse"];
exports.modules = {

/***/ "next/dist/compiled/next-server/pages-api.runtime.dev.js":
/*!**************************************************************************!*\
  !*** external "next/dist/compiled/next-server/pages-api.runtime.dev.js" ***!
  \**************************************************************************/
/***/ ((module) => {

module.exports = require("next/dist/compiled/next-server/pages-api.runtime.dev.js");

/***/ }),

/***/ "xlsx":
/*!***********************!*\
  !*** external "xlsx" ***!
  \***********************/
/***/ ((module) => {

module.exports = require("xlsx");

/***/ }),

/***/ "formidable":
/*!*****************************!*\
  !*** external "formidable" ***!
  \*****************************/
/***/ ((module) => {

module.exports = import("formidable");;

/***/ }),

/***/ "fs":
/*!*********************!*\
  !*** external "fs" ***!
  \*********************/
/***/ ((module) => {

module.exports = require("fs");

/***/ }),

/***/ "(api)/./node_modules/next/dist/build/webpack/loaders/next-route-loader/index.js?kind=PAGES_API&page=%2Fapi%2Fexcel%2Fparse&preferredRegion=&absolutePagePath=.%2Fpages%5Capi%5Cexcel%5Cparse.ts&middlewareConfigBase64=e30%3D!":
/*!********************************************************************************************************************************************************************************************************************************!*\
  !*** ./node_modules/next/dist/build/webpack/loaders/next-route-loader/index.js?kind=PAGES_API&page=%2Fapi%2Fexcel%2Fparse&preferredRegion=&absolutePagePath=.%2Fpages%5Capi%5Cexcel%5Cparse.ts&middlewareConfigBase64=e30%3D! ***!
  \********************************************************************************************************************************************************************************************************************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.a(module, async (__webpack_handle_async_dependencies__, __webpack_async_result__) => { try {\n__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   config: () => (/* binding */ config),\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__),\n/* harmony export */   routeModule: () => (/* binding */ routeModule)\n/* harmony export */ });\n/* harmony import */ var next_dist_server_future_route_modules_pages_api_module_compiled__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! next/dist/server/future/route-modules/pages-api/module.compiled */ \"(api)/./node_modules/next/dist/server/future/route-modules/pages-api/module.compiled.js\");\n/* harmony import */ var next_dist_server_future_route_modules_pages_api_module_compiled__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(next_dist_server_future_route_modules_pages_api_module_compiled__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var next_dist_server_future_route_kind__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! next/dist/server/future/route-kind */ \"(api)/./node_modules/next/dist/server/future/route-kind.js\");\n/* harmony import */ var next_dist_build_templates_helpers__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! next/dist/build/templates/helpers */ \"(api)/./node_modules/next/dist/build/templates/helpers.js\");\n/* harmony import */ var _pages_api_excel_parse_ts__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./pages\\api\\excel\\parse.ts */ \"(api)/./pages/api/excel/parse.ts\");\nvar __webpack_async_dependencies__ = __webpack_handle_async_dependencies__([_pages_api_excel_parse_ts__WEBPACK_IMPORTED_MODULE_3__]);\n_pages_api_excel_parse_ts__WEBPACK_IMPORTED_MODULE_3__ = (__webpack_async_dependencies__.then ? (await __webpack_async_dependencies__)() : __webpack_async_dependencies__)[0];\n\n\n\n// Import the userland code.\n\n// Re-export the handler (should be the default export).\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ((0,next_dist_build_templates_helpers__WEBPACK_IMPORTED_MODULE_2__.hoist)(_pages_api_excel_parse_ts__WEBPACK_IMPORTED_MODULE_3__, \"default\"));\n// Re-export config.\nconst config = (0,next_dist_build_templates_helpers__WEBPACK_IMPORTED_MODULE_2__.hoist)(_pages_api_excel_parse_ts__WEBPACK_IMPORTED_MODULE_3__, \"config\");\n// Create and export the route module that will be consumed.\nconst routeModule = new next_dist_server_future_route_modules_pages_api_module_compiled__WEBPACK_IMPORTED_MODULE_0__.PagesAPIRouteModule({\n    definition: {\n        kind: next_dist_server_future_route_kind__WEBPACK_IMPORTED_MODULE_1__.RouteKind.PAGES_API,\n        page: \"/api/excel/parse\",\n        pathname: \"/api/excel/parse\",\n        // The following aren't used in production.\n        bundlePath: \"\",\n        filename: \"\"\n    },\n    userland: _pages_api_excel_parse_ts__WEBPACK_IMPORTED_MODULE_3__\n});\n\n//# sourceMappingURL=pages-api.js.map\n__webpack_async_result__();\n} catch(e) { __webpack_async_result__(e); } });//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwaSkvLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2J1aWxkL3dlYnBhY2svbG9hZGVycy9uZXh0LXJvdXRlLWxvYWRlci9pbmRleC5qcz9raW5kPVBBR0VTX0FQSSZwYWdlPSUyRmFwaSUyRmV4Y2VsJTJGcGFyc2UmcHJlZmVycmVkUmVnaW9uPSZhYnNvbHV0ZVBhZ2VQYXRoPS4lMkZwYWdlcyU1Q2FwaSU1Q2V4Y2VsJTVDcGFyc2UudHMmbWlkZGxld2FyZUNvbmZpZ0Jhc2U2ND1lMzAlM0QhIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7O0FBQXNHO0FBQ3ZDO0FBQ0w7QUFDMUQ7QUFDMEQ7QUFDMUQ7QUFDQSxpRUFBZSx3RUFBSyxDQUFDLHNEQUFRLFlBQVksRUFBQztBQUMxQztBQUNPLGVBQWUsd0VBQUssQ0FBQyxzREFBUTtBQUNwQztBQUNPLHdCQUF3QixnSEFBbUI7QUFDbEQ7QUFDQSxjQUFjLHlFQUFTO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsWUFBWTtBQUNaLENBQUM7O0FBRUQscUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9mcm9udGVuZC8/MjFmZCJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBQYWdlc0FQSVJvdXRlTW9kdWxlIH0gZnJvbSBcIm5leHQvZGlzdC9zZXJ2ZXIvZnV0dXJlL3JvdXRlLW1vZHVsZXMvcGFnZXMtYXBpL21vZHVsZS5jb21waWxlZFwiO1xuaW1wb3J0IHsgUm91dGVLaW5kIH0gZnJvbSBcIm5leHQvZGlzdC9zZXJ2ZXIvZnV0dXJlL3JvdXRlLWtpbmRcIjtcbmltcG9ydCB7IGhvaXN0IH0gZnJvbSBcIm5leHQvZGlzdC9idWlsZC90ZW1wbGF0ZXMvaGVscGVyc1wiO1xuLy8gSW1wb3J0IHRoZSB1c2VybGFuZCBjb2RlLlxuaW1wb3J0ICogYXMgdXNlcmxhbmQgZnJvbSBcIi4vcGFnZXNcXFxcYXBpXFxcXGV4Y2VsXFxcXHBhcnNlLnRzXCI7XG4vLyBSZS1leHBvcnQgdGhlIGhhbmRsZXIgKHNob3VsZCBiZSB0aGUgZGVmYXVsdCBleHBvcnQpLlxuZXhwb3J0IGRlZmF1bHQgaG9pc3QodXNlcmxhbmQsIFwiZGVmYXVsdFwiKTtcbi8vIFJlLWV4cG9ydCBjb25maWcuXG5leHBvcnQgY29uc3QgY29uZmlnID0gaG9pc3QodXNlcmxhbmQsIFwiY29uZmlnXCIpO1xuLy8gQ3JlYXRlIGFuZCBleHBvcnQgdGhlIHJvdXRlIG1vZHVsZSB0aGF0IHdpbGwgYmUgY29uc3VtZWQuXG5leHBvcnQgY29uc3Qgcm91dGVNb2R1bGUgPSBuZXcgUGFnZXNBUElSb3V0ZU1vZHVsZSh7XG4gICAgZGVmaW5pdGlvbjoge1xuICAgICAgICBraW5kOiBSb3V0ZUtpbmQuUEFHRVNfQVBJLFxuICAgICAgICBwYWdlOiBcIi9hcGkvZXhjZWwvcGFyc2VcIixcbiAgICAgICAgcGF0aG5hbWU6IFwiL2FwaS9leGNlbC9wYXJzZVwiLFxuICAgICAgICAvLyBUaGUgZm9sbG93aW5nIGFyZW4ndCB1c2VkIGluIHByb2R1Y3Rpb24uXG4gICAgICAgIGJ1bmRsZVBhdGg6IFwiXCIsXG4gICAgICAgIGZpbGVuYW1lOiBcIlwiXG4gICAgfSxcbiAgICB1c2VybGFuZFxufSk7XG5cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXBhZ2VzLWFwaS5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(api)/./node_modules/next/dist/build/webpack/loaders/next-route-loader/index.js?kind=PAGES_API&page=%2Fapi%2Fexcel%2Fparse&preferredRegion=&absolutePagePath=.%2Fpages%5Capi%5Cexcel%5Cparse.ts&middlewareConfigBase64=e30%3D!\n");

/***/ }),

/***/ "(api)/./pages/api/excel/parse.ts":
/*!**********************************!*\
  !*** ./pages/api/excel/parse.ts ***!
  \**********************************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.a(module, async (__webpack_handle_async_dependencies__, __webpack_async_result__) => { try {\n__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   config: () => (/* binding */ config),\n/* harmony export */   \"default\": () => (/* binding */ handler)\n/* harmony export */ });\n/* harmony import */ var xlsx__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! xlsx */ \"xlsx\");\n/* harmony import */ var xlsx__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(xlsx__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var formidable__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! formidable */ \"formidable\");\n/* harmony import */ var fs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! fs */ \"fs\");\n/* harmony import */ var fs__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(fs__WEBPACK_IMPORTED_MODULE_2__);\nvar __webpack_async_dependencies__ = __webpack_handle_async_dependencies__([formidable__WEBPACK_IMPORTED_MODULE_1__]);\nformidable__WEBPACK_IMPORTED_MODULE_1__ = (__webpack_async_dependencies__.then ? (await __webpack_async_dependencies__)() : __webpack_async_dependencies__)[0];\n\n\n\n// Disable default body parser for file uploads\nconst config = {\n    api: {\n        bodyParser: false\n    }\n};\nfunction parseExcelFile(buffer, filename) {\n    console.log(\"Parsing Excel file:\", filename, \"Buffer size:\", buffer.length);\n    try {\n        const workbook = xlsx__WEBPACK_IMPORTED_MODULE_0__.read(buffer, {\n            type: \"buffer\",\n            cellFormula: true,\n            cellStyles: true,\n            cellDates: true,\n            cellNF: false\n        });\n        console.log(\"Workbook sheets found:\", workbook.SheetNames);\n        const sheets = workbook.SheetNames.map((sheetName, index)=>{\n            console.log(\"Processing sheet:\", sheetName);\n            const worksheet = workbook.Sheets[sheetName];\n            if (!worksheet) {\n                console.warn(\"Worksheet is empty:\", sheetName);\n                return null;\n            }\n            const jsonData = xlsx__WEBPACK_IMPORTED_MODULE_0__.utils.sheet_to_json(worksheet, {\n                header: 1,\n                raw: false,\n                defval: null,\n                blankrows: false\n            });\n            // Get the range of the worksheet\n            const range = worksheet[\"!ref\"] ? xlsx__WEBPACK_IMPORTED_MODULE_0__.utils.decode_range(worksheet[\"!ref\"]) : {\n                s: {\n                    r: 0,\n                    c: 0\n                },\n                e: {\n                    r: 0,\n                    c: 0\n                }\n            };\n            const rowCount = Math.max(jsonData.length, range.e.r + 1);\n            const columnCount = Math.max(range.e.c + 1, Math.max(...jsonData.map((row)=>row.length)));\n            console.log(`Sheet ${sheetName}: ${rowCount} rows, ${columnCount} columns`);\n            // Extract headers (first row) - handle empty rows\n            const headers = jsonData.length > 0 ? jsonData[0] || [] : [];\n            // Convert to our ExcelCell format with better error handling\n            const data = [];\n            for(let row = 0; row < rowCount; row++){\n                const rowData = [];\n                for(let col = 0; col < columnCount; col++){\n                    const cellAddress = xlsx__WEBPACK_IMPORTED_MODULE_0__.utils.encode_cell({\n                        r: row,\n                        c: col\n                    });\n                    const cell = worksheet[cellAddress];\n                    let cellValue = null;\n                    let cellType = \"empty\";\n                    let formula;\n                    if (cell) {\n                        try {\n                            if (cell.f) {\n                                formula = cell.f;\n                                cellType = \"formula\";\n                                cellValue = cell.v !== undefined ? cell.v : cell.w || \"\";\n                            } else if (cell.v !== undefined) {\n                                cellValue = cell.v;\n                                if (typeof cell.v === \"string\") cellType = \"string\";\n                                else if (typeof cell.v === \"number\") cellType = \"number\";\n                                else if (typeof cell.v === \"boolean\") cellType = \"boolean\";\n                                else if (cell.v instanceof Date || cell.t === \"d\") cellType = \"date\";\n                                else cellType = \"string\"; // fallback\n                            }\n                        } catch (cellError) {\n                            console.warn(`Error processing cell ${cellAddress}:`, cellError);\n                            cellValue = cell.w || cell.v || \"\";\n                            cellType = \"string\";\n                        }\n                    }\n                    rowData.push({\n                        value: cellValue,\n                        type: cellType,\n                        address: cellAddress,\n                        formula\n                    });\n                }\n                data.push(rowData);\n            }\n            // Analyze data types for each column with better detection\n            const dataTypes = headers.map((header, colIndex)=>{\n                const columnData = data.slice(1).map((row)=>row[colIndex]?.value).filter((v)=>v !== null && v !== undefined && v !== \"\");\n                const uniqueValues = Array.from(new Set(columnData));\n                // Determine data type with improved logic\n                let dataType = \"text\";\n                if (columnData.length > 0) {\n                    const numberCount = columnData.filter((v)=>typeof v === \"number\" || !isNaN(Number(v)) && v !== \"\").length;\n                    const dateCount = columnData.filter((v)=>{\n                        if (v instanceof Date) return true;\n                        if (typeof v === \"string\") {\n                            const dateTest = new Date(v);\n                            return !isNaN(dateTest.getTime()) && v.match(/\\d{1,4}[-\\/]\\d{1,2}[-\\/]\\d{1,4}/);\n                        }\n                        return false;\n                    }).length;\n                    if (numberCount / columnData.length > 0.7) dataType = \"number\";\n                    else if (dateCount / columnData.length > 0.7) dataType = \"date\";\n                }\n                return {\n                    columnIndex: colIndex,\n                    columnLetter: xlsx__WEBPACK_IMPORTED_MODULE_0__.utils.encode_col(colIndex),\n                    header: header || `Column ${colIndex + 1}`,\n                    dataType,\n                    sampleValues: uniqueValues.slice(0, 5),\n                    uniqueCount: uniqueValues.length,\n                    nullCount: data.slice(1).length - columnData.length\n                };\n            });\n            // Extract formula cells with better error handling\n            const formulaCells = [];\n            data.forEach((row, rowIndex)=>{\n                row.forEach((cell, colIndex)=>{\n                    if (cell.formula) {\n                        try {\n                            formulaCells.push({\n                                address: cell.address,\n                                formula: cell.formula,\n                                dependencies: extractFormulaDependencies(cell.formula),\n                                result: cell.value\n                            });\n                        } catch (formulaError) {\n                            console.warn(`Error processing formula in cell ${cell.address}:`, formulaError);\n                        }\n                    }\n                });\n            });\n            console.log(`Sheet ${sheetName} processed: ${formulaCells.length} formulas found`);\n            return {\n                id: `sheet_${index}`,\n                name: sheetName,\n                data,\n                headers,\n                rowCount,\n                columnCount,\n                dataTypes,\n                hasFormulas: formulaCells.length > 0,\n                formulaCells\n            };\n        }).filter((sheet)=>sheet !== null); // Remove any null sheets  \n        const finalWorkbook = {\n            id: `workbook_${Date.now()}`,\n            name: filename,\n            sheets,\n            uploadDate: new Date(),\n            fileSize: buffer.length,\n            lastModified: new Date()\n        };\n        console.log(\"Final workbook created:\", {\n            name: finalWorkbook.name,\n            sheetsCount: finalWorkbook.sheets.length,\n            totalFormulas: finalWorkbook.sheets.reduce((sum, s)=>sum + s.formulaCells.length, 0)\n        });\n        return finalWorkbook;\n    } catch (error) {\n        console.error(\"Error parsing Excel file:\", error);\n        throw new Error(`Failed to parse Excel file: ${error.message}`);\n    }\n}\nfunction extractFormulaDependencies(formula) {\n    // Simple regex to extract cell references like A1, B2, $A$1, etc.\n    const cellRefRegex = /\\$?[A-Z]+\\$?\\d+/g;\n    const matches = formula.match(cellRefRegex) || [];\n    return Array.from(new Set(matches));\n}\nasync function handler(req, res) {\n    if (req.method !== \"POST\") {\n        return res.status(405).json({\n            error: \"Method not allowed\"\n        });\n    }\n    try {\n        const form = new formidable__WEBPACK_IMPORTED_MODULE_1__.IncomingForm({\n            keepExtensions: true,\n            maxFileSize: 50 * 1024 * 1024,\n            multiples: true\n        });\n        const { files } = await new Promise((resolve, reject)=>{\n            form.parse(req, (err, fields, files)=>{\n                if (err) {\n                    console.error(\"Form parse error:\", err);\n                    reject(err);\n                } else {\n                    resolve({\n                        files\n                    });\n                }\n            });\n        });\n        console.log(\"Received files:\", Object.keys(files));\n        // Handle both single file and array of files\n        let excelFile = files.excel;\n        if (Array.isArray(excelFile)) {\n            excelFile = excelFile[0];\n        }\n        if (!excelFile) {\n            console.log(\"No excel file found in:\", files);\n            return res.status(400).json({\n                error: \"No Excel file uploaded\"\n            });\n        }\n        console.log(\"Processing file:\", excelFile.originalFilename, \"Size:\", excelFile.size);\n        // Read the file buffer\n        const buffer = fs__WEBPACK_IMPORTED_MODULE_2___default().readFileSync(excelFile.filepath);\n        // Parse the Excel file\n        const workbook = parseExcelFile(buffer, excelFile.originalFilename || \"unknown.xlsx\");\n        res.status(200).json(workbook);\n    } catch (error) {\n        console.error(\"Error parsing Excel file:\", error);\n        res.status(500).json({\n            error: \"Failed to parse Excel file\",\n            details: error.message\n        });\n    }\n}\n\n__webpack_async_result__();\n} catch(e) { __webpack_async_result__(e); } });//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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QUFDLEtBQUtDLElBQUksQ0FBQztnQkFBRVYsT0FBTztZQUF5QjtRQUNoRTtRQUVBbkcsUUFBUUMsR0FBRyxDQUFDLG9CQUFvQjBILFVBQVVHLGdCQUFnQixFQUFFLFNBQVNILFVBQVVJLElBQUk7UUFFbkYsdUJBQXVCO1FBQ3ZCLE1BQU1qSSxTQUFTTCxzREFBZSxDQUFDa0ksVUFBVU0sUUFBUTtRQUVqRCx1QkFBdUI7UUFDdkIsTUFBTTlILFdBQVdOLGVBQWVDLFFBQVE2SCxVQUFVRyxnQkFBZ0IsSUFBSTtRQUV0RXBCLElBQUlFLE1BQU0sQ0FBQyxLQUFLQyxJQUFJLENBQUMxRztJQUN2QixFQUFFLE9BQU9nRyxPQUFPO1FBQ2RuRyxRQUFRbUcsS0FBSyxDQUFDLDZCQUE2QkE7UUFDM0NPLElBQUlFLE1BQU0sQ0FBQyxLQUFLQyxJQUFJLENBQUM7WUFBRVYsT0FBTztZQUE4QitCLFNBQVMvQixNQUFNRSxPQUFPO1FBQUM7SUFDckY7QUFDRiIsInNvdXJjZXMiOlsid2VicGFjazovL2Zyb250ZW5kLy4vcGFnZXMvYXBpL2V4Y2VsL3BhcnNlLnRzPzA4ZmEiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgTmV4dEFwaVJlcXVlc3QsIE5leHRBcGlSZXNwb25zZSB9IGZyb20gJ25leHQnO1xyXG5pbXBvcnQgKiBhcyBYTFNYIGZyb20gJ3hsc3gnO1xyXG5pbXBvcnQgeyBJbmNvbWluZ0Zvcm0sIEZpbGUgYXMgRm9ybWlkYWJsZUZpbGUgfSBmcm9tICdmb3JtaWRhYmxlJztcclxuaW1wb3J0IGZzIGZyb20gJ2ZzJztcclxuaW1wb3J0IHsgRXhjZWxXb3JrYm9vaywgRXhjZWxXb3Jrc2hlZXQsIEV4Y2VsQ2VsbCwgQ29sdW1uRGF0YVR5cGUsIEZvcm11bGFDZWxsIH0gZnJvbSAnLi4vLi4vLi4vdHlwZXMvZXhjZWwnO1xyXG5cclxuLy8gRGlzYWJsZSBkZWZhdWx0IGJvZHkgcGFyc2VyIGZvciBmaWxlIHVwbG9hZHNcclxuZXhwb3J0IGNvbnN0IGNvbmZpZyA9IHtcclxuICBhcGk6IHtcclxuICAgIGJvZHlQYXJzZXI6IGZhbHNlLFxyXG4gIH0sXHJcbn07XHJcblxyXG5mdW5jdGlvbiBwYXJzZUV4Y2VsRmlsZShidWZmZXI6IEJ1ZmZlciwgZmlsZW5hbWU6IHN0cmluZyk6IEV4Y2VsV29ya2Jvb2sge1xyXG4gIGNvbnNvbGUubG9nKCdQYXJzaW5nIEV4Y2VsIGZpbGU6JywgZmlsZW5hbWUsICdCdWZmZXIgc2l6ZTonLCBidWZmZXIubGVuZ3RoKTtcclxuICBcclxuICB0cnkge1xyXG4gICAgY29uc3Qgd29ya2Jvb2sgPSBYTFNYLnJlYWQoYnVmZmVyLCB7IFxyXG4gICAgICB0eXBlOiAnYnVmZmVyJywgXHJcbiAgICAgIGNlbGxGb3JtdWxhOiB0cnVlLCBcclxuICAgICAgY2VsbFN0eWxlczogdHJ1ZSxcclxuICAgICAgY2VsbERhdGVzOiB0cnVlLFxyXG4gICAgICBjZWxsTkY6IGZhbHNlXHJcbiAgICB9KTtcclxuICAgIFxyXG4gICAgY29uc29sZS5sb2coJ1dvcmtib29rIHNoZWV0cyBmb3VuZDonLCB3b3JrYm9vay5TaGVldE5hbWVzKTtcclxuICAgIFxyXG4gICAgY29uc3Qgc2hlZXRzOiBFeGNlbFdvcmtzaGVldFtdID0gd29ya2Jvb2suU2hlZXROYW1lcy5tYXAoKHNoZWV0TmFtZSwgaW5kZXgpID0+IHtcclxuICAgICAgY29uc29sZS5sb2coJ1Byb2Nlc3Npbmcgc2hlZXQ6Jywgc2hlZXROYW1lKTtcclxuICAgICAgY29uc3Qgd29ya3NoZWV0ID0gd29ya2Jvb2suU2hlZXRzW3NoZWV0TmFtZV07XHJcbiAgICAgIFxyXG4gICAgICBpZiAoIXdvcmtzaGVldCkge1xyXG4gICAgICAgIGNvbnNvbGUud2FybignV29ya3NoZWV0IGlzIGVtcHR5OicsIHNoZWV0TmFtZSk7XHJcbiAgICAgICAgcmV0dXJuIG51bGw7XHJcbiAgICAgIH1cclxuICAgICAgXHJcbiAgICAgIGNvbnN0IGpzb25EYXRhID0gWExTWC51dGlscy5zaGVldF90b19qc29uKHdvcmtzaGVldCwgeyBcclxuICAgICAgICBoZWFkZXI6IDEsIFxyXG4gICAgICAgIHJhdzogZmFsc2UsIFxyXG4gICAgICAgIGRlZnZhbDogbnVsbCxcclxuICAgICAgICBibGFua3Jvd3M6IGZhbHNlXHJcbiAgICAgIH0pO1xyXG4gICAgICBcclxuICAgICAgLy8gR2V0IHRoZSByYW5nZSBvZiB0aGUgd29ya3NoZWV0XHJcbiAgICAgIGNvbnN0IHJhbmdlID0gd29ya3NoZWV0WychcmVmJ10gPyBYTFNYLnV0aWxzLmRlY29kZV9yYW5nZSh3b3Jrc2hlZXRbJyFyZWYnXSkgOiB7IHM6IHsgcjogMCwgYzogMCB9LCBlOiB7IHI6IDAsIGM6IDAgfSB9O1xyXG4gICAgICBjb25zdCByb3dDb3VudCA9IE1hdGgubWF4KGpzb25EYXRhLmxlbmd0aCwgcmFuZ2UuZS5yICsgMSk7XHJcbiAgICAgIGNvbnN0IGNvbHVtbkNvdW50ID0gTWF0aC5tYXgocmFuZ2UuZS5jICsgMSwgTWF0aC5tYXgoLi4uanNvbkRhdGEubWFwKChyb3c6IGFueVtdKSA9PiByb3cubGVuZ3RoKSkpO1xyXG4gICAgICBcclxuICAgICAgY29uc29sZS5sb2coYFNoZWV0ICR7c2hlZXROYW1lfTogJHtyb3dDb3VudH0gcm93cywgJHtjb2x1bW5Db3VudH0gY29sdW1uc2ApOyAgICAgIFxyXG4gICAgICAvLyBFeHRyYWN0IGhlYWRlcnMgKGZpcnN0IHJvdykgLSBoYW5kbGUgZW1wdHkgcm93c1xyXG4gICAgICBjb25zdCBoZWFkZXJzID0ganNvbkRhdGEubGVuZ3RoID4gMCA/IChqc29uRGF0YVswXSBhcyBzdHJpbmdbXSB8fCBbXSkgOiBbXTtcclxuICAgICAgXHJcbiAgICAgIC8vIENvbnZlcnQgdG8gb3VyIEV4Y2VsQ2VsbCBmb3JtYXQgd2l0aCBiZXR0ZXIgZXJyb3IgaGFuZGxpbmdcclxuICAgICAgY29uc3QgZGF0YTogRXhjZWxDZWxsW11bXSA9IFtdO1xyXG4gICAgICBmb3IgKGxldCByb3cgPSAwOyByb3cgPCByb3dDb3VudDsgcm93KyspIHtcclxuICAgICAgICBjb25zdCByb3dEYXRhOiBFeGNlbENlbGxbXSA9IFtdO1xyXG4gICAgICAgIGZvciAobGV0IGNvbCA9IDA7IGNvbCA8IGNvbHVtbkNvdW50OyBjb2wrKykge1xyXG4gICAgICAgICAgY29uc3QgY2VsbEFkZHJlc3MgPSBYTFNYLnV0aWxzLmVuY29kZV9jZWxsKHsgcjogcm93LCBjOiBjb2wgfSk7XHJcbiAgICAgICAgICBjb25zdCBjZWxsID0gd29ya3NoZWV0W2NlbGxBZGRyZXNzXTtcclxuICAgICAgICAgIFxyXG4gICAgICAgICAgbGV0IGNlbGxWYWx1ZSA9IG51bGw7XHJcbiAgICAgICAgICBsZXQgY2VsbFR5cGU6IEV4Y2VsQ2VsbFsndHlwZSddID0gJ2VtcHR5JztcclxuICAgICAgICAgIGxldCBmb3JtdWxhOiBzdHJpbmcgfCB1bmRlZmluZWQ7XHJcbiAgICAgICAgICBcclxuICAgICAgICAgIGlmIChjZWxsKSB7XHJcbiAgICAgICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgICAgaWYgKGNlbGwuZikge1xyXG4gICAgICAgICAgICAgICAgZm9ybXVsYSA9IGNlbGwuZjtcclxuICAgICAgICAgICAgICAgIGNlbGxUeXBlID0gJ2Zvcm11bGEnO1xyXG4gICAgICAgICAgICAgICAgY2VsbFZhbHVlID0gY2VsbC52ICE9PSB1bmRlZmluZWQgPyBjZWxsLnYgOiBjZWxsLncgfHwgJyc7XHJcbiAgICAgICAgICAgICAgfSBlbHNlIGlmIChjZWxsLnYgIT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgICAgICAgICAgY2VsbFZhbHVlID0gY2VsbC52O1xyXG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBjZWxsLnYgPT09ICdzdHJpbmcnKSBjZWxsVHlwZSA9ICdzdHJpbmcnO1xyXG4gICAgICAgICAgICAgICAgZWxzZSBpZiAodHlwZW9mIGNlbGwudiA9PT0gJ251bWJlcicpIGNlbGxUeXBlID0gJ251bWJlcic7XHJcbiAgICAgICAgICAgICAgICBlbHNlIGlmICh0eXBlb2YgY2VsbC52ID09PSAnYm9vbGVhbicpIGNlbGxUeXBlID0gJ2Jvb2xlYW4nO1xyXG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoY2VsbC52IGluc3RhbmNlb2YgRGF0ZSB8fCBjZWxsLnQgPT09ICdkJykgY2VsbFR5cGUgPSAnZGF0ZSc7XHJcbiAgICAgICAgICAgICAgICBlbHNlIGNlbGxUeXBlID0gJ3N0cmluZyc7IC8vIGZhbGxiYWNrXHJcbiAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9IGNhdGNoIChjZWxsRXJyb3IpIHtcclxuICAgICAgICAgICAgICBjb25zb2xlLndhcm4oYEVycm9yIHByb2Nlc3NpbmcgY2VsbCAke2NlbGxBZGRyZXNzfTpgLCBjZWxsRXJyb3IpO1xyXG4gICAgICAgICAgICAgIGNlbGxWYWx1ZSA9IGNlbGwudyB8fCBjZWxsLnYgfHwgJyc7XHJcbiAgICAgICAgICAgICAgY2VsbFR5cGUgPSAnc3RyaW5nJztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgfVxyXG4gICAgICAgICAgXHJcbiAgICAgICAgICByb3dEYXRhLnB1c2goe1xyXG4gICAgICAgICAgICB2YWx1ZTogY2VsbFZhbHVlLFxyXG4gICAgICAgICAgICB0eXBlOiBjZWxsVHlwZSxcclxuICAgICAgICAgICAgYWRkcmVzczogY2VsbEFkZHJlc3MsXHJcbiAgICAgICAgICAgIGZvcm11bGEsXHJcbiAgICAgICAgICB9KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZGF0YS5wdXNoKHJvd0RhdGEpO1xyXG4gICAgICB9XHJcbiAgICAgIFxyXG4gICAgICAvLyBBbmFseXplIGRhdGEgdHlwZXMgZm9yIGVhY2ggY29sdW1uIHdpdGggYmV0dGVyIGRldGVjdGlvblxyXG4gICAgICBjb25zdCBkYXRhVHlwZXM6IENvbHVtbkRhdGFUeXBlW10gPSBoZWFkZXJzLm1hcCgoaGVhZGVyLCBjb2xJbmRleCkgPT4ge1xyXG4gICAgICAgIGNvbnN0IGNvbHVtbkRhdGEgPSBkYXRhLnNsaWNlKDEpLm1hcChyb3cgPT4gcm93W2NvbEluZGV4XT8udmFsdWUpLmZpbHRlcih2ID0+IHYgIT09IG51bGwgJiYgdiAhPT0gdW5kZWZpbmVkICYmIHYgIT09ICcnKTtcclxuICAgICAgICBjb25zdCB1bmlxdWVWYWx1ZXMgPSBBcnJheS5mcm9tKG5ldyBTZXQoY29sdW1uRGF0YSkpO1xyXG4gICAgICAgIFxyXG4gICAgICAgIC8vIERldGVybWluZSBkYXRhIHR5cGUgd2l0aCBpbXByb3ZlZCBsb2dpY1xyXG4gICAgICAgIGxldCBkYXRhVHlwZTogQ29sdW1uRGF0YVR5cGVbJ2RhdGFUeXBlJ10gPSAndGV4dCc7XHJcbiAgICAgICAgaWYgKGNvbHVtbkRhdGEubGVuZ3RoID4gMCkge1xyXG4gICAgICAgICAgY29uc3QgbnVtYmVyQ291bnQgPSBjb2x1bW5EYXRhLmZpbHRlcih2ID0+IHR5cGVvZiB2ID09PSAnbnVtYmVyJyB8fCAoIWlzTmFOKE51bWJlcih2KSkgJiYgdiAhPT0gJycpKS5sZW5ndGg7XHJcbiAgICAgICAgICBjb25zdCBkYXRlQ291bnQgPSBjb2x1bW5EYXRhLmZpbHRlcih2ID0+IHtcclxuICAgICAgICAgICAgaWYgKHYgaW5zdGFuY2VvZiBEYXRlKSByZXR1cm4gdHJ1ZTtcclxuICAgICAgICAgICAgaWYgKHR5cGVvZiB2ID09PSAnc3RyaW5nJykge1xyXG4gICAgICAgICAgICAgIGNvbnN0IGRhdGVUZXN0ID0gbmV3IERhdGUodik7XHJcbiAgICAgICAgICAgICAgcmV0dXJuICFpc05hTihkYXRlVGVzdC5nZXRUaW1lKCkpICYmIHYubWF0Y2goL1xcZHsxLDR9Wy1cXC9dXFxkezEsMn1bLVxcL11cXGR7MSw0fS8pO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgICAgICAgIH0pLmxlbmd0aDtcclxuICAgICAgICAgIFxyXG4gICAgICAgICAgaWYgKG51bWJlckNvdW50IC8gY29sdW1uRGF0YS5sZW5ndGggPiAwLjcpIGRhdGFUeXBlID0gJ251bWJlcic7XHJcbiAgICAgICAgICBlbHNlIGlmIChkYXRlQ291bnQgLyBjb2x1bW5EYXRhLmxlbmd0aCA+IDAuNykgZGF0YVR5cGUgPSAnZGF0ZSc7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIFxyXG4gICAgICAgIHJldHVybiB7ICAgICAgICBjb2x1bW5JbmRleDogY29sSW5kZXgsXHJcbiAgICAgICAgY29sdW1uTGV0dGVyOiBYTFNYLnV0aWxzLmVuY29kZV9jb2woY29sSW5kZXgpLFxyXG4gICAgICAgIGhlYWRlcjogaGVhZGVyIHx8IGBDb2x1bW4gJHtjb2xJbmRleCArIDF9YCxcclxuICAgICAgICBkYXRhVHlwZSxcclxuICAgICAgICBzYW1wbGVWYWx1ZXM6IHVuaXF1ZVZhbHVlcy5zbGljZSgwLCA1KSxcclxuICAgICAgICB1bmlxdWVDb3VudDogdW5pcXVlVmFsdWVzLmxlbmd0aCxcclxuICAgICAgICBudWxsQ291bnQ6IGRhdGEuc2xpY2UoMSkubGVuZ3RoIC0gY29sdW1uRGF0YS5sZW5ndGgsXHJcbiAgICAgIH07XHJcbiAgICB9KTtcclxuICAgIFxyXG4gICAgLy8gRXh0cmFjdCBmb3JtdWxhIGNlbGxzIHdpdGggYmV0dGVyIGVycm9yIGhhbmRsaW5nXHJcbiAgICBjb25zdCBmb3JtdWxhQ2VsbHM6IEZvcm11bGFDZWxsW10gPSBbXTtcclxuICAgIGRhdGEuZm9yRWFjaCgocm93LCByb3dJbmRleCkgPT4ge1xyXG4gICAgICByb3cuZm9yRWFjaCgoY2VsbCwgY29sSW5kZXgpID0+IHtcclxuICAgICAgICBpZiAoY2VsbC5mb3JtdWxhKSB7XHJcbiAgICAgICAgICB0cnkge1xyXG4gICAgICAgICAgICBmb3JtdWxhQ2VsbHMucHVzaCh7XHJcbiAgICAgICAgICAgICAgYWRkcmVzczogY2VsbC5hZGRyZXNzLFxyXG4gICAgICAgICAgICAgIGZvcm11bGE6IGNlbGwuZm9ybXVsYSxcclxuICAgICAgICAgICAgICBkZXBlbmRlbmNpZXM6IGV4dHJhY3RGb3JtdWxhRGVwZW5kZW5jaWVzKGNlbGwuZm9ybXVsYSksXHJcbiAgICAgICAgICAgICAgcmVzdWx0OiBjZWxsLnZhbHVlLFxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICAgIH0gY2F0Y2ggKGZvcm11bGFFcnJvcikge1xyXG4gICAgICAgICAgICBjb25zb2xlLndhcm4oYEVycm9yIHByb2Nlc3NpbmcgZm9ybXVsYSBpbiBjZWxsICR7Y2VsbC5hZGRyZXNzfTpgLCBmb3JtdWxhRXJyb3IpO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgfSk7XHJcbiAgICB9KTtcclxuICAgIFxyXG4gICAgY29uc29sZS5sb2coYFNoZWV0ICR7c2hlZXROYW1lfSBwcm9jZXNzZWQ6ICR7Zm9ybXVsYUNlbGxzLmxlbmd0aH0gZm9ybXVsYXMgZm91bmRgKTtcclxuICAgIFxyXG4gICAgcmV0dXJuIHtcclxuICAgICAgaWQ6IGBzaGVldF8ke2luZGV4fWAsXHJcbiAgICAgIG5hbWU6IHNoZWV0TmFtZSxcclxuICAgICAgZGF0YSxcclxuICAgICAgaGVhZGVycyxcclxuICAgICAgcm93Q291bnQsXHJcbiAgICAgIGNvbHVtbkNvdW50LFxyXG4gICAgICBkYXRhVHlwZXMsXHJcbiAgICAgIGhhc0Zvcm11bGFzOiBmb3JtdWxhQ2VsbHMubGVuZ3RoID4gMCxcclxuICAgICAgZm9ybXVsYUNlbGxzLFxyXG4gICAgfTtcclxuICB9KS5maWx0ZXIoc2hlZXQgPT4gc2hlZXQgIT09IG51bGwpOyAvLyBSZW1vdmUgYW55IG51bGwgc2hlZXRzICBcclxuICBjb25zdCBmaW5hbFdvcmtib29rID0ge1xyXG4gICAgaWQ6IGB3b3JrYm9va18ke0RhdGUubm93KCl9YCxcclxuICAgIG5hbWU6IGZpbGVuYW1lLFxyXG4gICAgc2hlZXRzLFxyXG4gICAgdXBsb2FkRGF0ZTogbmV3IERhdGUoKSxcclxuICAgIGZpbGVTaXplOiBidWZmZXIubGVuZ3RoLFxyXG4gICAgbGFzdE1vZGlmaWVkOiBuZXcgRGF0ZSgpLFxyXG4gIH07XHJcbiAgXHJcbiAgY29uc29sZS5sb2coJ0ZpbmFsIHdvcmtib29rIGNyZWF0ZWQ6Jywge1xyXG4gICAgbmFtZTogZmluYWxXb3JrYm9vay5uYW1lLFxyXG4gICAgc2hlZXRzQ291bnQ6IGZpbmFsV29ya2Jvb2suc2hlZXRzLmxlbmd0aCxcclxuICAgIHRvdGFsRm9ybXVsYXM6IGZpbmFsV29ya2Jvb2suc2hlZXRzLnJlZHVjZSgoc3VtLCBzKSA9PiBzdW0gKyBzLmZvcm11bGFDZWxscy5sZW5ndGgsIDApXHJcbiAgfSk7XHJcbiAgXHJcbiAgcmV0dXJuIGZpbmFsV29ya2Jvb2s7XHJcbn0gY2F0Y2ggKGVycm9yKSB7XHJcbiAgY29uc29sZS5lcnJvcignRXJyb3IgcGFyc2luZyBFeGNlbCBmaWxlOicsIGVycm9yKTtcclxuICB0aHJvdyBuZXcgRXJyb3IoYEZhaWxlZCB0byBwYXJzZSBFeGNlbCBmaWxlOiAke2Vycm9yLm1lc3NhZ2V9YCk7XHJcbn1cclxufVxyXG5cclxuZnVuY3Rpb24gZXh0cmFjdEZvcm11bGFEZXBlbmRlbmNpZXMoZm9ybXVsYTogc3RyaW5nKTogc3RyaW5nW10ge1xyXG4gIC8vIFNpbXBsZSByZWdleCB0byBleHRyYWN0IGNlbGwgcmVmZXJlbmNlcyBsaWtlIEExLCBCMiwgJEEkMSwgZXRjLlxyXG4gIGNvbnN0IGNlbGxSZWZSZWdleCA9IC9cXCQ/W0EtWl0rXFwkP1xcZCsvZztcclxuICBjb25zdCBtYXRjaGVzID0gZm9ybXVsYS5tYXRjaChjZWxsUmVmUmVnZXgpIHx8IFtdO1xyXG4gIHJldHVybiBBcnJheS5mcm9tKG5ldyBTZXQobWF0Y2hlcykpO1xyXG59XHJcblxyXG5leHBvcnQgZGVmYXVsdCBhc3luYyBmdW5jdGlvbiBoYW5kbGVyKHJlcTogTmV4dEFwaVJlcXVlc3QsIHJlczogTmV4dEFwaVJlc3BvbnNlKSB7XHJcbiAgaWYgKHJlcS5tZXRob2QgIT09ICdQT1NUJykge1xyXG4gICAgcmV0dXJuIHJlcy5zdGF0dXMoNDA1KS5qc29uKHsgZXJyb3I6ICdNZXRob2Qgbm90IGFsbG93ZWQnIH0pO1xyXG4gIH1cclxuICBcclxuICB0cnkge1xyXG4gICAgY29uc3QgZm9ybSA9IG5ldyBJbmNvbWluZ0Zvcm0oe1xyXG4gICAgICBrZWVwRXh0ZW5zaW9uczogdHJ1ZSxcclxuICAgICAgbWF4RmlsZVNpemU6IDUwICogMTAyNCAqIDEwMjQsIC8vIDUwTUJcclxuICAgICAgbXVsdGlwbGVzOiB0cnVlLFxyXG4gICAgfSk7XHJcbiAgICBcclxuICAgIGNvbnN0IHsgZmlsZXMgfSA9IGF3YWl0IG5ldyBQcm9taXNlPHsgZmlsZXM6IGFueSB9PigocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XHJcbiAgICAgIGZvcm0ucGFyc2UocmVxLCAoZXJyLCBmaWVsZHMsIGZpbGVzKSA9PiB7XHJcbiAgICAgICAgaWYgKGVycikge1xyXG4gICAgICAgICAgY29uc29sZS5lcnJvcignRm9ybSBwYXJzZSBlcnJvcjonLCBlcnIpO1xyXG4gICAgICAgICAgcmVqZWN0KGVycik7XHJcbiAgICAgICAgfSBlbHNlIHtcclxuICAgICAgICAgIHJlc29sdmUoeyBmaWxlcyB9KTtcclxuICAgICAgICB9XHJcbiAgICAgIH0pO1xyXG4gICAgfSk7XHJcbiAgICBcclxuICAgIGNvbnNvbGUubG9nKCdSZWNlaXZlZCBmaWxlczonLCBPYmplY3Qua2V5cyhmaWxlcykpO1xyXG4gICAgXHJcbiAgICAvLyBIYW5kbGUgYm90aCBzaW5nbGUgZmlsZSBhbmQgYXJyYXkgb2YgZmlsZXNcclxuICAgIGxldCBleGNlbEZpbGUgPSBmaWxlcy5leGNlbDtcclxuICAgIGlmIChBcnJheS5pc0FycmF5KGV4Y2VsRmlsZSkpIHtcclxuICAgICAgZXhjZWxGaWxlID0gZXhjZWxGaWxlWzBdO1xyXG4gICAgfVxyXG4gICAgXHJcbiAgICBpZiAoIWV4Y2VsRmlsZSkge1xyXG4gICAgICBjb25zb2xlLmxvZygnTm8gZXhjZWwgZmlsZSBmb3VuZCBpbjonLCBmaWxlcyk7XHJcbiAgICAgIHJldHVybiByZXMuc3RhdHVzKDQwMCkuanNvbih7IGVycm9yOiAnTm8gRXhjZWwgZmlsZSB1cGxvYWRlZCcgfSk7XHJcbiAgICB9XHJcbiAgICBcclxuICAgIGNvbnNvbGUubG9nKCdQcm9jZXNzaW5nIGZpbGU6JywgZXhjZWxGaWxlLm9yaWdpbmFsRmlsZW5hbWUsICdTaXplOicsIGV4Y2VsRmlsZS5zaXplKTtcclxuICAgIFxyXG4gICAgLy8gUmVhZCB0aGUgZmlsZSBidWZmZXJcclxuICAgIGNvbnN0IGJ1ZmZlciA9IGZzLnJlYWRGaWxlU3luYyhleGNlbEZpbGUuZmlsZXBhdGgpO1xyXG4gICAgXHJcbiAgICAvLyBQYXJzZSB0aGUgRXhjZWwgZmlsZVxyXG4gICAgY29uc3Qgd29ya2Jvb2sgPSBwYXJzZUV4Y2VsRmlsZShidWZmZXIsIGV4Y2VsRmlsZS5vcmlnaW5hbEZpbGVuYW1lIHx8ICd1bmtub3duLnhsc3gnKTtcclxuICAgIFxyXG4gICAgcmVzLnN0YXR1cygyMDApLmpzb24od29ya2Jvb2spO1xyXG4gIH0gY2F0Y2ggKGVycm9yKSB7XHJcbiAgICBjb25zb2xlLmVycm9yKCdFcnJvciBwYXJzaW5nIEV4Y2VsIGZpbGU6JywgZXJyb3IpO1xyXG4gICAgcmVzLnN0YXR1cyg1MDApLmpzb24oeyBlcnJvcjogJ0ZhaWxlZCB0byBwYXJzZSBFeGNlbCBmaWxlJywgZGV0YWlsczogZXJyb3IubWVzc2FnZSB9KTtcclxuICB9XHJcbn1cclxuIl0sIm5hbWVzIjpbIlhMU1giLCJJbmNvbWluZ0Zvcm0iLCJmcyIsImNvbmZpZyIsImFwaSIsImJvZHlQYXJzZXIiLCJwYXJzZUV4Y2VsRmlsZSIsImJ1ZmZlciIsImZpbGVuYW1lIiwiY29uc29sZSIsImxvZyIsImxlbmd0aCIsIndvcmtib29rIiwicmVhZCIsInR5cGUiLCJjZWxsRm9ybXVsYSIsImNlbGxTdHlsZXMiLCJjZWxsRGF0ZXMiLCJjZWxsTkYiLCJTaGVldE5hbWVzIiwic2hlZXRzIiwibWFwIiwic2hlZXROYW1lIiwiaW5kZXgiLCJ3b3Jrc2hlZXQiLCJTaGVldHMiLCJ3YXJuIiwianNvbkRhdGEiLCJ1dGlscyIsInNoZWV0X3RvX2pzb24iLCJoZWFkZXIiLCJyYXciLCJkZWZ2YWwiLCJibGFua3Jvd3MiLCJyYW5nZSIsImRlY29kZV9yYW5nZSIsInMiLCJyIiwiYyIsImUiLCJyb3dDb3VudCIsIk1hdGgiLCJtYXgiLCJjb2x1bW5Db3VudCIsInJvdyIsImhlYWRlcnMiLCJkYXRhIiwicm93RGF0YSIsImNvbCIsImNlbGxBZGRyZXNzIiwiZW5jb2RlX2NlbGwiLCJjZWxsIiwiY2VsbFZhbHVlIiwiY2VsbFR5cGUiLCJmb3JtdWxhIiwiZiIsInYiLCJ1bmRlZmluZWQiLCJ3IiwiRGF0ZSIsInQiLCJjZWxsRXJyb3IiLCJwdXNoIiwidmFsdWUiLCJhZGRyZXNzIiwiZGF0YVR5cGVzIiwiY29sSW5kZXgiLCJjb2x1bW5EYXRhIiwic2xpY2UiLCJmaWx0ZXIiLCJ1bmlxdWVWYWx1ZXMiLCJBcnJheSIsImZyb20iLCJTZXQiLCJkYXRhVHlwZSIsIm51bWJlckNvdW50IiwiaXNOYU4iLCJOdW1iZXIiLCJkYXRlQ291bnQiLCJkYXRlVGVzdCIsImdldFRpbWUiLCJtYXRjaCIsImNvbHVtbkluZGV4IiwiY29sdW1uTGV0dGVyIiwiZW5jb2RlX2NvbCIsInNhbXBsZVZhbHVlcyIsInVuaXF1ZUNvdW50IiwibnVsbENvdW50IiwiZm9ybXVsYUNlbGxzIiwiZm9yRWFjaCIsInJvd0luZGV4IiwiZGVwZW5kZW5jaWVzIiwiZXh0cmFjdEZvcm11bGFEZXBlbmRlbmNpZXMiLCJyZXN1bHQiLCJmb3JtdWxhRXJyb3IiLCJpZCIsIm5hbWUiLCJoYXNGb3JtdWxhcyIsInNoZWV0IiwiZmluYWxXb3JrYm9vayIsIm5vdyIsInVwbG9hZERhdGUiLCJmaWxlU2l6ZSIsImxhc3RNb2RpZmllZCIsInNoZWV0c0NvdW50IiwidG90YWxGb3JtdWxhcyIsInJlZHVjZSIsInN1bSIsImVycm9yIiwiRXJyb3IiLCJtZXNzYWdlIiwiY2VsbFJlZlJlZ2V4IiwibWF0Y2hlcyIsImhhbmRsZXIiLCJyZXEiLCJyZXMiLCJtZXRob2QiLCJzdGF0dXMiLCJqc29uIiwiZm9ybSIsImtlZXBFeHRlbnNpb25zIiwibWF4RmlsZVNpemUiLCJtdWx0aXBsZXMiLCJmaWxlcyIsIlByb21pc2UiLCJyZXNvbHZlIiwicmVqZWN0IiwicGFyc2UiLCJlcnIiLCJmaWVsZHMiLCJPYmplY3QiLCJrZXlzIiwiZXhjZWxGaWxlIiwiZXhjZWwiLCJpc0FycmF5Iiwib3JpZ2luYWxGaWxlbmFtZSIsInNpemUiLCJyZWFkRmlsZVN5bmMiLCJmaWxlcGF0aCIsImRldGFpbHMiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(api)/./pages/api/excel/parse.ts\n");

/***/ })

};
;

// load runtime
var __webpack_require__ = require("../../../webpack-api-runtime.js");
__webpack_require__.C(exports);
var __webpack_exec__ = (moduleId) => (__webpack_require__(__webpack_require__.s = moduleId))
var __webpack_exports__ = __webpack_require__.X(0, ["vendor-chunks/next"], () => (__webpack_exec__("(api)/./node_modules/next/dist/build/webpack/loaders/next-route-loader/index.js?kind=PAGES_API&page=%2Fapi%2Fexcel%2Fparse&preferredRegion=&absolutePagePath=.%2Fpages%5Capi%5Cexcel%5Cparse.ts&middlewareConfigBase64=e30%3D!")));
module.exports = __webpack_exports__;

})();