"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(() => {
var exports = {};
exports.id = "pages/api/excel/analyze";
exports.ids = ["pages/api/excel/analyze"];
exports.modules = {

/***/ "next/dist/compiled/next-server/pages-api.runtime.dev.js":
/*!**************************************************************************!*\
  !*** external "next/dist/compiled/next-server/pages-api.runtime.dev.js" ***!
  \**************************************************************************/
/***/ ((module) => {

module.exports = require("next/dist/compiled/next-server/pages-api.runtime.dev.js");

/***/ }),

/***/ "xlsx":
/*!***********************!*\
  !*** external "xlsx" ***!
  \***********************/
/***/ ((module) => {

module.exports = require("xlsx");

/***/ }),

/***/ "(api)/./node_modules/next/dist/build/webpack/loaders/next-route-loader/index.js?kind=PAGES_API&page=%2Fapi%2Fexcel%2Fanalyze&preferredRegion=&absolutePagePath=.%2Fpages%5Capi%5Cexcel%5Canalyze.ts&middlewareConfigBase64=e30%3D!":
/*!************************************************************************************************************************************************************************************************************************************!*\
  !*** ./node_modules/next/dist/build/webpack/loaders/next-route-loader/index.js?kind=PAGES_API&page=%2Fapi%2Fexcel%2Fanalyze&preferredRegion=&absolutePagePath=.%2Fpages%5Capi%5Cexcel%5Canalyze.ts&middlewareConfigBase64=e30%3D! ***!
  \************************************************************************************************************************************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   config: () => (/* binding */ config),\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__),\n/* harmony export */   routeModule: () => (/* binding */ routeModule)\n/* harmony export */ });\n/* harmony import */ var next_dist_server_future_route_modules_pages_api_module_compiled__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! next/dist/server/future/route-modules/pages-api/module.compiled */ \"(api)/./node_modules/next/dist/server/future/route-modules/pages-api/module.compiled.js\");\n/* harmony import */ var next_dist_server_future_route_modules_pages_api_module_compiled__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(next_dist_server_future_route_modules_pages_api_module_compiled__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var next_dist_server_future_route_kind__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! next/dist/server/future/route-kind */ \"(api)/./node_modules/next/dist/server/future/route-kind.js\");\n/* harmony import */ var next_dist_build_templates_helpers__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! next/dist/build/templates/helpers */ \"(api)/./node_modules/next/dist/build/templates/helpers.js\");\n/* harmony import */ var _pages_api_excel_analyze_ts__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./pages\\api\\excel\\analyze.ts */ \"(api)/./pages/api/excel/analyze.ts\");\n\n\n\n// Import the userland code.\n\n// Re-export the handler (should be the default export).\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ((0,next_dist_build_templates_helpers__WEBPACK_IMPORTED_MODULE_2__.hoist)(_pages_api_excel_analyze_ts__WEBPACK_IMPORTED_MODULE_3__, \"default\"));\n// Re-export config.\nconst config = (0,next_dist_build_templates_helpers__WEBPACK_IMPORTED_MODULE_2__.hoist)(_pages_api_excel_analyze_ts__WEBPACK_IMPORTED_MODULE_3__, \"config\");\n// Create and export the route module that will be consumed.\nconst routeModule = new next_dist_server_future_route_modules_pages_api_module_compiled__WEBPACK_IMPORTED_MODULE_0__.PagesAPIRouteModule({\n    definition: {\n        kind: next_dist_server_future_route_kind__WEBPACK_IMPORTED_MODULE_1__.RouteKind.PAGES_API,\n        page: \"/api/excel/analyze\",\n        pathname: \"/api/excel/analyze\",\n        // The following aren't used in production.\n        bundlePath: \"\",\n        filename: \"\"\n    },\n    userland: _pages_api_excel_analyze_ts__WEBPACK_IMPORTED_MODULE_3__\n});\n\n//# sourceMappingURL=pages-api.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwaSkvLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2J1aWxkL3dlYnBhY2svbG9hZGVycy9uZXh0LXJvdXRlLWxvYWRlci9pbmRleC5qcz9raW5kPVBBR0VTX0FQSSZwYWdlPSUyRmFwaSUyRmV4Y2VsJTJGYW5hbHl6ZSZwcmVmZXJyZWRSZWdpb249JmFic29sdXRlUGFnZVBhdGg9LiUyRnBhZ2VzJTVDYXBpJTVDZXhjZWwlNUNhbmFseXplLnRzJm1pZGRsZXdhcmVDb25maWdCYXNlNjQ9ZTMwJTNEISIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7OztBQUFzRztBQUN2QztBQUNMO0FBQzFEO0FBQzREO0FBQzVEO0FBQ0EsaUVBQWUsd0VBQUssQ0FBQyx3REFBUSxZQUFZLEVBQUM7QUFDMUM7QUFDTyxlQUFlLHdFQUFLLENBQUMsd0RBQVE7QUFDcEM7QUFDTyx3QkFBd0IsZ0hBQW1CO0FBQ2xEO0FBQ0EsY0FBYyx5RUFBUztBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLFlBQVk7QUFDWixDQUFDOztBQUVEIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vcmUtZ2VudC1mcm9udGVuZC8/NmZiMiJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBQYWdlc0FQSVJvdXRlTW9kdWxlIH0gZnJvbSBcIm5leHQvZGlzdC9zZXJ2ZXIvZnV0dXJlL3JvdXRlLW1vZHVsZXMvcGFnZXMtYXBpL21vZHVsZS5jb21waWxlZFwiO1xuaW1wb3J0IHsgUm91dGVLaW5kIH0gZnJvbSBcIm5leHQvZGlzdC9zZXJ2ZXIvZnV0dXJlL3JvdXRlLWtpbmRcIjtcbmltcG9ydCB7IGhvaXN0IH0gZnJvbSBcIm5leHQvZGlzdC9idWlsZC90ZW1wbGF0ZXMvaGVscGVyc1wiO1xuLy8gSW1wb3J0IHRoZSB1c2VybGFuZCBjb2RlLlxuaW1wb3J0ICogYXMgdXNlcmxhbmQgZnJvbSBcIi4vcGFnZXNcXFxcYXBpXFxcXGV4Y2VsXFxcXGFuYWx5emUudHNcIjtcbi8vIFJlLWV4cG9ydCB0aGUgaGFuZGxlciAoc2hvdWxkIGJlIHRoZSBkZWZhdWx0IGV4cG9ydCkuXG5leHBvcnQgZGVmYXVsdCBob2lzdCh1c2VybGFuZCwgXCJkZWZhdWx0XCIpO1xuLy8gUmUtZXhwb3J0IGNvbmZpZy5cbmV4cG9ydCBjb25zdCBjb25maWcgPSBob2lzdCh1c2VybGFuZCwgXCJjb25maWdcIik7XG4vLyBDcmVhdGUgYW5kIGV4cG9ydCB0aGUgcm91dGUgbW9kdWxlIHRoYXQgd2lsbCBiZSBjb25zdW1lZC5cbmV4cG9ydCBjb25zdCByb3V0ZU1vZHVsZSA9IG5ldyBQYWdlc0FQSVJvdXRlTW9kdWxlKHtcbiAgICBkZWZpbml0aW9uOiB7XG4gICAgICAgIGtpbmQ6IFJvdXRlS2luZC5QQUdFU19BUEksXG4gICAgICAgIHBhZ2U6IFwiL2FwaS9leGNlbC9hbmFseXplXCIsXG4gICAgICAgIHBhdGhuYW1lOiBcIi9hcGkvZXhjZWwvYW5hbHl6ZVwiLFxuICAgICAgICAvLyBUaGUgZm9sbG93aW5nIGFyZW4ndCB1c2VkIGluIHByb2R1Y3Rpb24uXG4gICAgICAgIGJ1bmRsZVBhdGg6IFwiXCIsXG4gICAgICAgIGZpbGVuYW1lOiBcIlwiXG4gICAgfSxcbiAgICB1c2VybGFuZFxufSk7XG5cbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXBhZ2VzLWFwaS5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(api)/./node_modules/next/dist/build/webpack/loaders/next-route-loader/index.js?kind=PAGES_API&page=%2Fapi%2Fexcel%2Fanalyze&preferredRegion=&absolutePagePath=.%2Fpages%5Capi%5Cexcel%5Canalyze.ts&middlewareConfigBase64=e30%3D!\n");

/***/ }),

/***/ "(api)/./pages/api/excel/analyze.ts":
/*!************************************!*\
  !*** ./pages/api/excel/analyze.ts ***!
  \************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ handler)\n/* harmony export */ });\n/* harmony import */ var xlsx__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! xlsx */ \"xlsx\");\n/* harmony import */ var xlsx__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(xlsx__WEBPACK_IMPORTED_MODULE_0__);\n\n// Enhanced analysis with more realistic data generation\nasync function handler(req, res) {\n    if (req.method !== \"POST\") {\n        return res.status(405).json({\n            error: \"Method not allowed\"\n        });\n    }\n    try {\n        const { workbookId, workbook } = req.body;\n        if (!workbookId) {\n            return res.status(400).json({\n                error: \"Workbook ID is required\"\n            });\n        }\n        // Simulate analysis processing time\n        await new Promise((resolve)=>setTimeout(resolve, 1500));\n        // Generate dynamic analysis based on workbook if provided\n        const analysis = generateDynamicAnalysis(workbook);\n        res.status(200).json(analysis);\n    } catch (error) {\n        console.error(\"Error analyzing workbook:\", error);\n        res.status(500).json({\n            error: \"Failed to analyze workbook\"\n        });\n    }\n}\nfunction generateDynamicAnalysis(workbook) {\n    console.log(\"Generating dynamic analysis for workbook:\", workbook?.name);\n    // Default values for when no workbook is provided\n    let totalSheets = 3;\n    let totalRows = 1250;\n    let totalColumns = 12;\n    let totalFormulas = 45;\n    let complexityScore = 72;\n    let automationPotential = \"high\";\n    let dataTypesDistribution = {\n        \"text\": 6,\n        \"number\": 4,\n        \"date\": 2\n    };\n    // If workbook data is provided, analyze it for real insights\n    if (workbook && workbook.sheets && Array.isArray(workbook.sheets)) {\n        console.log(\"Analyzing real workbook data...\");\n        totalSheets = workbook.sheets.length;\n        totalRows = workbook.sheets.reduce((sum, sheet)=>sum + (sheet.rowCount || 0), 0);\n        totalColumns = Math.max(...workbook.sheets.map((sheet)=>sheet.columnCount || 0), 1);\n        totalFormulas = workbook.sheets.reduce((sum, sheet)=>sum + (sheet.formulaCells?.length || 0), 0);\n        // Analyze data types across all sheets\n        const allDataTypes = {\n            text: 0,\n            number: 0,\n            date: 0\n        };\n        workbook.sheets.forEach((sheet)=>{\n            if (sheet.dataTypes && Array.isArray(sheet.dataTypes)) {\n                sheet.dataTypes.forEach((col)=>{\n                    if (col.dataType === \"text\") {\n                        allDataTypes.text += 1;\n                    } else if (col.dataType === \"number\") {\n                        allDataTypes.number += 1;\n                    } else if (col.dataType === \"date\") {\n                        allDataTypes.date += 1;\n                    }\n                });\n            }\n        });\n        dataTypesDistribution = allDataTypes;\n        // Calculate complexity score based on actual data\n        const formulaDensity = totalRows > 0 ? totalFormulas / totalRows * 100 : 0;\n        const sheetComplexity = totalSheets * 10;\n        const dataVolumeComplexity = Math.min(30, Math.log10(totalRows + 1) * 10);\n        complexityScore = Math.min(100, Math.round(formulaDensity + sheetComplexity + dataVolumeComplexity));\n        // Determine automation potential based on real metrics\n        const hasComplexFormulas = workbook.sheets.some((sheet)=>sheet.formulaCells?.some((formula)=>formula.formula?.includes(\"VLOOKUP\") || formula.formula?.includes(\"INDEX\") || formula.formula?.includes(\"MATCH\") || formula.formula?.includes(\"SUMIFS\") || formula.formula?.includes(\"COUNTIFS\")));\n        const hasMultipleSheets = totalSheets > 1;\n        const hasLargeDataset = totalRows > 100;\n        if (hasComplexFormulas && hasMultipleSheets || totalFormulas > 20) {\n            automationPotential = \"high\";\n        } else if (hasComplexFormulas || hasMultipleSheets || totalFormulas > 5) {\n            automationPotential = \"medium\";\n        } else {\n            automationPotential = \"low\";\n        }\n        console.log(\"Analysis metrics:\", {\n            totalSheets,\n            totalRows,\n            totalColumns,\n            totalFormulas,\n            complexityScore,\n            automationPotential,\n            dataTypesDistribution\n        });\n    }\n    return {\n        summary: {\n            totalSheets,\n            totalRows,\n            totalColumns,\n            totalFormulas,\n            dataTypes: dataTypesDistribution,\n            complexityScore,\n            automationPotential\n        },\n        recommendations: generateRecommendations(totalFormulas, totalSheets, automationPotential, workbook),\n        suggestedFormulas: generateSuggestedFormulas(workbook),\n        suggestedPowerQueries: generatePowerQueryTemplates(workbook),\n        dataQualityIssues: generateDataQualityIssues(workbook)\n    };\n}\nfunction generateRecommendations(formulas, sheets, automation, workbook) {\n    const recommendations = [];\n    // Analyze actual workbook data if available\n    const hasComplexFormulas = workbook?.sheets?.some((sheet)=>sheet.formulaCells?.some((formula)=>formula.formula?.includes(\"VLOOKUP\") || formula.formula?.includes(\"INDEX\") || formula.formula?.includes(\"SUMIFS\")));\n    const hasMultipleDataSources = sheets > 1;\n    const hasLargeDataset = workbook?.sheets?.some((sheet)=>sheet.rowCount > 100);\n    if (formulas > 10 || hasComplexFormulas) {\n        recommendations.push({\n            id: \"rec_1\",\n            type: \"powerquery\",\n            priority: \"high\",\n            title: \"Automate Data Processing with PowerQuery\",\n            description: `${hasComplexFormulas ? \"Complex lookup formulas\" : `${formulas} formulas`} detected. PowerQuery can automate these transformations`,\n            implementation: \"Use Data → Get Data → From Other Sources → Blank Query to create automated data pipelines\",\n            impact: `Reduce manual formula maintenance by ${hasComplexFormulas ? \"80%\" : \"70%\"}`,\n            effort: hasComplexFormulas ? \"high\" : \"medium\"\n        });\n    }\n    if (hasMultipleDataSources) {\n        recommendations.push({\n            id: \"rec_2\",\n            type: \"formula\",\n            priority: \"medium\",\n            title: \"Consolidate Sheet References\",\n            description: `Multiple sheets detected (${sheets}). Use dynamic references to improve maintainability`,\n            implementation: \"Replace hard-coded sheet references with INDIRECT or structured references\",\n            impact: \"Improve workbook flexibility and reduce errors\",\n            effort: \"low\"\n        });\n    }\n    recommendations.push({\n        id: \"rec_3\",\n        type: \"data_validation\",\n        priority: automation === \"high\" ? \"high\" : \"medium\",\n        title: \"Implement Data Validation\",\n        description: \"Add validation rules to prevent data entry errors and improve data quality\",\n        implementation: \"Use Data → Data Validation for critical input fields\",\n        impact: \"Reduce data quality issues by 90%\",\n        effort: \"low\"\n    });\n    return recommendations;\n}\nfunction generateSuggestedFormulas(workbook) {\n    const formulas = [];\n    // Default formulas\n    const defaultFormulas = [\n        {\n            formula: '=XLOOKUP(A2,Products[Product_ID],Products[Price],\"\")',\n            description: \"Dynamic price lookup with error handling\",\n            cellAddress: \"D2\",\n            category: \"lookup\",\n            complexity: \"intermediate\",\n            dependencies: [\n                \"A2\",\n                \"Products[Product_ID]\",\n                \"Products[Price]\"\n            ],\n            explanation: \"This formula looks up prices dynamically and returns an empty string if not found.\"\n        },\n        {\n            formula: '=SUMIFS(Sales[Amount],Sales[Date],\">=\"&TODAY()-30)',\n            description: \"Sum sales from last 30 days\",\n            cellAddress: \"G2\",\n            category: \"math\",\n            complexity: \"intermediate\",\n            dependencies: [\n                \"Sales[Amount]\",\n                \"Sales[Date]\"\n            ],\n            explanation: \"Calculates total sales for the last 30 days using dynamic date criteria.\"\n        }\n    ];\n    // Add workbook-specific formulas if data is available\n    if (workbook && workbook.sheets) {\n        workbook.sheets.forEach((sheet, sheetIndex)=>{\n            if (sheet.headers && sheet.dataTypes) {\n                // Generate formulas based on detected data types\n                const numberColumns = sheet.dataTypes.filter((col)=>col.dataType === \"number\");\n                const dateColumns = sheet.dataTypes.filter((col)=>col.dataType === \"date\");\n                const textColumns = sheet.dataTypes.filter((col)=>col.dataType === \"text\");\n                // If we have number columns, suggest SUM formulas\n                if (numberColumns.length > 0) {\n                    const firstNumberCol = numberColumns[0];\n                    const colLetter = firstNumberCol.columnLetter || xlsx__WEBPACK_IMPORTED_MODULE_0__.utils.encode_col(firstNumberCol.columnIndex || 0);\n                    formulas.push({\n                        formula: `=SUM(${colLetter}2:${colLetter}1000)`,\n                        description: `Sum all values in ${firstNumberCol.header} column`,\n                        cellAddress: `${colLetter}${sheet.rowCount + 2}`,\n                        category: \"math\",\n                        complexity: \"basic\",\n                        dependencies: [\n                            `${colLetter}2:${colLetter}1000`\n                        ],\n                        explanation: `Calculates the total of all numeric values in the ${firstNumberCol.header} column.`\n                    });\n                    formulas.push({\n                        formula: `=AVERAGE(${colLetter}2:${colLetter}1000)`,\n                        description: `Average of ${firstNumberCol.header} column`,\n                        cellAddress: `${colLetter}${sheet.rowCount + 3}`,\n                        category: \"math\",\n                        complexity: \"basic\",\n                        dependencies: [\n                            `${colLetter}2:${colLetter}1000`\n                        ],\n                        explanation: `Calculates the average of all numeric values in the ${firstNumberCol.header} column.`\n                    });\n                }\n                // If we have date columns, suggest date-related formulas\n                if (dateColumns.length > 0) {\n                    const firstDateCol = dateColumns[0];\n                    const colLetter = firstDateCol.columnLetter || xlsx__WEBPACK_IMPORTED_MODULE_0__.utils.encode_col(firstDateCol.columnIndex || 0);\n                    const nextColLetter = xlsx__WEBPACK_IMPORTED_MODULE_0__.utils.encode_col((firstDateCol.columnIndex || 0) + 1);\n                    formulas.push({\n                        formula: `=COUNTIFS(${colLetter}:${colLetter},\">=\"&TODAY()-30)`,\n                        description: `Count recent entries in ${firstDateCol.header}`,\n                        cellAddress: `${nextColLetter}${sheet.rowCount + 2}`,\n                        category: \"date\",\n                        complexity: \"intermediate\",\n                        dependencies: [\n                            `${colLetter}:${colLetter}`\n                        ],\n                        explanation: `Counts how many entries in ${firstDateCol.header} are from the last 30 days.`\n                    });\n                }\n                // If we have multiple columns, suggest lookup formulas\n                if (sheet.headers.length > 2) {\n                    const firstCol = sheet.dataTypes[0];\n                    const secondCol = sheet.dataTypes[1];\n                    if (firstCol && secondCol) {\n                        const firstColLetter = firstCol.columnLetter || xlsx__WEBPACK_IMPORTED_MODULE_0__.utils.encode_col(firstCol.columnIndex || 0);\n                        const secondColLetter = secondCol.columnLetter || xlsx__WEBPACK_IMPORTED_MODULE_0__.utils.encode_col(secondCol.columnIndex || 1);\n                        const resultColLetter = xlsx__WEBPACK_IMPORTED_MODULE_0__.utils.encode_col((secondCol.columnIndex || 1) + 2);\n                        formulas.push({\n                            formula: `=XLOOKUP(A2,${firstColLetter}:${firstColLetter},${secondColLetter}:${secondColLetter},\"Not Found\")`,\n                            description: `Lookup ${secondCol.header} based on ${firstCol.header}`,\n                            cellAddress: `${resultColLetter}2`,\n                            category: \"lookup\",\n                            complexity: \"intermediate\",\n                            dependencies: [\n                                `A2`,\n                                `${firstColLetter}:${firstColLetter}`,\n                                `${secondColLetter}:${secondColLetter}`\n                            ],\n                            explanation: `Finds the corresponding ${secondCol.header} value for each ${firstCol.header} entry.`\n                        });\n                    }\n                }\n            }\n        });\n    }\n    // Add default formulas with workbook-specific ones\n    if (workbook && workbook.sheets) {\n        const hasDateColumns = workbook.sheets.some((sheet)=>sheet.dataTypes?.some((dt)=>dt.dataType === \"date\"));\n        if (hasDateColumns) {\n            formulas.push({\n                formula: \"=FILTER(Data[Product],(Data[Date]>=EOMONTH(TODAY(),-1)+1)*(Data[Date]<=EOMONTH(TODAY(),0)))\",\n                description: \"Filter current month data\",\n                cellAddress: \"A10\",\n                category: \"lookup\",\n                complexity: \"advanced\",\n                dependencies: [\n                    \"Data[Product]\",\n                    \"Data[Date]\"\n                ],\n                explanation: \"Returns all records from the current month using dynamic array formulas.\"\n            });\n        }\n    }\n    // Combine default and generated formulas, limiting to reasonable amount\n    return [\n        ...defaultFormulas,\n        ...formulas\n    ].slice(0, 8);\n}\nfunction generatePowerQueryTemplates(workbook) {\n    const templates = [\n        {\n            id: \"pq_1\",\n            name: \"Data Standardization\",\n            description: \"Clean and standardize data formats across all columns\",\n            category: \"data_cleaning\",\n            steps: [\n                {\n                    id: \"step_1\",\n                    name: \"Promote Headers\",\n                    operation: \"headers\",\n                    mCode: \"Table.PromoteHeaders(Source, [PromoteAllScalars=true])\",\n                    description: \"Promote first row to column headers\",\n                    isApplied: true\n                },\n                {\n                    id: \"step_2\",\n                    name: \"Trim Text\",\n                    operation: \"replace\",\n                    mCode: 'Table.TransformColumns(#\"Promoted Headers\", {}, Text.Trim)',\n                    description: \"Remove leading and trailing spaces\",\n                    isApplied: true\n                },\n                {\n                    id: \"step_3\",\n                    name: \"Detect Data Types\",\n                    operation: \"dataTypes\",\n                    mCode: 'Table.DetectDataTypes(#\"Trimmed Text\")',\n                    description: \"Automatically detect and apply proper data types\",\n                    isApplied: true\n                }\n            ],\n            requiredColumns: [],\n            outputColumns: [],\n            mCode: `let\r\n    Source = Excel.CurrentWorkbook(){[Name=\"Table1\"]}[Content],\r\n    #\"Promoted Headers\" = Table.PromoteHeaders(Source, [PromoteAllScalars=true]),\r\n    #\"Trimmed Text\" = Table.TransformColumns(#\"Promoted Headers\", {}, Text.Trim),\r\n    #\"Detected Types\" = Table.DetectDataTypes(#\"Trimmed Text\")\r\nin\r\n    #\"Detected Types\"`\n        }\n    ];\n    // Add workbook-specific templates\n    if (workbook && workbook.sheets) {\n        const hasNumericData = workbook.sheets.some((sheet)=>sheet.dataTypes?.some((dt)=>dt.dataType === \"number\"));\n        if (hasNumericData) {\n            templates.push({\n                id: \"pq_2\",\n                name: \"Numerical Analysis\",\n                description: \"Group and analyze numerical data with calculations\",\n                category: \"analysis\",\n                steps: [\n                    {\n                        id: \"step_1\",\n                        name: \"Group By Category\",\n                        operation: \"group\",\n                        mCode: 'Table.Group(Source, {\"Category\"}, {{\"Total\", each List.Sum([Amount]), type number}, {\"Count\", each Table.RowCount(_), type number}})',\n                        description: \"Group data and calculate totals\",\n                        isApplied: true\n                    },\n                    {\n                        id: \"step_2\",\n                        name: \"Add Percentage\",\n                        operation: \"add_column\",\n                        mCode: 'Table.AddColumn(#\"Grouped Rows\", \"Percentage\", each [Total] / List.Sum(#\"Grouped Rows\"[Total]) * 100)',\n                        description: \"Calculate percentage of total\",\n                        isApplied: true\n                    }\n                ],\n                requiredColumns: [\n                    \"Category\",\n                    \"Amount\"\n                ],\n                outputColumns: [\n                    \"Category\",\n                    \"Total\",\n                    \"Count\",\n                    \"Percentage\"\n                ],\n                mCode: `let\r\n    Source = Excel.CurrentWorkbook(){[Name=\"Data\"]}[Content],\r\n    #\"Grouped Rows\" = Table.Group(Source, {\"Category\"}, {{\"Total\", each List.Sum([Amount]), type number}, {\"Count\", each Table.RowCount(_), type number}}),\r\n    #\"Added Percentage\" = Table.AddColumn(#\"Grouped Rows\", \"Percentage\", each [Total] / List.Sum(#\"Grouped Rows\"[Total]) * 100)\r\nin\r\n    #\"Added Percentage\"`\n            });\n        }\n    }\n    return templates;\n}\nfunction generateDataQualityIssues(workbook) {\n    const issues = [];\n    if (workbook && workbook.sheets) {\n        workbook.sheets.forEach((sheet, sheetIndex)=>{\n            if (sheet.dataTypes) {\n                sheet.dataTypes.forEach((col)=>{\n                    const nullPercentage = col.nullCount / Math.max(sheet.rowCount - 1, 1) * 100;\n                    const colLetter = col.columnLetter || xlsx__WEBPACK_IMPORTED_MODULE_0__.utils.encode_col(col.columnIndex || 0);\n                    if (nullPercentage > 20) {\n                        issues.push({\n                            id: `dq_null_${sheetIndex}_${col.columnIndex}`,\n                            type: \"missing_data\",\n                            severity: nullPercentage > 50 ? \"high\" : \"medium\",\n                            sheet: sheet.name,\n                            column: col.header,\n                            description: `${nullPercentage.toFixed(1)}% missing values in ${col.header}`,\n                            affectedCells: [\n                                `${colLetter}2:${colLetter}${sheet.rowCount}`\n                            ],\n                            suggestedFix: \"Add data validation or implement default values for required fields\"\n                        });\n                    }\n                });\n                // Check for inconsistent data types\n                const textColumns = sheet.dataTypes.filter((col)=>col.dataType === \"text\");\n                textColumns.forEach((col)=>{\n                    const colLetter = col.columnLetter || xlsx__WEBPACK_IMPORTED_MODULE_0__.utils.encode_col(col.columnIndex || 0);\n                    if (col.uniqueCount === 1 && col.sampleValues.length > 0) {\n                        issues.push({\n                            id: `dq_uniform_${sheetIndex}_${col.columnIndex}`,\n                            type: \"inconsistent_format\",\n                            severity: \"low\",\n                            sheet: sheet.name,\n                            column: col.header,\n                            description: `${col.header} contains only one unique value: \"${col.sampleValues[0]}\"`,\n                            affectedCells: [\n                                `${colLetter}2:${colLetter}${sheet.rowCount}`\n                            ],\n                            suggestedFix: \"Verify if this column provides meaningful data variation\"\n                        });\n                    }\n                });\n            }\n            // Check for complex formulas that might be error-prone\n            if (sheet.formulaCells && sheet.formulaCells.length > 5) {\n                const complexFormulas = sheet.formulaCells.filter((formula)=>formula.formula && (formula.formula.includes(\"VLOOKUP\") || formula.formula.includes(\"INDEX\") && formula.formula.includes(\"MATCH\")));\n                if (complexFormulas.length > 3) {\n                    issues.push({\n                        id: `dq_complex_${sheetIndex}`,\n                        type: \"invalid_data\",\n                        severity: \"medium\",\n                        sheet: sheet.name,\n                        column: \"Various\",\n                        description: `${complexFormulas.length} complex lookup formulas detected`,\n                        affectedCells: complexFormulas.map((f)=>f.address),\n                        suggestedFix: \"Consider replacing with XLOOKUP or PowerQuery for better maintainability\"\n                    });\n                }\n            }\n        });\n    }\n    // Add some default issues if no real issues found (for demo purposes)\n    if (issues.length === 0) {\n        issues.push({\n            id: \"dq_demo_1\",\n            type: \"missing_data\",\n            severity: \"medium\",\n            sheet: \"Data\",\n            column: \"Important Field\",\n            description: \"Some required fields contain empty values\",\n            affectedCells: [\n                \"B15\",\n                \"B23\",\n                \"B41\"\n            ],\n            suggestedFix: \"Use data validation to require field entry or implement default values\"\n        });\n        issues.push({\n            id: \"dq_demo_2\",\n            type: \"inconsistent_format\",\n            severity: \"low\",\n            sheet: \"Data\",\n            column: \"Date Field\",\n            description: \"Inconsistent date formatting detected\",\n            affectedCells: [\n                \"A5\",\n                \"A12\",\n                \"A18\"\n            ],\n            suggestedFix: \"Standardize date format using Format Cells dialog\"\n        });\n    }\n    return issues.slice(0, 8); // Limit to reasonable number\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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QSxDQUFBQSxRQUFRQSxPQUFPLENBQUNDLFFBQVEsQ0FBQyxjQUN4QkQsUUFBUUEsT0FBTyxDQUFDQyxRQUFRLENBQUMsWUFBWUQsUUFBUUEsT0FBTyxDQUFDQyxRQUFRLENBQUMsUUFBUTtnQkFHekUsSUFBSXVFLGdCQUFnQmxHLE1BQU0sR0FBRyxHQUFHO29CQUNoQ3dGLE9BQU85QyxJQUFJLENBQUM7d0JBQ1ZDLElBQUksQ0FBQyxXQUFXLEVBQUVjLFdBQVcsQ0FBQzt3QkFDOUJiLE1BQU07d0JBQ04rQyxVQUFVO3dCQUNWeEYsT0FBT0EsTUFBTWQsSUFBSTt3QkFDakJ1RyxRQUFRO3dCQUNSN0MsYUFBYSxDQUFDLEVBQUVtRCxnQkFBZ0JsRyxNQUFNLENBQUMsaUNBQWlDLENBQUM7d0JBQ3pFOEYsZUFBZUksZ0JBQWdCM0YsR0FBRyxDQUFDLENBQUM0RixJQUFXQSxFQUFFQyxPQUFPO3dCQUN4REwsY0FBYztvQkFDaEI7Z0JBQ0Y7WUFDRjtRQUNGO0lBQ0Y7SUFFQSxzRUFBc0U7SUFDdEUsSUFBSVAsT0FBT3hGLE1BQU0sS0FBSyxHQUFHO1FBQ3ZCd0YsT0FBTzlDLElBQUksQ0FBQztZQUNWQyxJQUFJO1lBQ0pDLE1BQU07WUFDTitDLFVBQVU7WUFDVnhGLE9BQU87WUFDUHlGLFFBQVE7WUFDUjdDLGFBQWE7WUFDYitDLGVBQWU7Z0JBQUM7Z0JBQU87Z0JBQU87YUFBTTtZQUNwQ0MsY0FBYztRQUNoQjtRQUVBUCxPQUFPOUMsSUFBSSxDQUFDO1lBQ1ZDLElBQUk7WUFDSkMsTUFBTTtZQUNOK0MsVUFBVTtZQUNWeEYsT0FBTztZQUNQeUYsUUFBUTtZQUNSN0MsYUFBYTtZQUNiK0MsZUFBZTtnQkFBQztnQkFBTTtnQkFBTzthQUFNO1lBQ25DQyxjQUFjO1FBQ2hCO0lBQ0Y7SUFFQSxPQUFPUCxPQUFPVCxLQUFLLENBQUMsR0FBRyxJQUFJLDZCQUE2QjtBQUMxRCIsInNvdXJjZXMiOlsid2VicGFjazovL3JlLWdlbnQtZnJvbnRlbmQvLi9wYWdlcy9hcGkvZXhjZWwvYW5hbHl6ZS50cz85MTEzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IE5leHRBcGlSZXF1ZXN0LCBOZXh0QXBpUmVzcG9uc2UgfSBmcm9tICduZXh0JztcclxuaW1wb3J0ICogYXMgWExTWCBmcm9tICd4bHN4JztcclxuaW1wb3J0IHsgRXhjZWxBbmFseXNpcywgQW5hbHlzaXNTdW1tYXJ5LCBSZWNvbW1lbmRhdGlvbiwgRGF0YVF1YWxpdHlJc3N1ZSwgR2VuZXJhdGVkRm9ybXVsYSwgUG93ZXJRdWVyeVRlbXBsYXRlIH0gZnJvbSAnLi4vLi4vLi4vdHlwZXMvZXhjZWwnO1xyXG5cclxuLy8gRW5oYW5jZWQgYW5hbHlzaXMgd2l0aCBtb3JlIHJlYWxpc3RpYyBkYXRhIGdlbmVyYXRpb25cclxuZXhwb3J0IGRlZmF1bHQgYXN5bmMgZnVuY3Rpb24gaGFuZGxlcihyZXE6IE5leHRBcGlSZXF1ZXN0LCByZXM6IE5leHRBcGlSZXNwb25zZSkge1xyXG4gIGlmIChyZXEubWV0aG9kICE9PSAnUE9TVCcpIHtcclxuICAgIHJldHVybiByZXMuc3RhdHVzKDQwNSkuanNvbih7IGVycm9yOiAnTWV0aG9kIG5vdCBhbGxvd2VkJyB9KTtcclxuICB9XHJcbiAgXHJcbiAgdHJ5IHtcclxuICAgIGNvbnN0IHsgd29ya2Jvb2tJZCwgd29ya2Jvb2sgfSA9IHJlcS5ib2R5O1xyXG4gICAgXHJcbiAgICBpZiAoIXdvcmtib29rSWQpIHtcclxuICAgICAgcmV0dXJuIHJlcy5zdGF0dXMoNDAwKS5qc29uKHsgZXJyb3I6ICdXb3JrYm9vayBJRCBpcyByZXF1aXJlZCcgfSk7XHJcbiAgICB9XHJcbiAgICBcclxuICAgIC8vIFNpbXVsYXRlIGFuYWx5c2lzIHByb2Nlc3NpbmcgdGltZVxyXG4gICAgYXdhaXQgbmV3IFByb21pc2UocmVzb2x2ZSA9PiBzZXRUaW1lb3V0KHJlc29sdmUsIDE1MDApKTtcclxuICAgIFxyXG4gICAgLy8gR2VuZXJhdGUgZHluYW1pYyBhbmFseXNpcyBiYXNlZCBvbiB3b3JrYm9vayBpZiBwcm92aWRlZFxyXG4gICAgY29uc3QgYW5hbHlzaXM6IFBhcnRpYWw8RXhjZWxBbmFseXNpcz4gPSBnZW5lcmF0ZUR5bmFtaWNBbmFseXNpcyh3b3JrYm9vayk7XHJcbiAgICBcclxuICAgIHJlcy5zdGF0dXMoMjAwKS5qc29uKGFuYWx5c2lzKTtcclxuICB9IGNhdGNoIChlcnJvcikge1xyXG4gICAgY29uc29sZS5lcnJvcignRXJyb3IgYW5hbHl6aW5nIHdvcmtib29rOicsIGVycm9yKTtcclxuICAgIHJlcy5zdGF0dXMoNTAwKS5qc29uKHsgZXJyb3I6ICdGYWlsZWQgdG8gYW5hbHl6ZSB3b3JrYm9vaycgfSk7XHJcbiAgfVxyXG59XHJcblxyXG5mdW5jdGlvbiBnZW5lcmF0ZUR5bmFtaWNBbmFseXNpcyh3b3JrYm9vazogYW55KTogUGFydGlhbDxFeGNlbEFuYWx5c2lzPiB7XHJcbiAgY29uc29sZS5sb2coJ0dlbmVyYXRpbmcgZHluYW1pYyBhbmFseXNpcyBmb3Igd29ya2Jvb2s6Jywgd29ya2Jvb2s/Lm5hbWUpO1xyXG4gIFxyXG4gIC8vIERlZmF1bHQgdmFsdWVzIGZvciB3aGVuIG5vIHdvcmtib29rIGlzIHByb3ZpZGVkXHJcbiAgbGV0IHRvdGFsU2hlZXRzID0gMztcclxuICBsZXQgdG90YWxSb3dzID0gMTI1MDtcclxuICBsZXQgdG90YWxDb2x1bW5zID0gMTI7XHJcbiAgbGV0IHRvdGFsRm9ybXVsYXMgPSA0NTtcclxuICBsZXQgY29tcGxleGl0eVNjb3JlID0gNzI7XHJcbiAgbGV0IGF1dG9tYXRpb25Qb3RlbnRpYWw6ICdsb3cnIHwgJ21lZGl1bScgfCAnaGlnaCcgPSAnaGlnaCc7XHJcbiAgbGV0IGRhdGFUeXBlc0Rpc3RyaWJ1dGlvbiA9IHsgJ3RleHQnOiA2LCAnbnVtYmVyJzogNCwgJ2RhdGUnOiAyIH07XHJcbiAgXHJcbiAgLy8gSWYgd29ya2Jvb2sgZGF0YSBpcyBwcm92aWRlZCwgYW5hbHl6ZSBpdCBmb3IgcmVhbCBpbnNpZ2h0c1xyXG4gIGlmICh3b3JrYm9vayAmJiB3b3JrYm9vay5zaGVldHMgJiYgQXJyYXkuaXNBcnJheSh3b3JrYm9vay5zaGVldHMpKSB7XHJcbiAgICBjb25zb2xlLmxvZygnQW5hbHl6aW5nIHJlYWwgd29ya2Jvb2sgZGF0YS4uLicpO1xyXG4gICAgXHJcbiAgICB0b3RhbFNoZWV0cyA9IHdvcmtib29rLnNoZWV0cy5sZW5ndGg7XHJcbiAgICB0b3RhbFJvd3MgPSB3b3JrYm9vay5zaGVldHMucmVkdWNlKChzdW06IG51bWJlciwgc2hlZXQ6IGFueSkgPT4gc3VtICsgKHNoZWV0LnJvd0NvdW50IHx8IDApLCAwKTtcclxuICAgIHRvdGFsQ29sdW1ucyA9IE1hdGgubWF4KC4uLndvcmtib29rLnNoZWV0cy5tYXAoKHNoZWV0OiBhbnkpID0+IHNoZWV0LmNvbHVtbkNvdW50IHx8IDApLCAxKTtcclxuICAgIHRvdGFsRm9ybXVsYXMgPSB3b3JrYm9vay5zaGVldHMucmVkdWNlKChzdW06IG51bWJlciwgc2hlZXQ6IGFueSkgPT4gc3VtICsgKHNoZWV0LmZvcm11bGFDZWxscz8ubGVuZ3RoIHx8IDApLCAwKTtcclxuICAgICAgLy8gQW5hbHl6ZSBkYXRhIHR5cGVzIGFjcm9zcyBhbGwgc2hlZXRzXHJcbiAgICBjb25zdCBhbGxEYXRhVHlwZXM6IHsgdGV4dDogbnVtYmVyOyBudW1iZXI6IG51bWJlcjsgZGF0ZTogbnVtYmVyIH0gPSB7IHRleHQ6IDAsIG51bWJlcjogMCwgZGF0ZTogMCB9O1xyXG4gICAgXHJcbiAgICB3b3JrYm9vay5zaGVldHMuZm9yRWFjaCgoc2hlZXQ6IGFueSkgPT4ge1xyXG4gICAgICBpZiAoc2hlZXQuZGF0YVR5cGVzICYmIEFycmF5LmlzQXJyYXkoc2hlZXQuZGF0YVR5cGVzKSkge1xyXG4gICAgICAgIHNoZWV0LmRhdGFUeXBlcy5mb3JFYWNoKChjb2w6IGFueSkgPT4ge1xyXG4gICAgICAgICAgaWYgKGNvbC5kYXRhVHlwZSA9PT0gJ3RleHQnKSB7XHJcbiAgICAgICAgICAgIGFsbERhdGFUeXBlcy50ZXh0ICs9IDE7XHJcbiAgICAgICAgICB9IGVsc2UgaWYgKGNvbC5kYXRhVHlwZSA9PT0gJ251bWJlcicpIHtcclxuICAgICAgICAgICAgYWxsRGF0YVR5cGVzLm51bWJlciArPSAxO1xyXG4gICAgICAgICAgfSBlbHNlIGlmIChjb2wuZGF0YVR5cGUgPT09ICdkYXRlJykge1xyXG4gICAgICAgICAgICBhbGxEYXRhVHlwZXMuZGF0ZSArPSAxO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG4gICAgICB9XHJcbiAgICB9KTtcclxuICAgIFxyXG4gICAgZGF0YVR5cGVzRGlzdHJpYnV0aW9uID0gYWxsRGF0YVR5cGVzO1xyXG4gICAgXHJcbiAgICAvLyBDYWxjdWxhdGUgY29tcGxleGl0eSBzY29yZSBiYXNlZCBvbiBhY3R1YWwgZGF0YVxyXG4gICAgY29uc3QgZm9ybXVsYURlbnNpdHkgPSB0b3RhbFJvd3MgPiAwID8gKHRvdGFsRm9ybXVsYXMgLyB0b3RhbFJvd3MpICogMTAwIDogMDtcclxuICAgIGNvbnN0IHNoZWV0Q29tcGxleGl0eSA9IHRvdGFsU2hlZXRzICogMTA7XHJcbiAgICBjb25zdCBkYXRhVm9sdW1lQ29tcGxleGl0eSA9IE1hdGgubWluKDMwLCBNYXRoLmxvZzEwKHRvdGFsUm93cyArIDEpICogMTApO1xyXG4gICAgXHJcbiAgICBjb21wbGV4aXR5U2NvcmUgPSBNYXRoLm1pbigxMDAsIE1hdGgucm91bmQoZm9ybXVsYURlbnNpdHkgKyBzaGVldENvbXBsZXhpdHkgKyBkYXRhVm9sdW1lQ29tcGxleGl0eSkpO1xyXG4gICAgXHJcbiAgICAvLyBEZXRlcm1pbmUgYXV0b21hdGlvbiBwb3RlbnRpYWwgYmFzZWQgb24gcmVhbCBtZXRyaWNzXHJcbiAgICBjb25zdCBoYXNDb21wbGV4Rm9ybXVsYXMgPSB3b3JrYm9vay5zaGVldHMuc29tZSgoc2hlZXQ6IGFueSkgPT4gXHJcbiAgICAgIHNoZWV0LmZvcm11bGFDZWxscz8uc29tZSgoZm9ybXVsYTogYW55KSA9PiBcclxuICAgICAgICBmb3JtdWxhLmZvcm11bGE/LmluY2x1ZGVzKCdWTE9PS1VQJykgfHwgXHJcbiAgICAgICAgZm9ybXVsYS5mb3JtdWxhPy5pbmNsdWRlcygnSU5ERVgnKSB8fCBcclxuICAgICAgICBmb3JtdWxhLmZvcm11bGE/LmluY2x1ZGVzKCdNQVRDSCcpIHx8XHJcbiAgICAgICAgZm9ybXVsYS5mb3JtdWxhPy5pbmNsdWRlcygnU1VNSUZTJykgfHxcclxuICAgICAgICBmb3JtdWxhLmZvcm11bGE/LmluY2x1ZGVzKCdDT1VOVElGUycpXHJcbiAgICAgIClcclxuICAgICk7XHJcbiAgICBcclxuICAgIGNvbnN0IGhhc011bHRpcGxlU2hlZXRzID0gdG90YWxTaGVldHMgPiAxO1xyXG4gICAgY29uc3QgaGFzTGFyZ2VEYXRhc2V0ID0gdG90YWxSb3dzID4gMTAwO1xyXG4gICAgXHJcbiAgICBpZiAoKGhhc0NvbXBsZXhGb3JtdWxhcyAmJiBoYXNNdWx0aXBsZVNoZWV0cykgfHwgdG90YWxGb3JtdWxhcyA+IDIwKSB7XHJcbiAgICAgIGF1dG9tYXRpb25Qb3RlbnRpYWwgPSAnaGlnaCc7XHJcbiAgICB9IGVsc2UgaWYgKGhhc0NvbXBsZXhGb3JtdWxhcyB8fCBoYXNNdWx0aXBsZVNoZWV0cyB8fCB0b3RhbEZvcm11bGFzID4gNSkge1xyXG4gICAgICBhdXRvbWF0aW9uUG90ZW50aWFsID0gJ21lZGl1bSc7XHJcbiAgICB9IGVsc2Uge1xyXG4gICAgICBhdXRvbWF0aW9uUG90ZW50aWFsID0gJ2xvdyc7XHJcbiAgICB9XHJcbiAgICBcclxuICAgIGNvbnNvbGUubG9nKCdBbmFseXNpcyBtZXRyaWNzOicsIHtcclxuICAgICAgdG90YWxTaGVldHMsXHJcbiAgICAgIHRvdGFsUm93cyxcclxuICAgICAgdG90YWxDb2x1bW5zLFxyXG4gICAgICB0b3RhbEZvcm11bGFzLFxyXG4gICAgICBjb21wbGV4aXR5U2NvcmUsXHJcbiAgICAgIGF1dG9tYXRpb25Qb3RlbnRpYWwsXHJcbiAgICAgIGRhdGFUeXBlc0Rpc3RyaWJ1dGlvblxyXG4gICAgfSk7XHJcbiAgfVxyXG4gIFxyXG4gIHJldHVybiB7XHJcbiAgICBzdW1tYXJ5OiB7XHJcbiAgICAgIHRvdGFsU2hlZXRzLFxyXG4gICAgICB0b3RhbFJvd3MsXHJcbiAgICAgIHRvdGFsQ29sdW1ucyxcclxuICAgICAgdG90YWxGb3JtdWxhcyxcclxuICAgICAgZGF0YVR5cGVzOiBkYXRhVHlwZXNEaXN0cmlidXRpb24sXHJcbiAgICAgIGNvbXBsZXhpdHlTY29yZSxcclxuICAgICAgYXV0b21hdGlvblBvdGVudGlhbCxcclxuICAgIH0sXHJcbiAgICByZWNvbW1lbmRhdGlvbnM6IGdlbmVyYXRlUmVjb21tZW5kYXRpb25zKHRvdGFsRm9ybXVsYXMsIHRvdGFsU2hlZXRzLCBhdXRvbWF0aW9uUG90ZW50aWFsLCB3b3JrYm9vayksXHJcbiAgICBzdWdnZXN0ZWRGb3JtdWxhczogZ2VuZXJhdGVTdWdnZXN0ZWRGb3JtdWxhcyh3b3JrYm9vayksXHJcbiAgICBzdWdnZXN0ZWRQb3dlclF1ZXJpZXM6IGdlbmVyYXRlUG93ZXJRdWVyeVRlbXBsYXRlcyh3b3JrYm9vayksXHJcbiAgICBkYXRhUXVhbGl0eUlzc3VlczogZ2VuZXJhdGVEYXRhUXVhbGl0eUlzc3Vlcyh3b3JrYm9vayksXHJcbiAgfTtcclxufVxyXG5cclxuZnVuY3Rpb24gZ2VuZXJhdGVSZWNvbW1lbmRhdGlvbnMoZm9ybXVsYXM6IG51bWJlciwgc2hlZXRzOiBudW1iZXIsIGF1dG9tYXRpb246IHN0cmluZywgd29ya2Jvb2s/OiBhbnkpOiBSZWNvbW1lbmRhdGlvbltdIHtcclxuICBjb25zdCByZWNvbW1lbmRhdGlvbnM6IFJlY29tbWVuZGF0aW9uW10gPSBbXTtcclxuICBcclxuICAvLyBBbmFseXplIGFjdHVhbCB3b3JrYm9vayBkYXRhIGlmIGF2YWlsYWJsZVxyXG4gIGNvbnN0IGhhc0NvbXBsZXhGb3JtdWxhcyA9IHdvcmtib29rPy5zaGVldHM/LnNvbWUoKHNoZWV0OiBhbnkpID0+IFxyXG4gICAgc2hlZXQuZm9ybXVsYUNlbGxzPy5zb21lKChmb3JtdWxhOiBhbnkpID0+IFxyXG4gICAgICBmb3JtdWxhLmZvcm11bGE/LmluY2x1ZGVzKCdWTE9PS1VQJykgfHwgXHJcbiAgICAgIGZvcm11bGEuZm9ybXVsYT8uaW5jbHVkZXMoJ0lOREVYJykgfHwgXHJcbiAgICAgIGZvcm11bGEuZm9ybXVsYT8uaW5jbHVkZXMoJ1NVTUlGUycpXHJcbiAgICApXHJcbiAgKTtcclxuICBcclxuICBjb25zdCBoYXNNdWx0aXBsZURhdGFTb3VyY2VzID0gc2hlZXRzID4gMTtcclxuICBjb25zdCBoYXNMYXJnZURhdGFzZXQgPSB3b3JrYm9vaz8uc2hlZXRzPy5zb21lKChzaGVldDogYW55KSA9PiBzaGVldC5yb3dDb3VudCA+IDEwMCk7XHJcbiAgXHJcbiAgaWYgKGZvcm11bGFzID4gMTAgfHwgaGFzQ29tcGxleEZvcm11bGFzKSB7XHJcbiAgICByZWNvbW1lbmRhdGlvbnMucHVzaCh7XHJcbiAgICAgIGlkOiAncmVjXzEnLFxyXG4gICAgICB0eXBlOiAncG93ZXJxdWVyeScsXHJcbiAgICAgIHByaW9yaXR5OiAnaGlnaCcsXHJcbiAgICAgIHRpdGxlOiAnQXV0b21hdGUgRGF0YSBQcm9jZXNzaW5nIHdpdGggUG93ZXJRdWVyeScsXHJcbiAgICAgIGRlc2NyaXB0aW9uOiBgJHtoYXNDb21wbGV4Rm9ybXVsYXMgPyAnQ29tcGxleCBsb29rdXAgZm9ybXVsYXMnIDogYCR7Zm9ybXVsYXN9IGZvcm11bGFzYH0gZGV0ZWN0ZWQuIFBvd2VyUXVlcnkgY2FuIGF1dG9tYXRlIHRoZXNlIHRyYW5zZm9ybWF0aW9uc2AsXHJcbiAgICAgIGltcGxlbWVudGF0aW9uOiAnVXNlIERhdGEg4oaSIEdldCBEYXRhIOKGkiBGcm9tIE90aGVyIFNvdXJjZXMg4oaSIEJsYW5rIFF1ZXJ5IHRvIGNyZWF0ZSBhdXRvbWF0ZWQgZGF0YSBwaXBlbGluZXMnLFxyXG4gICAgICBpbXBhY3Q6IGBSZWR1Y2UgbWFudWFsIGZvcm11bGEgbWFpbnRlbmFuY2UgYnkgJHtoYXNDb21wbGV4Rm9ybXVsYXMgPyAnODAlJyA6ICc3MCUnfWAsXHJcbiAgICAgIGVmZm9ydDogaGFzQ29tcGxleEZvcm11bGFzID8gJ2hpZ2gnIDogJ21lZGl1bScsXHJcbiAgICB9KTtcclxuICB9XHJcbiAgXHJcbiAgaWYgKGhhc011bHRpcGxlRGF0YVNvdXJjZXMpIHtcclxuICAgIHJlY29tbWVuZGF0aW9ucy5wdXNoKHtcclxuICAgICAgaWQ6ICdyZWNfMicsXHJcbiAgICAgIHR5cGU6ICdmb3JtdWxhJyxcclxuICAgICAgcHJpb3JpdHk6ICdtZWRpdW0nLFxyXG4gICAgICB0aXRsZTogJ0NvbnNvbGlkYXRlIFNoZWV0IFJlZmVyZW5jZXMnLFxyXG4gICAgICBkZXNjcmlwdGlvbjogYE11bHRpcGxlIHNoZWV0cyBkZXRlY3RlZCAoJHtzaGVldHN9KS4gVXNlIGR5bmFtaWMgcmVmZXJlbmNlcyB0byBpbXByb3ZlIG1haW50YWluYWJpbGl0eWAsXHJcbiAgICAgIGltcGxlbWVudGF0aW9uOiAnUmVwbGFjZSBoYXJkLWNvZGVkIHNoZWV0IHJlZmVyZW5jZXMgd2l0aCBJTkRJUkVDVCBvciBzdHJ1Y3R1cmVkIHJlZmVyZW5jZXMnLFxyXG4gICAgICBpbXBhY3Q6ICdJbXByb3ZlIHdvcmtib29rIGZsZXhpYmlsaXR5IGFuZCByZWR1Y2UgZXJyb3JzJyxcclxuICAgICAgZWZmb3J0OiAnbG93JyxcclxuICAgIH0pO1xyXG4gIH1cclxuICBcclxuICByZWNvbW1lbmRhdGlvbnMucHVzaCh7XHJcbiAgICBpZDogJ3JlY18zJyxcclxuICAgIHR5cGU6ICdkYXRhX3ZhbGlkYXRpb24nLFxyXG4gICAgcHJpb3JpdHk6IGF1dG9tYXRpb24gPT09ICdoaWdoJyA/ICdoaWdoJyA6ICdtZWRpdW0nLFxyXG4gICAgdGl0bGU6ICdJbXBsZW1lbnQgRGF0YSBWYWxpZGF0aW9uJyxcclxuICAgIGRlc2NyaXB0aW9uOiAnQWRkIHZhbGlkYXRpb24gcnVsZXMgdG8gcHJldmVudCBkYXRhIGVudHJ5IGVycm9ycyBhbmQgaW1wcm92ZSBkYXRhIHF1YWxpdHknLFxyXG4gICAgaW1wbGVtZW50YXRpb246ICdVc2UgRGF0YSDihpIgRGF0YSBWYWxpZGF0aW9uIGZvciBjcml0aWNhbCBpbnB1dCBmaWVsZHMnLFxyXG4gICAgaW1wYWN0OiAnUmVkdWNlIGRhdGEgcXVhbGl0eSBpc3N1ZXMgYnkgOTAlJyxcclxuICAgIGVmZm9ydDogJ2xvdycsXHJcbiAgfSk7XHJcbiAgXHJcbiAgcmV0dXJuIHJlY29tbWVuZGF0aW9ucztcclxufVxyXG5cclxuZnVuY3Rpb24gZ2VuZXJhdGVTdWdnZXN0ZWRGb3JtdWxhcyh3b3JrYm9vazogYW55KTogR2VuZXJhdGVkRm9ybXVsYVtdIHtcclxuICBjb25zdCBmb3JtdWxhczogR2VuZXJhdGVkRm9ybXVsYVtdID0gW107XHJcbiAgXHJcbiAgLy8gRGVmYXVsdCBmb3JtdWxhc1xyXG4gIGNvbnN0IGRlZmF1bHRGb3JtdWxhczogR2VuZXJhdGVkRm9ybXVsYVtdID0gW1xyXG4gICAge1xyXG4gICAgICBmb3JtdWxhOiAnPVhMT09LVVAoQTIsUHJvZHVjdHNbUHJvZHVjdF9JRF0sUHJvZHVjdHNbUHJpY2VdLFwiXCIpJyxcclxuICAgICAgZGVzY3JpcHRpb246ICdEeW5hbWljIHByaWNlIGxvb2t1cCB3aXRoIGVycm9yIGhhbmRsaW5nJyxcclxuICAgICAgY2VsbEFkZHJlc3M6ICdEMicsXHJcbiAgICAgIGNhdGVnb3J5OiAnbG9va3VwJyxcclxuICAgICAgY29tcGxleGl0eTogJ2ludGVybWVkaWF0ZScsXHJcbiAgICAgIGRlcGVuZGVuY2llczogWydBMicsICdQcm9kdWN0c1tQcm9kdWN0X0lEXScsICdQcm9kdWN0c1tQcmljZV0nXSxcclxuICAgICAgZXhwbGFuYXRpb246ICdUaGlzIGZvcm11bGEgbG9va3MgdXAgcHJpY2VzIGR5bmFtaWNhbGx5IGFuZCByZXR1cm5zIGFuIGVtcHR5IHN0cmluZyBpZiBub3QgZm91bmQuJyxcclxuICAgIH0sXHJcbiAgICB7XHJcbiAgICAgIGZvcm11bGE6ICc9U1VNSUZTKFNhbGVzW0Ftb3VudF0sU2FsZXNbRGF0ZV0sXCI+PVwiJlRPREFZKCktMzApJyxcclxuICAgICAgZGVzY3JpcHRpb246ICdTdW0gc2FsZXMgZnJvbSBsYXN0IDMwIGRheXMnLFxyXG4gICAgICBjZWxsQWRkcmVzczogJ0cyJyxcclxuICAgICAgY2F0ZWdvcnk6ICdtYXRoJyxcclxuICAgICAgY29tcGxleGl0eTogJ2ludGVybWVkaWF0ZScsXHJcbiAgICAgIGRlcGVuZGVuY2llczogWydTYWxlc1tBbW91bnRdJywgJ1NhbGVzW0RhdGVdJ10sXHJcbiAgICAgIGV4cGxhbmF0aW9uOiAnQ2FsY3VsYXRlcyB0b3RhbCBzYWxlcyBmb3IgdGhlIGxhc3QgMzAgZGF5cyB1c2luZyBkeW5hbWljIGRhdGUgY3JpdGVyaWEuJyxcclxuICAgIH0sXHJcbiAgXTtcclxuICBcclxuICAvLyBBZGQgd29ya2Jvb2stc3BlY2lmaWMgZm9ybXVsYXMgaWYgZGF0YSBpcyBhdmFpbGFibGVcclxuICBpZiAod29ya2Jvb2sgJiYgd29ya2Jvb2suc2hlZXRzKSB7XHJcbiAgICB3b3JrYm9vay5zaGVldHMuZm9yRWFjaCgoc2hlZXQ6IGFueSwgc2hlZXRJbmRleDogbnVtYmVyKSA9PiB7XHJcbiAgICAgIGlmIChzaGVldC5oZWFkZXJzICYmIHNoZWV0LmRhdGFUeXBlcykge1xyXG4gICAgICAgIFxyXG4gICAgICAgIC8vIEdlbmVyYXRlIGZvcm11bGFzIGJhc2VkIG9uIGRldGVjdGVkIGRhdGEgdHlwZXNcclxuICAgICAgICBjb25zdCBudW1iZXJDb2x1bW5zID0gc2hlZXQuZGF0YVR5cGVzLmZpbHRlcigoY29sOiBhbnkpID0+IGNvbC5kYXRhVHlwZSA9PT0gJ251bWJlcicpO1xyXG4gICAgICAgIGNvbnN0IGRhdGVDb2x1bW5zID0gc2hlZXQuZGF0YVR5cGVzLmZpbHRlcigoY29sOiBhbnkpID0+IGNvbC5kYXRhVHlwZSA9PT0gJ2RhdGUnKTtcclxuICAgICAgICBjb25zdCB0ZXh0Q29sdW1ucyA9IHNoZWV0LmRhdGFUeXBlcy5maWx0ZXIoKGNvbDogYW55KSA9PiBjb2wuZGF0YVR5cGUgPT09ICd0ZXh0Jyk7XHJcbiAgICAgICAgICAvLyBJZiB3ZSBoYXZlIG51bWJlciBjb2x1bW5zLCBzdWdnZXN0IFNVTSBmb3JtdWxhc1xyXG4gICAgICAgIGlmIChudW1iZXJDb2x1bW5zLmxlbmd0aCA+IDApIHtcclxuICAgICAgICAgIGNvbnN0IGZpcnN0TnVtYmVyQ29sID0gbnVtYmVyQ29sdW1uc1swXTtcclxuICAgICAgICAgIGNvbnN0IGNvbExldHRlciA9IGZpcnN0TnVtYmVyQ29sLmNvbHVtbkxldHRlciB8fCBYTFNYLnV0aWxzLmVuY29kZV9jb2woZmlyc3ROdW1iZXJDb2wuY29sdW1uSW5kZXggfHwgMCk7XHJcbiAgICAgICAgICBcclxuICAgICAgICAgIGZvcm11bGFzLnB1c2goe1xyXG4gICAgICAgICAgICBmb3JtdWxhOiBgPVNVTSgke2NvbExldHRlcn0yOiR7Y29sTGV0dGVyfTEwMDApYCxcclxuICAgICAgICAgICAgZGVzY3JpcHRpb246IGBTdW0gYWxsIHZhbHVlcyBpbiAke2ZpcnN0TnVtYmVyQ29sLmhlYWRlcn0gY29sdW1uYCxcclxuICAgICAgICAgICAgY2VsbEFkZHJlc3M6IGAke2NvbExldHRlcn0ke3NoZWV0LnJvd0NvdW50ICsgMn1gLFxyXG4gICAgICAgICAgICBjYXRlZ29yeTogJ21hdGgnLFxyXG4gICAgICAgICAgICBjb21wbGV4aXR5OiAnYmFzaWMnLFxyXG4gICAgICAgICAgICBkZXBlbmRlbmNpZXM6IFtgJHtjb2xMZXR0ZXJ9Mjoke2NvbExldHRlcn0xMDAwYF0sXHJcbiAgICAgICAgICAgIGV4cGxhbmF0aW9uOiBgQ2FsY3VsYXRlcyB0aGUgdG90YWwgb2YgYWxsIG51bWVyaWMgdmFsdWVzIGluIHRoZSAke2ZpcnN0TnVtYmVyQ29sLmhlYWRlcn0gY29sdW1uLmAsXHJcbiAgICAgICAgICB9KTtcclxuICAgICAgICAgIFxyXG4gICAgICAgICAgZm9ybXVsYXMucHVzaCh7XHJcbiAgICAgICAgICAgIGZvcm11bGE6IGA9QVZFUkFHRSgke2NvbExldHRlcn0yOiR7Y29sTGV0dGVyfTEwMDApYCxcclxuICAgICAgICAgICAgZGVzY3JpcHRpb246IGBBdmVyYWdlIG9mICR7Zmlyc3ROdW1iZXJDb2wuaGVhZGVyfSBjb2x1bW5gLFxyXG4gICAgICAgICAgICBjZWxsQWRkcmVzczogYCR7Y29sTGV0dGVyfSR7c2hlZXQucm93Q291bnQgKyAzfWAsXHJcbiAgICAgICAgICAgIGNhdGVnb3J5OiAnbWF0aCcsXHJcbiAgICAgICAgICAgIGNvbXBsZXhpdHk6ICdiYXNpYycsXHJcbiAgICAgICAgICAgIGRlcGVuZGVuY2llczogW2Ake2NvbExldHRlcn0yOiR7Y29sTGV0dGVyfTEwMDBgXSxcclxuICAgICAgICAgICAgZXhwbGFuYXRpb246IGBDYWxjdWxhdGVzIHRoZSBhdmVyYWdlIG9mIGFsbCBudW1lcmljIHZhbHVlcyBpbiB0aGUgJHtmaXJzdE51bWJlckNvbC5oZWFkZXJ9IGNvbHVtbi5gLFxyXG4gICAgICAgICAgfSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgICAgLy8gSWYgd2UgaGF2ZSBkYXRlIGNvbHVtbnMsIHN1Z2dlc3QgZGF0ZS1yZWxhdGVkIGZvcm11bGFzXHJcbiAgICAgICAgaWYgKGRhdGVDb2x1bW5zLmxlbmd0aCA+IDApIHtcclxuICAgICAgICAgIGNvbnN0IGZpcnN0RGF0ZUNvbCA9IGRhdGVDb2x1bW5zWzBdO1xyXG4gICAgICAgICAgY29uc3QgY29sTGV0dGVyID0gZmlyc3REYXRlQ29sLmNvbHVtbkxldHRlciB8fCBYTFNYLnV0aWxzLmVuY29kZV9jb2woZmlyc3REYXRlQ29sLmNvbHVtbkluZGV4IHx8IDApO1xyXG4gICAgICAgICAgY29uc3QgbmV4dENvbExldHRlciA9IFhMU1gudXRpbHMuZW5jb2RlX2NvbCgoZmlyc3REYXRlQ29sLmNvbHVtbkluZGV4IHx8IDApICsgMSk7XHJcbiAgICAgICAgICBcclxuICAgICAgICAgIGZvcm11bGFzLnB1c2goe1xyXG4gICAgICAgICAgICBmb3JtdWxhOiBgPUNPVU5USUZTKCR7Y29sTGV0dGVyfToke2NvbExldHRlcn0sXCI+PVwiJlRPREFZKCktMzApYCxcclxuICAgICAgICAgICAgZGVzY3JpcHRpb246IGBDb3VudCByZWNlbnQgZW50cmllcyBpbiAke2ZpcnN0RGF0ZUNvbC5oZWFkZXJ9YCxcclxuICAgICAgICAgICAgY2VsbEFkZHJlc3M6IGAke25leHRDb2xMZXR0ZXJ9JHtzaGVldC5yb3dDb3VudCArIDJ9YCxcclxuICAgICAgICAgICAgY2F0ZWdvcnk6ICdkYXRlJyxcclxuICAgICAgICAgICAgY29tcGxleGl0eTogJ2ludGVybWVkaWF0ZScsXHJcbiAgICAgICAgICAgIGRlcGVuZGVuY2llczogW2Ake2NvbExldHRlcn06JHtjb2xMZXR0ZXJ9YF0sXHJcbiAgICAgICAgICAgIGV4cGxhbmF0aW9uOiBgQ291bnRzIGhvdyBtYW55IGVudHJpZXMgaW4gJHtmaXJzdERhdGVDb2wuaGVhZGVyfSBhcmUgZnJvbSB0aGUgbGFzdCAzMCBkYXlzLmAsXHJcbiAgICAgICAgICB9KTtcclxuICAgICAgICB9XHJcbiAgICAgICAgICAvLyBJZiB3ZSBoYXZlIG11bHRpcGxlIGNvbHVtbnMsIHN1Z2dlc3QgbG9va3VwIGZvcm11bGFzXHJcbiAgICAgICAgaWYgKHNoZWV0LmhlYWRlcnMubGVuZ3RoID4gMikge1xyXG4gICAgICAgICAgY29uc3QgZmlyc3RDb2wgPSBzaGVldC5kYXRhVHlwZXNbMF07XHJcbiAgICAgICAgICBjb25zdCBzZWNvbmRDb2wgPSBzaGVldC5kYXRhVHlwZXNbMV07XHJcbiAgICAgICAgICBpZiAoZmlyc3RDb2wgJiYgc2Vjb25kQ29sKSB7XHJcbiAgICAgICAgICAgIGNvbnN0IGZpcnN0Q29sTGV0dGVyID0gZmlyc3RDb2wuY29sdW1uTGV0dGVyIHx8IFhMU1gudXRpbHMuZW5jb2RlX2NvbChmaXJzdENvbC5jb2x1bW5JbmRleCB8fCAwKTtcclxuICAgICAgICAgICAgY29uc3Qgc2Vjb25kQ29sTGV0dGVyID0gc2Vjb25kQ29sLmNvbHVtbkxldHRlciB8fCBYTFNYLnV0aWxzLmVuY29kZV9jb2woc2Vjb25kQ29sLmNvbHVtbkluZGV4IHx8IDEpO1xyXG4gICAgICAgICAgICBjb25zdCByZXN1bHRDb2xMZXR0ZXIgPSBYTFNYLnV0aWxzLmVuY29kZV9jb2woKHNlY29uZENvbC5jb2x1bW5JbmRleCB8fCAxKSArIDIpO1xyXG4gICAgICAgICAgICBcclxuICAgICAgICAgICAgZm9ybXVsYXMucHVzaCh7XHJcbiAgICAgICAgICAgICAgZm9ybXVsYTogYD1YTE9PS1VQKEEyLCR7Zmlyc3RDb2xMZXR0ZXJ9OiR7Zmlyc3RDb2xMZXR0ZXJ9LCR7c2Vjb25kQ29sTGV0dGVyfToke3NlY29uZENvbExldHRlcn0sXCJOb3QgRm91bmRcIilgLFxyXG4gICAgICAgICAgICAgIGRlc2NyaXB0aW9uOiBgTG9va3VwICR7c2Vjb25kQ29sLmhlYWRlcn0gYmFzZWQgb24gJHtmaXJzdENvbC5oZWFkZXJ9YCxcclxuICAgICAgICAgICAgICBjZWxsQWRkcmVzczogYCR7cmVzdWx0Q29sTGV0dGVyfTJgLFxyXG4gICAgICAgICAgICAgIGNhdGVnb3J5OiAnbG9va3VwJyxcclxuICAgICAgICAgICAgICBjb21wbGV4aXR5OiAnaW50ZXJtZWRpYXRlJyxcclxuICAgICAgICAgICAgICBkZXBlbmRlbmNpZXM6IFtgQTJgLCBgJHtmaXJzdENvbExldHRlcn06JHtmaXJzdENvbExldHRlcn1gLCBgJHtzZWNvbmRDb2xMZXR0ZXJ9OiR7c2Vjb25kQ29sTGV0dGVyfWBdLCAgICAgICAgICAgICAgZXhwbGFuYXRpb246IGBGaW5kcyB0aGUgY29ycmVzcG9uZGluZyAke3NlY29uZENvbC5oZWFkZXJ9IHZhbHVlIGZvciBlYWNoICR7Zmlyc3RDb2wuaGVhZGVyfSBlbnRyeS5gLFxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuICAgIH0pO1xyXG4gIH1cclxuICBcclxuICAvLyBBZGQgZGVmYXVsdCBmb3JtdWxhcyB3aXRoIHdvcmtib29rLXNwZWNpZmljIG9uZXNcclxuICBpZiAod29ya2Jvb2sgJiYgd29ya2Jvb2suc2hlZXRzKSB7XHJcbiAgICBjb25zdCBoYXNEYXRlQ29sdW1ucyA9IHdvcmtib29rLnNoZWV0cy5zb21lKChzaGVldDogYW55KSA9PiBcclxuICAgICAgc2hlZXQuZGF0YVR5cGVzPy5zb21lKChkdDogYW55KSA9PiBkdC5kYXRhVHlwZSA9PT0gJ2RhdGUnKVxyXG4gICAgKTtcclxuICAgIFxyXG4gICAgaWYgKGhhc0RhdGVDb2x1bW5zKSB7XHJcbiAgICAgIGZvcm11bGFzLnB1c2goe1xyXG4gICAgICAgIGZvcm11bGE6ICc9RklMVEVSKERhdGFbUHJvZHVjdF0sKERhdGFbRGF0ZV0+PUVPTU9OVEgoVE9EQVkoKSwtMSkrMSkqKERhdGFbRGF0ZV08PUVPTU9OVEgoVE9EQVkoKSwwKSkpJyxcclxuICAgICAgICBkZXNjcmlwdGlvbjogJ0ZpbHRlciBjdXJyZW50IG1vbnRoIGRhdGEnLFxyXG4gICAgICAgIGNlbGxBZGRyZXNzOiAnQTEwJyxcclxuICAgICAgICBjYXRlZ29yeTogJ2xvb2t1cCcsXHJcbiAgICAgICAgY29tcGxleGl0eTogJ2FkdmFuY2VkJyxcclxuICAgICAgICBkZXBlbmRlbmNpZXM6IFsnRGF0YVtQcm9kdWN0XScsICdEYXRhW0RhdGVdJ10sXHJcbiAgICAgICAgZXhwbGFuYXRpb246ICdSZXR1cm5zIGFsbCByZWNvcmRzIGZyb20gdGhlIGN1cnJlbnQgbW9udGggdXNpbmcgZHluYW1pYyBhcnJheSBmb3JtdWxhcy4nLFxyXG4gICAgICB9KTtcclxuICAgIH1cclxuICB9XHJcbiAgXHJcbiAgLy8gQ29tYmluZSBkZWZhdWx0IGFuZCBnZW5lcmF0ZWQgZm9ybXVsYXMsIGxpbWl0aW5nIHRvIHJlYXNvbmFibGUgYW1vdW50XHJcbiAgcmV0dXJuIFsuLi5kZWZhdWx0Rm9ybXVsYXMsIC4uLmZvcm11bGFzXS5zbGljZSgwLCA4KTtcclxufVxyXG5cclxuZnVuY3Rpb24gZ2VuZXJhdGVQb3dlclF1ZXJ5VGVtcGxhdGVzKHdvcmtib29rOiBhbnkpOiBQb3dlclF1ZXJ5VGVtcGxhdGVbXSB7XHJcbiAgY29uc3QgdGVtcGxhdGVzOiBQb3dlclF1ZXJ5VGVtcGxhdGVbXSA9IFtcclxuICAgIHtcclxuICAgICAgaWQ6ICdwcV8xJyxcclxuICAgICAgbmFtZTogJ0RhdGEgU3RhbmRhcmRpemF0aW9uJyxcclxuICAgICAgZGVzY3JpcHRpb246ICdDbGVhbiBhbmQgc3RhbmRhcmRpemUgZGF0YSBmb3JtYXRzIGFjcm9zcyBhbGwgY29sdW1ucycsXHJcbiAgICAgIGNhdGVnb3J5OiAnZGF0YV9jbGVhbmluZycsXHJcbiAgICAgIHN0ZXBzOiBbXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgaWQ6ICdzdGVwXzEnLFxyXG4gICAgICAgICAgbmFtZTogJ1Byb21vdGUgSGVhZGVycycsXHJcbiAgICAgICAgICBvcGVyYXRpb246ICdoZWFkZXJzJyxcclxuICAgICAgICAgIG1Db2RlOiAnVGFibGUuUHJvbW90ZUhlYWRlcnMoU291cmNlLCBbUHJvbW90ZUFsbFNjYWxhcnM9dHJ1ZV0pJyxcclxuICAgICAgICAgIGRlc2NyaXB0aW9uOiAnUHJvbW90ZSBmaXJzdCByb3cgdG8gY29sdW1uIGhlYWRlcnMnLFxyXG4gICAgICAgICAgaXNBcHBsaWVkOiB0cnVlLFxyXG4gICAgICAgIH0sXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgaWQ6ICdzdGVwXzInLFxyXG4gICAgICAgICAgbmFtZTogJ1RyaW0gVGV4dCcsXHJcbiAgICAgICAgICBvcGVyYXRpb246ICdyZXBsYWNlJyxcclxuICAgICAgICAgIG1Db2RlOiAnVGFibGUuVHJhbnNmb3JtQ29sdW1ucygjXCJQcm9tb3RlZCBIZWFkZXJzXCIsIHt9LCBUZXh0LlRyaW0pJyxcclxuICAgICAgICAgIGRlc2NyaXB0aW9uOiAnUmVtb3ZlIGxlYWRpbmcgYW5kIHRyYWlsaW5nIHNwYWNlcycsXHJcbiAgICAgICAgICBpc0FwcGxpZWQ6IHRydWUsXHJcbiAgICAgICAgfSxcclxuICAgICAgICB7XHJcbiAgICAgICAgICBpZDogJ3N0ZXBfMycsXHJcbiAgICAgICAgICBuYW1lOiAnRGV0ZWN0IERhdGEgVHlwZXMnLFxyXG4gICAgICAgICAgb3BlcmF0aW9uOiAnZGF0YVR5cGVzJyxcclxuICAgICAgICAgIG1Db2RlOiAnVGFibGUuRGV0ZWN0RGF0YVR5cGVzKCNcIlRyaW1tZWQgVGV4dFwiKScsXHJcbiAgICAgICAgICBkZXNjcmlwdGlvbjogJ0F1dG9tYXRpY2FsbHkgZGV0ZWN0IGFuZCBhcHBseSBwcm9wZXIgZGF0YSB0eXBlcycsXHJcbiAgICAgICAgICBpc0FwcGxpZWQ6IHRydWUsXHJcbiAgICAgICAgfSxcclxuICAgICAgXSxcclxuICAgICAgcmVxdWlyZWRDb2x1bW5zOiBbXSxcclxuICAgICAgb3V0cHV0Q29sdW1uczogW10sXHJcbiAgICAgIG1Db2RlOiBgbGV0XHJcbiAgICBTb3VyY2UgPSBFeGNlbC5DdXJyZW50V29ya2Jvb2soKXtbTmFtZT1cIlRhYmxlMVwiXX1bQ29udGVudF0sXHJcbiAgICAjXCJQcm9tb3RlZCBIZWFkZXJzXCIgPSBUYWJsZS5Qcm9tb3RlSGVhZGVycyhTb3VyY2UsIFtQcm9tb3RlQWxsU2NhbGFycz10cnVlXSksXHJcbiAgICAjXCJUcmltbWVkIFRleHRcIiA9IFRhYmxlLlRyYW5zZm9ybUNvbHVtbnMoI1wiUHJvbW90ZWQgSGVhZGVyc1wiLCB7fSwgVGV4dC5UcmltKSxcclxuICAgICNcIkRldGVjdGVkIFR5cGVzXCIgPSBUYWJsZS5EZXRlY3REYXRhVHlwZXMoI1wiVHJpbW1lZCBUZXh0XCIpXHJcbmluXHJcbiAgICAjXCJEZXRlY3RlZCBUeXBlc1wiYCxcclxuICAgIH0sXHJcbiAgXTtcclxuICBcclxuICAvLyBBZGQgd29ya2Jvb2stc3BlY2lmaWMgdGVtcGxhdGVzXHJcbiAgaWYgKHdvcmtib29rICYmIHdvcmtib29rLnNoZWV0cykge1xyXG4gICAgY29uc3QgaGFzTnVtZXJpY0RhdGEgPSB3b3JrYm9vay5zaGVldHMuc29tZSgoc2hlZXQ6IGFueSkgPT4gXHJcbiAgICAgIHNoZWV0LmRhdGFUeXBlcz8uc29tZSgoZHQ6IGFueSkgPT4gZHQuZGF0YVR5cGUgPT09ICdudW1iZXInKVxyXG4gICAgKTtcclxuICAgIFxyXG4gICAgaWYgKGhhc051bWVyaWNEYXRhKSB7XHJcbiAgICAgIHRlbXBsYXRlcy5wdXNoKHtcclxuICAgICAgICBpZDogJ3BxXzInLFxyXG4gICAgICAgIG5hbWU6ICdOdW1lcmljYWwgQW5hbHlzaXMnLFxyXG4gICAgICAgIGRlc2NyaXB0aW9uOiAnR3JvdXAgYW5kIGFuYWx5emUgbnVtZXJpY2FsIGRhdGEgd2l0aCBjYWxjdWxhdGlvbnMnLFxyXG4gICAgICAgIGNhdGVnb3J5OiAnYW5hbHlzaXMnLFxyXG4gICAgICAgIHN0ZXBzOiBbXHJcbiAgICAgICAgICB7XHJcbiAgICAgICAgICAgIGlkOiAnc3RlcF8xJyxcclxuICAgICAgICAgICAgbmFtZTogJ0dyb3VwIEJ5IENhdGVnb3J5JyxcclxuICAgICAgICAgICAgb3BlcmF0aW9uOiAnZ3JvdXAnLFxyXG4gICAgICAgICAgICBtQ29kZTogJ1RhYmxlLkdyb3VwKFNvdXJjZSwge1wiQ2F0ZWdvcnlcIn0sIHt7XCJUb3RhbFwiLCBlYWNoIExpc3QuU3VtKFtBbW91bnRdKSwgdHlwZSBudW1iZXJ9LCB7XCJDb3VudFwiLCBlYWNoIFRhYmxlLlJvd0NvdW50KF8pLCB0eXBlIG51bWJlcn19KScsXHJcbiAgICAgICAgICAgIGRlc2NyaXB0aW9uOiAnR3JvdXAgZGF0YSBhbmQgY2FsY3VsYXRlIHRvdGFscycsXHJcbiAgICAgICAgICAgIGlzQXBwbGllZDogdHJ1ZSxcclxuICAgICAgICAgIH0sXHJcbiAgICAgICAgICB7XHJcbiAgICAgICAgICAgIGlkOiAnc3RlcF8yJyxcclxuICAgICAgICAgICAgbmFtZTogJ0FkZCBQZXJjZW50YWdlJyxcclxuICAgICAgICAgICAgb3BlcmF0aW9uOiAnYWRkX2NvbHVtbicsXHJcbiAgICAgICAgICAgIG1Db2RlOiAnVGFibGUuQWRkQ29sdW1uKCNcIkdyb3VwZWQgUm93c1wiLCBcIlBlcmNlbnRhZ2VcIiwgZWFjaCBbVG90YWxdIC8gTGlzdC5TdW0oI1wiR3JvdXBlZCBSb3dzXCJbVG90YWxdKSAqIDEwMCknLFxyXG4gICAgICAgICAgICBkZXNjcmlwdGlvbjogJ0NhbGN1bGF0ZSBwZXJjZW50YWdlIG9mIHRvdGFsJyxcclxuICAgICAgICAgICAgaXNBcHBsaWVkOiB0cnVlLFxyXG4gICAgICAgICAgfSxcclxuICAgICAgICBdLFxyXG4gICAgICAgIHJlcXVpcmVkQ29sdW1uczogWydDYXRlZ29yeScsICdBbW91bnQnXSxcclxuICAgICAgICBvdXRwdXRDb2x1bW5zOiBbJ0NhdGVnb3J5JywgJ1RvdGFsJywgJ0NvdW50JywgJ1BlcmNlbnRhZ2UnXSxcclxuICAgICAgICBtQ29kZTogYGxldFxyXG4gICAgU291cmNlID0gRXhjZWwuQ3VycmVudFdvcmtib29rKCl7W05hbWU9XCJEYXRhXCJdfVtDb250ZW50XSxcclxuICAgICNcIkdyb3VwZWQgUm93c1wiID0gVGFibGUuR3JvdXAoU291cmNlLCB7XCJDYXRlZ29yeVwifSwge3tcIlRvdGFsXCIsIGVhY2ggTGlzdC5TdW0oW0Ftb3VudF0pLCB0eXBlIG51bWJlcn0sIHtcIkNvdW50XCIsIGVhY2ggVGFibGUuUm93Q291bnQoXyksIHR5cGUgbnVtYmVyfX0pLFxyXG4gICAgI1wiQWRkZWQgUGVyY2VudGFnZVwiID0gVGFibGUuQWRkQ29sdW1uKCNcIkdyb3VwZWQgUm93c1wiLCBcIlBlcmNlbnRhZ2VcIiwgZWFjaCBbVG90YWxdIC8gTGlzdC5TdW0oI1wiR3JvdXBlZCBSb3dzXCJbVG90YWxdKSAqIDEwMClcclxuaW5cclxuICAgICNcIkFkZGVkIFBlcmNlbnRhZ2VcImAsXHJcbiAgICAgIH0pO1xyXG4gICAgfVxyXG4gIH1cclxuICBcclxuICByZXR1cm4gdGVtcGxhdGVzO1xyXG59XHJcblxyXG5mdW5jdGlvbiBnZW5lcmF0ZURhdGFRdWFsaXR5SXNzdWVzKHdvcmtib29rOiBhbnkpOiBEYXRhUXVhbGl0eUlzc3VlW10ge1xyXG4gIGNvbnN0IGlzc3VlczogRGF0YVF1YWxpdHlJc3N1ZVtdID0gW107XHJcbiAgXHJcbiAgaWYgKHdvcmtib29rICYmIHdvcmtib29rLnNoZWV0cykge1xyXG4gICAgd29ya2Jvb2suc2hlZXRzLmZvckVhY2goKHNoZWV0OiBhbnksIHNoZWV0SW5kZXg6IG51bWJlcikgPT4ge1xyXG4gICAgICBpZiAoc2hlZXQuZGF0YVR5cGVzKSB7ICAgICAgICAvLyBDaGVjayBmb3IgY29sdW1ucyB3aXRoIGhpZ2ggbnVsbCBjb3VudHNcclxuICAgICAgICBzaGVldC5kYXRhVHlwZXMuZm9yRWFjaCgoY29sOiBhbnkpID0+IHtcclxuICAgICAgICAgIGNvbnN0IG51bGxQZXJjZW50YWdlID0gY29sLm51bGxDb3VudCAvIE1hdGgubWF4KHNoZWV0LnJvd0NvdW50IC0gMSwgMSkgKiAxMDA7XHJcbiAgICAgICAgICBjb25zdCBjb2xMZXR0ZXIgPSBjb2wuY29sdW1uTGV0dGVyIHx8IFhMU1gudXRpbHMuZW5jb2RlX2NvbChjb2wuY29sdW1uSW5kZXggfHwgMCk7XHJcbiAgICAgICAgICBcclxuICAgICAgICAgIGlmIChudWxsUGVyY2VudGFnZSA+IDIwKSB7XHJcbiAgICAgICAgICAgIGlzc3Vlcy5wdXNoKHtcclxuICAgICAgICAgICAgICBpZDogYGRxX251bGxfJHtzaGVldEluZGV4fV8ke2NvbC5jb2x1bW5JbmRleH1gLFxyXG4gICAgICAgICAgICAgIHR5cGU6ICdtaXNzaW5nX2RhdGEnLFxyXG4gICAgICAgICAgICAgIHNldmVyaXR5OiBudWxsUGVyY2VudGFnZSA+IDUwID8gJ2hpZ2gnIDogJ21lZGl1bScsXHJcbiAgICAgICAgICAgICAgc2hlZXQ6IHNoZWV0Lm5hbWUsXHJcbiAgICAgICAgICAgICAgY29sdW1uOiBjb2wuaGVhZGVyLFxyXG4gICAgICAgICAgICAgIGRlc2NyaXB0aW9uOiBgJHtudWxsUGVyY2VudGFnZS50b0ZpeGVkKDEpfSUgbWlzc2luZyB2YWx1ZXMgaW4gJHtjb2wuaGVhZGVyfWAsXHJcbiAgICAgICAgICAgICAgYWZmZWN0ZWRDZWxsczogW2Ake2NvbExldHRlcn0yOiR7Y29sTGV0dGVyfSR7c2hlZXQucm93Q291bnR9YF0sXHJcbiAgICAgICAgICAgICAgc3VnZ2VzdGVkRml4OiAnQWRkIGRhdGEgdmFsaWRhdGlvbiBvciBpbXBsZW1lbnQgZGVmYXVsdCB2YWx1ZXMgZm9yIHJlcXVpcmVkIGZpZWxkcycsXHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG4gICAgICAgICAgLy8gQ2hlY2sgZm9yIGluY29uc2lzdGVudCBkYXRhIHR5cGVzXHJcbiAgICAgICAgY29uc3QgdGV4dENvbHVtbnMgPSBzaGVldC5kYXRhVHlwZXMuZmlsdGVyKChjb2w6IGFueSkgPT4gY29sLmRhdGFUeXBlID09PSAndGV4dCcpO1xyXG4gICAgICAgIHRleHRDb2x1bW5zLmZvckVhY2goKGNvbDogYW55KSA9PiB7XHJcbiAgICAgICAgICBjb25zdCBjb2xMZXR0ZXIgPSBjb2wuY29sdW1uTGV0dGVyIHx8IFhMU1gudXRpbHMuZW5jb2RlX2NvbChjb2wuY29sdW1uSW5kZXggfHwgMCk7XHJcbiAgICAgICAgICBcclxuICAgICAgICAgIGlmIChjb2wudW5pcXVlQ291bnQgPT09IDEgJiYgY29sLnNhbXBsZVZhbHVlcy5sZW5ndGggPiAwKSB7XHJcbiAgICAgICAgICAgIGlzc3Vlcy5wdXNoKHtcclxuICAgICAgICAgICAgICBpZDogYGRxX3VuaWZvcm1fJHtzaGVldEluZGV4fV8ke2NvbC5jb2x1bW5JbmRleH1gLFxyXG4gICAgICAgICAgICAgIHR5cGU6ICdpbmNvbnNpc3RlbnRfZm9ybWF0JyxcclxuICAgICAgICAgICAgICBzZXZlcml0eTogJ2xvdycsXHJcbiAgICAgICAgICAgICAgc2hlZXQ6IHNoZWV0Lm5hbWUsXHJcbiAgICAgICAgICAgICAgY29sdW1uOiBjb2wuaGVhZGVyLFxyXG4gICAgICAgICAgICAgIGRlc2NyaXB0aW9uOiBgJHtjb2wuaGVhZGVyfSBjb250YWlucyBvbmx5IG9uZSB1bmlxdWUgdmFsdWU6IFwiJHtjb2wuc2FtcGxlVmFsdWVzWzBdfVwiYCxcclxuICAgICAgICAgICAgICBhZmZlY3RlZENlbGxzOiBbYCR7Y29sTGV0dGVyfTI6JHtjb2xMZXR0ZXJ9JHtzaGVldC5yb3dDb3VudH1gXSxcclxuICAgICAgICAgICAgICBzdWdnZXN0ZWRGaXg6ICdWZXJpZnkgaWYgdGhpcyBjb2x1bW4gcHJvdmlkZXMgbWVhbmluZ2Z1bCBkYXRhIHZhcmlhdGlvbicsXHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG4gICAgICB9XHJcbiAgICAgIFxyXG4gICAgICAvLyBDaGVjayBmb3IgY29tcGxleCBmb3JtdWxhcyB0aGF0IG1pZ2h0IGJlIGVycm9yLXByb25lXHJcbiAgICAgIGlmIChzaGVldC5mb3JtdWxhQ2VsbHMgJiYgc2hlZXQuZm9ybXVsYUNlbGxzLmxlbmd0aCA+IDUpIHtcclxuICAgICAgICBjb25zdCBjb21wbGV4Rm9ybXVsYXMgPSBzaGVldC5mb3JtdWxhQ2VsbHMuZmlsdGVyKChmb3JtdWxhOiBhbnkpID0+IFxyXG4gICAgICAgICAgZm9ybXVsYS5mb3JtdWxhICYmIChcclxuICAgICAgICAgICAgZm9ybXVsYS5mb3JtdWxhLmluY2x1ZGVzKCdWTE9PS1VQJykgfHwgXHJcbiAgICAgICAgICAgIChmb3JtdWxhLmZvcm11bGEuaW5jbHVkZXMoJ0lOREVYJykgJiYgZm9ybXVsYS5mb3JtdWxhLmluY2x1ZGVzKCdNQVRDSCcpKVxyXG4gICAgICAgICAgKVxyXG4gICAgICAgICk7XHJcbiAgICAgICAgICBpZiAoY29tcGxleEZvcm11bGFzLmxlbmd0aCA+IDMpIHtcclxuICAgICAgICAgIGlzc3Vlcy5wdXNoKHtcclxuICAgICAgICAgICAgaWQ6IGBkcV9jb21wbGV4XyR7c2hlZXRJbmRleH1gLFxyXG4gICAgICAgICAgICB0eXBlOiAnaW52YWxpZF9kYXRhJyxcclxuICAgICAgICAgICAgc2V2ZXJpdHk6ICdtZWRpdW0nLFxyXG4gICAgICAgICAgICBzaGVldDogc2hlZXQubmFtZSxcclxuICAgICAgICAgICAgY29sdW1uOiAnVmFyaW91cycsXHJcbiAgICAgICAgICAgIGRlc2NyaXB0aW9uOiBgJHtjb21wbGV4Rm9ybXVsYXMubGVuZ3RofSBjb21wbGV4IGxvb2t1cCBmb3JtdWxhcyBkZXRlY3RlZGAsXHJcbiAgICAgICAgICAgIGFmZmVjdGVkQ2VsbHM6IGNvbXBsZXhGb3JtdWxhcy5tYXAoKGY6IGFueSkgPT4gZi5hZGRyZXNzKSxcclxuICAgICAgICAgICAgc3VnZ2VzdGVkRml4OiAnQ29uc2lkZXIgcmVwbGFjaW5nIHdpdGggWExPT0tVUCBvciBQb3dlclF1ZXJ5IGZvciBiZXR0ZXIgbWFpbnRhaW5hYmlsaXR5JyxcclxuICAgICAgICAgIH0pO1xyXG4gICAgICAgIH1cclxuICAgICAgfVxyXG4gICAgfSk7XHJcbiAgfVxyXG4gIFxyXG4gIC8vIEFkZCBzb21lIGRlZmF1bHQgaXNzdWVzIGlmIG5vIHJlYWwgaXNzdWVzIGZvdW5kIChmb3IgZGVtbyBwdXJwb3NlcylcclxuICBpZiAoaXNzdWVzLmxlbmd0aCA9PT0gMCkge1xyXG4gICAgaXNzdWVzLnB1c2goe1xyXG4gICAgICBpZDogJ2RxX2RlbW9fMScsXHJcbiAgICAgIHR5cGU6ICdtaXNzaW5nX2RhdGEnLFxyXG4gICAgICBzZXZlcml0eTogJ21lZGl1bScsXHJcbiAgICAgIHNoZWV0OiAnRGF0YScsXHJcbiAgICAgIGNvbHVtbjogJ0ltcG9ydGFudCBGaWVsZCcsXHJcbiAgICAgIGRlc2NyaXB0aW9uOiAnU29tZSByZXF1aXJlZCBmaWVsZHMgY29udGFpbiBlbXB0eSB2YWx1ZXMnLFxyXG4gICAgICBhZmZlY3RlZENlbGxzOiBbJ0IxNScsICdCMjMnLCAnQjQxJ10sXHJcbiAgICAgIHN1Z2dlc3RlZEZpeDogJ1VzZSBkYXRhIHZhbGlkYXRpb24gdG8gcmVxdWlyZSBmaWVsZCBlbnRyeSBvciBpbXBsZW1lbnQgZGVmYXVsdCB2YWx1ZXMnLFxyXG4gICAgfSk7XHJcbiAgICBcclxuICAgIGlzc3Vlcy5wdXNoKHtcclxuICAgICAgaWQ6ICdkcV9kZW1vXzInLFxyXG4gICAgICB0eXBlOiAnaW5jb25zaXN0ZW50X2Zvcm1hdCcsXHJcbiAgICAgIHNldmVyaXR5OiAnbG93JyxcclxuICAgICAgc2hlZXQ6ICdEYXRhJyxcclxuICAgICAgY29sdW1uOiAnRGF0ZSBGaWVsZCcsXHJcbiAgICAgIGRlc2NyaXB0aW9uOiAnSW5jb25zaXN0ZW50IGRhdGUgZm9ybWF0dGluZyBkZXRlY3RlZCcsXHJcbiAgICAgIGFmZmVjdGVkQ2VsbHM6IFsnQTUnLCAnQTEyJywgJ0ExOCddLFxyXG4gICAgICBzdWdnZXN0ZWRGaXg6ICdTdGFuZGFyZGl6ZSBkYXRlIGZvcm1hdCB1c2luZyBGb3JtYXQgQ2VsbHMgZGlhbG9nJyxcclxuICAgIH0pO1xyXG4gIH1cclxuICBcclxuICByZXR1cm4gaXNzdWVzLnNsaWNlKDAsIDgpOyAvLyBMaW1pdCB0byByZWFzb25hYmxlIG51bWJlclxyXG59XHJcbiJdLCJuYW1lcyI6WyJYTFNYIiwiaGFuZGxlciIsInJlcSIsInJlcyIsIm1ldGhvZCIsInN0YXR1cyIsImpzb24iLCJlcnJvciIsIndvcmtib29rSWQiLCJ3b3JrYm9vayIsImJvZHkiLCJQcm9taXNlIiwicmVzb2x2ZSIsInNldFRpbWVvdXQiLCJhbmFseXNpcyIsImdlbmVyYXRlRHluYW1pY0FuYWx5c2lzIiwiY29uc29sZSIsImxvZyIsIm5hbWUiLCJ0b3RhbFNoZWV0cyIsInRvdGFsUm93cyIsInRvdGFsQ29sdW1ucyIsInRvdGFsRm9ybXVsYXMiLCJjb21wbGV4aXR5U2NvcmUiLCJhdXRvbWF0aW9uUG90ZW50aWFsIiwiZGF0YVR5cGVzRGlzdHJpYnV0aW9uIiwic2hlZXRzIiwiQXJyYXkiLCJpc0FycmF5IiwibGVuZ3RoIiwicmVkdWNlIiwic3VtIiwic2hlZXQiLCJyb3dDb3VudCIsIk1hdGgiLCJtYXgiLCJtYXAiLCJjb2x1bW5Db3VudCIsImZvcm11bGFDZWxscyIsImFsbERhdGFUeXBlcyIsInRleHQiLCJudW1iZXIiLCJkYXRlIiwiZm9yRWFjaCIsImRhdGFUeXBlcyIsImNvbCIsImRhdGFUeXBlIiwiZm9ybXVsYURlbnNpdHkiLCJzaGVldENvbXBsZXhpdHkiLCJkYXRhVm9sdW1lQ29tcGxleGl0eSIsIm1pbiIsImxvZzEwIiwicm91bmQiLCJoYXNDb21wbGV4Rm9ybXVsYXMiLCJzb21lIiwiZm9ybXVsYSIsImluY2x1ZGVzIiwiaGFzTXVsdGlwbGVTaGVldHMiLCJoYXNMYXJnZURhdGFzZXQiLCJzdW1tYXJ5IiwicmVjb21tZW5kYXRpb25zIiwiZ2VuZXJhdGVSZWNvbW1lbmRhdGlvbnMiLCJzdWdnZXN0ZWRGb3JtdWxhcyIsImdlbmVyYXRlU3VnZ2VzdGVkRm9ybXVsYXMiLCJzdWdnZXN0ZWRQb3dlclF1ZXJpZXMiLCJnZW5lcmF0ZVBvd2VyUXVlcnlUZW1wbGF0ZXMiLCJkYXRhUXVhbGl0eUlzc3VlcyIsImdlbmVyYXRlRGF0YVF1YWxpdHlJc3N1ZXMiLCJmb3JtdWxhcyIsImF1dG9tYXRpb24iLCJoYXNNdWx0aXBsZURhdGFTb3VyY2VzIiwicHVzaCIsImlkIiwidHlwZSIsInByaW9yaXR5IiwidGl0bGUiLCJkZXNjcmlwdGlvbiIsImltcGxlbWVudGF0aW9uIiwiaW1wYWN0IiwiZWZmb3J0IiwiZGVmYXVsdEZvcm11bGFzIiwiY2VsbEFkZHJlc3MiLCJjYXRlZ29yeSIsImNvbXBsZXhpdHkiLCJkZXBlbmRlbmNpZXMiLCJleHBsYW5hdGlvbiIsInNoZWV0SW5kZXgiLCJoZWFkZXJzIiwibnVtYmVyQ29sdW1ucyIsImZpbHRlciIsImRhdGVDb2x1bW5zIiwidGV4dENvbHVtbnMiLCJmaXJzdE51bWJlckNvbCIsImNvbExldHRlciIsImNvbHVtbkxldHRlciIsInV0aWxzIiwiZW5jb2RlX2NvbCIsImNvbHVtbkluZGV4IiwiaGVhZGVyIiwiZmlyc3REYXRlQ29sIiwibmV4dENvbExldHRlciIsImZpcnN0Q29sIiwic2Vjb25kQ29sIiwiZmlyc3RDb2xMZXR0ZXIiLCJzZWNvbmRDb2xMZXR0ZXIiLCJyZXN1bHRDb2xMZXR0ZXIiLCJoYXNEYXRlQ29sdW1ucyIsImR0Iiwic2xpY2UiLCJ0ZW1wbGF0ZXMiLCJzdGVwcyIsIm9wZXJhdGlvbiIsIm1Db2RlIiwiaXNBcHBsaWVkIiwicmVxdWlyZWRDb2x1bW5zIiwib3V0cHV0Q29sdW1ucyIsImhhc051bWVyaWNEYXRhIiwiaXNzdWVzIiwibnVsbFBlcmNlbnRhZ2UiLCJudWxsQ291bnQiLCJzZXZlcml0eSIsImNvbHVtbiIsInRvRml4ZWQiLCJhZmZlY3RlZENlbGxzIiwic3VnZ2VzdGVkRml4IiwidW5pcXVlQ291bnQiLCJzYW1wbGVWYWx1ZXMiLCJjb21wbGV4Rm9ybXVsYXMiLCJmIiwiYWRkcmVzcyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(api)/./pages/api/excel/analyze.ts\n");

/***/ })

};
;

// load runtime
var __webpack_require__ = require("../../../webpack-api-runtime.js");
__webpack_require__.C(exports);
var __webpack_exec__ = (moduleId) => (__webpack_require__(__webpack_require__.s = moduleId))
var __webpack_exports__ = __webpack_require__.X(0, ["vendor-chunks/next"], () => (__webpack_exec__("(api)/./node_modules/next/dist/build/webpack/loaders/next-route-loader/index.js?kind=PAGES_API&page=%2Fapi%2Fexcel%2Fanalyze&preferredRegion=&absolutePagePath=.%2Fpages%5Capi%5Cexcel%5Canalyze.ts&middlewareConfigBase64=e30%3D!")));
module.exports = __webpack_exports__;

})();