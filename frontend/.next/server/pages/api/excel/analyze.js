"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(() => {
var exports = {};
exports.id = "pages/api/excel/analyze";
exports.ids = ["pages/api/excel/analyze"];
exports.modules = {

/***/ "next/dist/compiled/next-server/pages-api.runtime.dev.js":
/*!**************************************************************************!*\
  !*** external "next/dist/compiled/next-server/pages-api.runtime.dev.js" ***!
  \**************************************************************************/
/***/ ((module) => {

module.exports = require("next/dist/compiled/next-server/pages-api.runtime.dev.js");

/***/ }),

/***/ "xlsx":
/*!***********************!*\
  !*** external "xlsx" ***!
  \***********************/
/***/ ((module) => {

module.exports = require("xlsx");

/***/ }),

/***/ "(api)/./node_modules/next/dist/build/webpack/loaders/next-route-loader/index.js?kind=PAGES_API&page=%2Fapi%2Fexcel%2Fanalyze&preferredRegion=&absolutePagePath=.%2Fpages%5Capi%5Cexcel%5Canalyze.ts&middlewareConfigBase64=e30%3D!":
/*!************************************************************************************************************************************************************************************************************************************!*\
  !*** ./node_modules/next/dist/build/webpack/loaders/next-route-loader/index.js?kind=PAGES_API&page=%2Fapi%2Fexcel%2Fanalyze&preferredRegion=&absolutePagePath=.%2Fpages%5Capi%5Cexcel%5Canalyze.ts&middlewareConfigBase64=e30%3D! ***!
  \************************************************************************************************************************************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   config: () => (/* binding */ config),\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__),\n/* harmony export */   routeModule: () => (/* binding */ routeModule)\n/* harmony export */ });\n/* harmony import */ var next_dist_server_future_route_modules_pages_api_module_compiled__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! next/dist/server/future/route-modules/pages-api/module.compiled */ \"(api)/./node_modules/next/dist/server/future/route-modules/pages-api/module.compiled.js\");\n/* harmony import */ var next_dist_server_future_route_modules_pages_api_module_compiled__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(next_dist_server_future_route_modules_pages_api_module_compiled__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var next_dist_server_future_route_kind__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! next/dist/server/future/route-kind */ \"(api)/./node_modules/next/dist/server/future/route-kind.js\");\n/* harmony import */ var next_dist_build_templates_helpers__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! next/dist/build/templates/helpers */ \"(api)/./node_modules/next/dist/build/templates/helpers.js\");\n/* harmony import */ var _pages_api_excel_analyze_ts__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./pages\\api\\excel\\analyze.ts */ \"(api)/./pages/api/excel/analyze.ts\");\n\n\n\n// Import the userland code.\n\n// Re-export the handler (should be the default export).\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = ((0,next_dist_build_templates_helpers__WEBPACK_IMPORTED_MODULE_2__.hoist)(_pages_api_excel_analyze_ts__WEBPACK_IMPORTED_MODULE_3__, \"default\"));\n// Re-export config.\nconst config = (0,next_dist_build_templates_helpers__WEBPACK_IMPORTED_MODULE_2__.hoist)(_pages_api_excel_analyze_ts__WEBPACK_IMPORTED_MODULE_3__, \"config\");\n// Create and export the route module that will be consumed.\nconst routeModule = new next_dist_server_future_route_modules_pages_api_module_compiled__WEBPACK_IMPORTED_MODULE_0__.PagesAPIRouteModule({\n    definition: {\n        kind: next_dist_server_future_route_kind__WEBPACK_IMPORTED_MODULE_1__.RouteKind.PAGES_API,\n        page: \"/api/excel/analyze\",\n        pathname: \"/api/excel/analyze\",\n        // The following aren't used in production.\n        bundlePath: \"\",\n        filename: \"\"\n    },\n    userland: _pages_api_excel_analyze_ts__WEBPACK_IMPORTED_MODULE_3__\n});\n\n//# sourceMappingURL=pages-api.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwaSkvLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2J1aWxkL3dlYnBhY2svbG9hZGVycy9uZXh0LXJvdXRlLWxvYWRlci9pbmRleC5qcz9raW5kPVBBR0VTX0FQSSZwYWdlPSUyRmFwaSUyRmV4Y2VsJTJGYW5hbHl6ZSZwcmVmZXJyZWRSZWdpb249JmFic29sdXRlUGFnZVBhdGg9LiUyRnBhZ2VzJTVDYXBpJTVDZXhjZWwlNUNhbmFseXplLnRzJm1pZGRsZXdhcmVDb25maWdCYXNlNjQ9ZTMwJTNEISIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7OztBQUFzRztBQUN2QztBQUNMO0FBQzFEO0FBQzREO0FBQzVEO0FBQ0EsaUVBQWUsd0VBQUssQ0FBQyx3REFBUSxZQUFZLEVBQUM7QUFDMUM7QUFDTyxlQUFlLHdFQUFLLENBQUMsd0RBQVE7QUFDcEM7QUFDTyx3QkFBd0IsZ0hBQW1CO0FBQ2xEO0FBQ0EsY0FBYyx5RUFBUztBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLFlBQVk7QUFDWixDQUFDOztBQUVEIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vZnJvbnRlbmQvPzZmYjIiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgUGFnZXNBUElSb3V0ZU1vZHVsZSB9IGZyb20gXCJuZXh0L2Rpc3Qvc2VydmVyL2Z1dHVyZS9yb3V0ZS1tb2R1bGVzL3BhZ2VzLWFwaS9tb2R1bGUuY29tcGlsZWRcIjtcbmltcG9ydCB7IFJvdXRlS2luZCB9IGZyb20gXCJuZXh0L2Rpc3Qvc2VydmVyL2Z1dHVyZS9yb3V0ZS1raW5kXCI7XG5pbXBvcnQgeyBob2lzdCB9IGZyb20gXCJuZXh0L2Rpc3QvYnVpbGQvdGVtcGxhdGVzL2hlbHBlcnNcIjtcbi8vIEltcG9ydCB0aGUgdXNlcmxhbmQgY29kZS5cbmltcG9ydCAqIGFzIHVzZXJsYW5kIGZyb20gXCIuL3BhZ2VzXFxcXGFwaVxcXFxleGNlbFxcXFxhbmFseXplLnRzXCI7XG4vLyBSZS1leHBvcnQgdGhlIGhhbmRsZXIgKHNob3VsZCBiZSB0aGUgZGVmYXVsdCBleHBvcnQpLlxuZXhwb3J0IGRlZmF1bHQgaG9pc3QodXNlcmxhbmQsIFwiZGVmYXVsdFwiKTtcbi8vIFJlLWV4cG9ydCBjb25maWcuXG5leHBvcnQgY29uc3QgY29uZmlnID0gaG9pc3QodXNlcmxhbmQsIFwiY29uZmlnXCIpO1xuLy8gQ3JlYXRlIGFuZCBleHBvcnQgdGhlIHJvdXRlIG1vZHVsZSB0aGF0IHdpbGwgYmUgY29uc3VtZWQuXG5leHBvcnQgY29uc3Qgcm91dGVNb2R1bGUgPSBuZXcgUGFnZXNBUElSb3V0ZU1vZHVsZSh7XG4gICAgZGVmaW5pdGlvbjoge1xuICAgICAgICBraW5kOiBSb3V0ZUtpbmQuUEFHRVNfQVBJLFxuICAgICAgICBwYWdlOiBcIi9hcGkvZXhjZWwvYW5hbHl6ZVwiLFxuICAgICAgICBwYXRobmFtZTogXCIvYXBpL2V4Y2VsL2FuYWx5emVcIixcbiAgICAgICAgLy8gVGhlIGZvbGxvd2luZyBhcmVuJ3QgdXNlZCBpbiBwcm9kdWN0aW9uLlxuICAgICAgICBidW5kbGVQYXRoOiBcIlwiLFxuICAgICAgICBmaWxlbmFtZTogXCJcIlxuICAgIH0sXG4gICAgdXNlcmxhbmRcbn0pO1xuXG4vLyMgc291cmNlTWFwcGluZ1VSTD1wYWdlcy1hcGkuanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(api)/./node_modules/next/dist/build/webpack/loaders/next-route-loader/index.js?kind=PAGES_API&page=%2Fapi%2Fexcel%2Fanalyze&preferredRegion=&absolutePagePath=.%2Fpages%5Capi%5Cexcel%5Canalyze.ts&middlewareConfigBase64=e30%3D!\n");

/***/ }),

/***/ "(api)/./pages/api/excel/analyze.ts":
/*!************************************!*\
  !*** ./pages/api/excel/analyze.ts ***!
  \************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ handler)\n/* harmony export */ });\n/* harmony import */ var xlsx__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! xlsx */ \"xlsx\");\n/* harmony import */ var xlsx__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(xlsx__WEBPACK_IMPORTED_MODULE_0__);\n\n// Enhanced analysis with more realistic data generation\nasync function handler(req, res) {\n    if (req.method !== \"POST\") {\n        return res.status(405).json({\n            error: \"Method not allowed\"\n        });\n    }\n    try {\n        const { workbookId, workbook } = req.body;\n        if (!workbookId) {\n            return res.status(400).json({\n                error: \"Workbook ID is required\"\n            });\n        }\n        // Simulate analysis processing time\n        await new Promise((resolve)=>setTimeout(resolve, 1500));\n        // Generate dynamic analysis based on workbook if provided\n        const analysis = generateDynamicAnalysis(workbook);\n        res.status(200).json(analysis);\n    } catch (error) {\n        console.error(\"Error analyzing workbook:\", error);\n        res.status(500).json({\n            error: \"Failed to analyze workbook\"\n        });\n    }\n}\nfunction generateDynamicAnalysis(workbook) {\n    console.log(\"Generating dynamic analysis for workbook:\", workbook?.name);\n    // Default values for when no workbook is provided\n    let totalSheets = 3;\n    let totalRows = 1250;\n    let totalColumns = 12;\n    let totalFormulas = 45;\n    let complexityScore = 72;\n    let automationPotential = \"high\";\n    let dataTypesDistribution = {\n        \"text\": 6,\n        \"number\": 4,\n        \"date\": 2\n    };\n    // If workbook data is provided, analyze it for real insights\n    if (workbook && workbook.sheets && Array.isArray(workbook.sheets)) {\n        console.log(\"Analyzing real workbook data...\");\n        totalSheets = workbook.sheets.length;\n        totalRows = workbook.sheets.reduce((sum, sheet)=>sum + (sheet.rowCount || 0), 0);\n        totalColumns = Math.max(...workbook.sheets.map((sheet)=>sheet.columnCount || 0), 1);\n        totalFormulas = workbook.sheets.reduce((sum, sheet)=>sum + (sheet.formulaCells?.length || 0), 0);\n        // Analyze data types across all sheets\n        const allDataTypes = {\n            text: 0,\n            number: 0,\n            date: 0\n        };\n        workbook.sheets.forEach((sheet)=>{\n            if (sheet.dataTypes && Array.isArray(sheet.dataTypes)) {\n                sheet.dataTypes.forEach((col)=>{\n                    if (col.dataType === \"text\") {\n                        allDataTypes.text += 1;\n                    } else if (col.dataType === \"number\") {\n                        allDataTypes.number += 1;\n                    } else if (col.dataType === \"date\") {\n                        allDataTypes.date += 1;\n                    }\n                });\n            }\n        });\n        dataTypesDistribution = allDataTypes;\n        // Calculate complexity score based on actual data\n        const formulaDensity = totalRows > 0 ? totalFormulas / totalRows * 100 : 0;\n        const sheetComplexity = totalSheets * 10;\n        const dataVolumeComplexity = Math.min(30, Math.log10(totalRows + 1) * 10);\n        complexityScore = Math.min(100, Math.round(formulaDensity + sheetComplexity + dataVolumeComplexity));\n        // Determine automation potential based on real metrics\n        const hasComplexFormulas = workbook.sheets.some((sheet)=>sheet.formulaCells?.some((formula)=>formula.formula?.includes(\"VLOOKUP\") || formula.formula?.includes(\"INDEX\") || formula.formula?.includes(\"MATCH\") || formula.formula?.includes(\"SUMIFS\") || formula.formula?.includes(\"COUNTIFS\")));\n        const hasMultipleSheets = totalSheets > 1;\n        const hasLargeDataset = totalRows > 100;\n        if (hasComplexFormulas && hasMultipleSheets || totalFormulas > 20) {\n            automationPotential = \"high\";\n        } else if (hasComplexFormulas || hasMultipleSheets || totalFormulas > 5) {\n            automationPotential = \"medium\";\n        } else {\n            automationPotential = \"low\";\n        }\n        console.log(\"Analysis metrics:\", {\n            totalSheets,\n            totalRows,\n            totalColumns,\n            totalFormulas,\n            complexityScore,\n            automationPotential,\n            dataTypesDistribution\n        });\n    }\n    return {\n        summary: {\n            totalSheets,\n            totalRows,\n            totalColumns,\n            totalFormulas,\n            dataTypes: dataTypesDistribution,\n            complexityScore,\n            automationPotential\n        },\n        recommendations: generateRecommendations(totalFormulas, totalSheets, automationPotential, workbook),\n        suggestedFormulas: generateSuggestedFormulas(workbook),\n        suggestedPowerQueries: generatePowerQueryTemplates(workbook),\n        dataQualityIssues: generateDataQualityIssues(workbook)\n    };\n}\nfunction generateRecommendations(formulas, sheets, automation, workbook) {\n    const recommendations = [];\n    // Analyze actual workbook data if available\n    const hasComplexFormulas = workbook?.sheets?.some((sheet)=>sheet.formulaCells?.some((formula)=>formula.formula?.includes(\"VLOOKUP\") || formula.formula?.includes(\"INDEX\") || formula.formula?.includes(\"SUMIFS\")));\n    const hasMultipleDataSources = sheets > 1;\n    const hasLargeDataset = workbook?.sheets?.some((sheet)=>sheet.rowCount > 100);\n    if (formulas > 10 || hasComplexFormulas) {\n        recommendations.push({\n            id: \"rec_1\",\n            type: \"powerquery\",\n            priority: \"high\",\n            title: \"Automate Data Processing with PowerQuery\",\n            description: `${hasComplexFormulas ? \"Complex lookup formulas\" : `${formulas} formulas`} detected. PowerQuery can automate these transformations`,\n            implementation: \"Use Data → Get Data → From Other Sources → Blank Query to create automated data pipelines\",\n            impact: `Reduce manual formula maintenance by ${hasComplexFormulas ? \"80%\" : \"70%\"}`,\n            effort: hasComplexFormulas ? \"high\" : \"medium\"\n        });\n    }\n    if (hasMultipleDataSources) {\n        recommendations.push({\n            id: \"rec_2\",\n            type: \"formula\",\n            priority: \"medium\",\n            title: \"Consolidate Sheet References\",\n            description: `Multiple sheets detected (${sheets}). Use dynamic references to improve maintainability`,\n            implementation: \"Replace hard-coded sheet references with INDIRECT or structured references\",\n            impact: \"Improve workbook flexibility and reduce errors\",\n            effort: \"low\"\n        });\n    }\n    recommendations.push({\n        id: \"rec_3\",\n        type: \"data_validation\",\n        priority: automation === \"high\" ? \"high\" : \"medium\",\n        title: \"Implement Data Validation\",\n        description: \"Add validation rules to prevent data entry errors and improve data quality\",\n        implementation: \"Use Data → Data Validation for critical input fields\",\n        impact: \"Reduce data quality issues by 90%\",\n        effort: \"low\"\n    });\n    return recommendations;\n}\nfunction generateSuggestedFormulas(workbook) {\n    const formulas = [];\n    // Default formulas\n    const defaultFormulas = [\n        {\n            formula: '=XLOOKUP(A2,Products[Product_ID],Products[Price],\"\")',\n            description: \"Dynamic price lookup with error handling\",\n            cellAddress: \"D2\",\n            category: \"lookup\",\n            complexity: \"intermediate\",\n            dependencies: [\n                \"A2\",\n                \"Products[Product_ID]\",\n                \"Products[Price]\"\n            ],\n            explanation: \"This formula looks up prices dynamically and returns an empty string if not found.\"\n        },\n        {\n            formula: '=SUMIFS(Sales[Amount],Sales[Date],\">=\"&TODAY()-30)',\n            description: \"Sum sales from last 30 days\",\n            cellAddress: \"G2\",\n            category: \"math\",\n            complexity: \"intermediate\",\n            dependencies: [\n                \"Sales[Amount]\",\n                \"Sales[Date]\"\n            ],\n            explanation: \"Calculates total sales for the last 30 days using dynamic date criteria.\"\n        }\n    ];\n    // Add workbook-specific formulas if data is available\n    if (workbook && workbook.sheets) {\n        workbook.sheets.forEach((sheet, sheetIndex)=>{\n            if (sheet.headers && sheet.dataTypes) {\n                // Generate formulas based on detected data types\n                const numberColumns = sheet.dataTypes.filter((col)=>col.dataType === \"number\");\n                const dateColumns = sheet.dataTypes.filter((col)=>col.dataType === \"date\");\n                const textColumns = sheet.dataTypes.filter((col)=>col.dataType === \"text\");\n                // If we have number columns, suggest SUM formulas\n                if (numberColumns.length > 0) {\n                    const firstNumberCol = numberColumns[0];\n                    const colLetter = firstNumberCol.columnLetter || xlsx__WEBPACK_IMPORTED_MODULE_0__.utils.encode_col(firstNumberCol.columnIndex || 0);\n                    formulas.push({\n                        formula: `=SUM(${colLetter}2:${colLetter}1000)`,\n                        description: `Sum all values in ${firstNumberCol.header} column`,\n                        cellAddress: `${colLetter}${sheet.rowCount + 2}`,\n                        category: \"math\",\n                        complexity: \"basic\",\n                        dependencies: [\n                            `${colLetter}2:${colLetter}1000`\n                        ],\n                        explanation: `Calculates the total of all numeric values in the ${firstNumberCol.header} column.`\n                    });\n                    formulas.push({\n                        formula: `=AVERAGE(${colLetter}2:${colLetter}1000)`,\n                        description: `Average of ${firstNumberCol.header} column`,\n                        cellAddress: `${colLetter}${sheet.rowCount + 3}`,\n                        category: \"math\",\n                        complexity: \"basic\",\n                        dependencies: [\n                            `${colLetter}2:${colLetter}1000`\n                        ],\n                        explanation: `Calculates the average of all numeric values in the ${firstNumberCol.header} column.`\n                    });\n                }\n                // If we have date columns, suggest date-related formulas\n                if (dateColumns.length > 0) {\n                    const firstDateCol = dateColumns[0];\n                    const colLetter = firstDateCol.columnLetter || xlsx__WEBPACK_IMPORTED_MODULE_0__.utils.encode_col(firstDateCol.columnIndex || 0);\n                    const nextColLetter = xlsx__WEBPACK_IMPORTED_MODULE_0__.utils.encode_col((firstDateCol.columnIndex || 0) + 1);\n                    formulas.push({\n                        formula: `=COUNTIFS(${colLetter}:${colLetter},\">=\"&TODAY()-30)`,\n                        description: `Count recent entries in ${firstDateCol.header}`,\n                        cellAddress: `${nextColLetter}${sheet.rowCount + 2}`,\n                        category: \"date\",\n                        complexity: \"intermediate\",\n                        dependencies: [\n                            `${colLetter}:${colLetter}`\n                        ],\n                        explanation: `Counts how many entries in ${firstDateCol.header} are from the last 30 days.`\n                    });\n                }\n                // If we have multiple columns, suggest lookup formulas\n                if (sheet.headers.length > 2) {\n                    const firstCol = sheet.dataTypes[0];\n                    const secondCol = sheet.dataTypes[1];\n                    if (firstCol && secondCol) {\n                        const firstColLetter = firstCol.columnLetter || xlsx__WEBPACK_IMPORTED_MODULE_0__.utils.encode_col(firstCol.columnIndex || 0);\n                        const secondColLetter = secondCol.columnLetter || xlsx__WEBPACK_IMPORTED_MODULE_0__.utils.encode_col(secondCol.columnIndex || 1);\n                        const resultColLetter = xlsx__WEBPACK_IMPORTED_MODULE_0__.utils.encode_col((secondCol.columnIndex || 1) + 2);\n                        formulas.push({\n                            formula: `=XLOOKUP(A2,${firstColLetter}:${firstColLetter},${secondColLetter}:${secondColLetter},\"Not Found\")`,\n                            description: `Lookup ${secondCol.header} based on ${firstCol.header}`,\n                            cellAddress: `${resultColLetter}2`,\n                            category: \"lookup\",\n                            complexity: \"intermediate\",\n                            dependencies: [\n                                `A2`,\n                                `${firstColLetter}:${firstColLetter}`,\n                                `${secondColLetter}:${secondColLetter}`\n                            ],\n                            explanation: `Finds the corresponding ${secondCol.header} value for each ${firstCol.header} entry.`\n                        });\n                    }\n                }\n            }\n        });\n    }\n    // Add default formulas with workbook-specific ones\n    if (workbook && workbook.sheets) {\n        const hasDateColumns = workbook.sheets.some((sheet)=>sheet.dataTypes?.some((dt)=>dt.dataType === \"date\"));\n        if (hasDateColumns) {\n            formulas.push({\n                formula: \"=FILTER(Data[Product],(Data[Date]>=EOMONTH(TODAY(),-1)+1)*(Data[Date]<=EOMONTH(TODAY(),0)))\",\n                description: \"Filter current month data\",\n                cellAddress: \"A10\",\n                category: \"lookup\",\n                complexity: \"advanced\",\n                dependencies: [\n                    \"Data[Product]\",\n                    \"Data[Date]\"\n                ],\n                explanation: \"Returns all records from the current month using dynamic array formulas.\"\n            });\n        }\n    }\n    // Combine default and generated formulas, limiting to reasonable amount\n    return [\n        ...defaultFormulas,\n        ...formulas\n    ].slice(0, 8);\n}\nfunction generatePowerQueryTemplates(workbook) {\n    const templates = [\n        {\n            id: \"pq_1\",\n            name: \"Data Standardization\",\n            description: \"Clean and standardize data formats across all columns\",\n            category: \"data_cleaning\",\n            steps: [\n                {\n                    id: \"step_1\",\n                    name: \"Promote Headers\",\n                    operation: \"headers\",\n                    mCode: \"Table.PromoteHeaders(Source, [PromoteAllScalars=true])\",\n                    description: \"Promote first row to column headers\",\n                    isApplied: true\n                },\n                {\n                    id: \"step_2\",\n                    name: \"Trim Text\",\n                    operation: \"replace\",\n                    mCode: 'Table.TransformColumns(#\"Promoted Headers\", {}, Text.Trim)',\n                    description: \"Remove leading and trailing spaces\",\n                    isApplied: true\n                },\n                {\n                    id: \"step_3\",\n                    name: \"Detect Data Types\",\n                    operation: \"dataTypes\",\n                    mCode: 'Table.DetectDataTypes(#\"Trimmed Text\")',\n                    description: \"Automatically detect and apply proper data types\",\n                    isApplied: true\n                }\n            ],\n            requiredColumns: [],\n            outputColumns: [],\n            mCode: `let\r\n    Source = Excel.CurrentWorkbook(){[Name=\"Table1\"]}[Content],\r\n    #\"Promoted Headers\" = Table.PromoteHeaders(Source, [PromoteAllScalars=true]),\r\n    #\"Trimmed Text\" = Table.TransformColumns(#\"Promoted Headers\", {}, Text.Trim),\r\n    #\"Detected Types\" = Table.DetectDataTypes(#\"Trimmed Text\")\r\nin\r\n    #\"Detected Types\"`\n        }\n    ];\n    // Add workbook-specific templates\n    if (workbook && workbook.sheets) {\n        const hasNumericData = workbook.sheets.some((sheet)=>sheet.dataTypes?.some((dt)=>dt.dataType === \"number\"));\n        if (hasNumericData) {\n            templates.push({\n                id: \"pq_2\",\n                name: \"Numerical Analysis\",\n                description: \"Group and analyze numerical data with calculations\",\n                category: \"analysis\",\n                steps: [\n                    {\n                        id: \"step_1\",\n                        name: \"Group By Category\",\n                        operation: \"group\",\n                        mCode: 'Table.Group(Source, {\"Category\"}, {{\"Total\", each List.Sum([Amount]), type number}, {\"Count\", each Table.RowCount(_), type number}})',\n                        description: \"Group data and calculate totals\",\n                        isApplied: true\n                    },\n                    {\n                        id: \"step_2\",\n                        name: \"Add Percentage\",\n                        operation: \"add_column\",\n                        mCode: 'Table.AddColumn(#\"Grouped Rows\", \"Percentage\", each [Total] / List.Sum(#\"Grouped Rows\"[Total]) * 100)',\n                        description: \"Calculate percentage of total\",\n                        isApplied: true\n                    }\n                ],\n                requiredColumns: [\n                    \"Category\",\n                    \"Amount\"\n                ],\n                outputColumns: [\n                    \"Category\",\n                    \"Total\",\n                    \"Count\",\n                    \"Percentage\"\n                ],\n                mCode: `let\r\n    Source = Excel.CurrentWorkbook(){[Name=\"Data\"]}[Content],\r\n    #\"Grouped Rows\" = Table.Group(Source, {\"Category\"}, {{\"Total\", each List.Sum([Amount]), type number}, {\"Count\", each Table.RowCount(_), type number}}),\r\n    #\"Added Percentage\" = Table.AddColumn(#\"Grouped Rows\", \"Percentage\", each [Total] / List.Sum(#\"Grouped Rows\"[Total]) * 100)\r\nin\r\n    #\"Added Percentage\"`\n            });\n        }\n    }\n    return templates;\n}\nfunction generateDataQualityIssues(workbook) {\n    const issues = [];\n    if (workbook && workbook.sheets) {\n        workbook.sheets.forEach((sheet, sheetIndex)=>{\n            if (sheet.dataTypes) {\n                sheet.dataTypes.forEach((col)=>{\n                    const nullPercentage = col.nullCount / Math.max(sheet.rowCount - 1, 1) * 100;\n                    const colLetter = col.columnLetter || xlsx__WEBPACK_IMPORTED_MODULE_0__.utils.encode_col(col.columnIndex || 0);\n                    if (nullPercentage > 20) {\n                        issues.push({\n                            id: `dq_null_${sheetIndex}_${col.columnIndex}`,\n                            type: \"missing_data\",\n                            severity: nullPercentage > 50 ? \"high\" : \"medium\",\n                            sheet: sheet.name,\n                            column: col.header,\n                            description: `${nullPercentage.toFixed(1)}% missing values in ${col.header}`,\n                            affectedCells: [\n                                `${colLetter}2:${colLetter}${sheet.rowCount}`\n                            ],\n                            suggestedFix: \"Add data validation or implement default values for required fields\"\n                        });\n                    }\n                });\n                // Check for inconsistent data types\n                const textColumns = sheet.dataTypes.filter((col)=>col.dataType === \"text\");\n                textColumns.forEach((col)=>{\n                    const colLetter = col.columnLetter || xlsx__WEBPACK_IMPORTED_MODULE_0__.utils.encode_col(col.columnIndex || 0);\n                    if (col.uniqueCount === 1 && col.sampleValues.length > 0) {\n                        issues.push({\n                            id: `dq_uniform_${sheetIndex}_${col.columnIndex}`,\n                            type: \"inconsistent_format\",\n                            severity: \"low\",\n                            sheet: sheet.name,\n                            column: col.header,\n                            description: `${col.header} contains only one unique value: \"${col.sampleValues[0]}\"`,\n                            affectedCells: [\n                                `${colLetter}2:${colLetter}${sheet.rowCount}`\n                            ],\n                            suggestedFix: \"Verify if this column provides meaningful data variation\"\n                        });\n                    }\n                });\n            }\n            // Check for complex formulas that might be error-prone\n            if (sheet.formulaCells && sheet.formulaCells.length > 5) {\n                const complexFormulas = sheet.formulaCells.filter((formula)=>formula.formula && (formula.formula.includes(\"VLOOKUP\") || formula.formula.includes(\"INDEX\") && formula.formula.includes(\"MATCH\")));\n                if (complexFormulas.length > 3) {\n                    issues.push({\n                        id: `dq_complex_${sheetIndex}`,\n                        type: \"invalid_data\",\n                        severity: \"medium\",\n                        sheet: sheet.name,\n                        column: \"Various\",\n                        description: `${complexFormulas.length} complex lookup formulas detected`,\n                        affectedCells: complexFormulas.map((f)=>f.address),\n                        suggestedFix: \"Consider replacing with XLOOKUP or PowerQuery for better maintainability\"\n                    });\n                }\n            }\n        });\n    }\n    // Add some default issues if no real issues found (for demo purposes)\n    if (issues.length === 0) {\n        issues.push({\n            id: \"dq_demo_1\",\n            type: \"missing_data\",\n            severity: \"medium\",\n            sheet: \"Data\",\n            column: \"Important Field\",\n            description: \"Some required fields contain empty values\",\n            affectedCells: [\n                \"B15\",\n                \"B23\",\n                \"B41\"\n            ],\n            suggestedFix: \"Use data validation to require field entry or implement default values\"\n        });\n        issues.push({\n            id: \"dq_demo_2\",\n            type: \"inconsistent_format\",\n            severity: \"low\",\n            sheet: \"Data\",\n            column: \"Date Field\",\n            description: \"Inconsistent date formatting detected\",\n            affectedCells: [\n                \"A5\",\n                \"A12\",\n                \"A18\"\n            ],\n            suggestedFix: \"Standardize date format using Format Cells dialog\"\n        });\n    }\n    return issues.slice(0, 8); // Limit to reasonable number\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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QSxDQUFBQSxRQUFRQSxPQUFPLENBQUNDLFFBQVEsQ0FBQyxjQUN4QkQsUUFBUUEsT0FBTyxDQUFDQyxRQUFRLENBQUMsWUFBWUQsUUFBUUEsT0FBTyxDQUFDQyxRQUFRLENBQUMsUUFBUTtnQkFHekUsSUFBSXVFLGdCQUFnQmxHLE1BQU0sR0FBRyxHQUFHO29CQUNoQ3dGLE9BQU85QyxJQUFJLENBQUM7d0JBQ1ZDLElBQUksQ0FBQyxXQUFXLEVBQUVjLFdBQVcsQ0FBQzt3QkFDOUJiLE1BQU07d0JBQ04rQyxVQUFVO3dCQUNWeEYsT0FBT0EsTUFBTWQsSUFBSTt3QkFDakJ1RyxRQUFRO3dCQUNSN0MsYUFBYSxDQUFDLEVBQUVtRCxnQkFBZ0JsRyxNQUFNLENBQUMsaUNBQWlDLENBQUM7d0JBQ3pFOEYsZUFBZUksZ0JBQWdCM0YsR0FBRyxDQUFDLENBQUM0RixJQUFXQSxFQUFFQyxPQUFPO3dCQUN4REwsY0FBYztvQkFDaEI7Z0JBQ0Y7WUFDRjtRQUNGO0lBQ0Y7SUFFQSxzRUFBc0U7SUFDdEUsSUFBSVAsT0FBT3hGLE1BQU0sS0FBSyxHQUFHO1FBQ3ZCd0YsT0FBTzlDLElBQUksQ0FBQztZQUNWQyxJQUFJO1lBQ0pDLE1BQU07WUFDTitDLFVBQVU7WUFDVnhGLE9BQU87WUFDUHlGLFFBQVE7WUFDUjdDLGFBQWE7WUFDYitDLGVBQWU7Z0JBQUM7Z0JBQU87Z0JBQU87YUFBTTtZQUNwQ0MsY0FBYztRQUNoQjtRQUVBUCxPQUFPOUMsSUFBSSxDQUFDO1lBQ1ZDLElBQUk7WUFDSkMsTUFBTTtZQUNOK0MsVUFBVTtZQUNWeEYsT0FBTztZQUNQeUYsUUFBUTtZQUNSN0MsYUFBYTtZQUNiK0MsZUFBZTtnQkFBQztnQkFBTTtnQkFBTzthQUFNO1lBQ25DQyxjQUFjO1FBQ2hCO0lBQ0Y7SUFFQSxPQUFPUCxPQUFPVCxLQUFLLENBQUMsR0FBRyxJQUFJLDZCQUE2QjtBQUMxRCIsInNvdXJjZXMiOlsid2VicGFjazovL2Zyb250ZW5kLy4vcGFnZXMvYXBpL2V4Y2VsL2FuYWx5emUudHM/OTExMyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBOZXh0QXBpUmVxdWVzdCwgTmV4dEFwaVJlc3BvbnNlIH0gZnJvbSAnbmV4dCc7XHJcbmltcG9ydCAqIGFzIFhMU1ggZnJvbSAneGxzeCc7XHJcbmltcG9ydCB7IEV4Y2VsQW5hbHlzaXMsIEFuYWx5c2lzU3VtbWFyeSwgUmVjb21tZW5kYXRpb24sIERhdGFRdWFsaXR5SXNzdWUsIEdlbmVyYXRlZEZvcm11bGEsIFBvd2VyUXVlcnlUZW1wbGF0ZSB9IGZyb20gJy4uLy4uLy4uL3R5cGVzL2V4Y2VsJztcclxuXHJcbi8vIEVuaGFuY2VkIGFuYWx5c2lzIHdpdGggbW9yZSByZWFsaXN0aWMgZGF0YSBnZW5lcmF0aW9uXHJcbmV4cG9ydCBkZWZhdWx0IGFzeW5jIGZ1bmN0aW9uIGhhbmRsZXIocmVxOiBOZXh0QXBpUmVxdWVzdCwgcmVzOiBOZXh0QXBpUmVzcG9uc2UpIHtcclxuICBpZiAocmVxLm1ldGhvZCAhPT0gJ1BPU1QnKSB7XHJcbiAgICByZXR1cm4gcmVzLnN0YXR1cyg0MDUpLmpzb24oeyBlcnJvcjogJ01ldGhvZCBub3QgYWxsb3dlZCcgfSk7XHJcbiAgfVxyXG4gIFxyXG4gIHRyeSB7XHJcbiAgICBjb25zdCB7IHdvcmtib29rSWQsIHdvcmtib29rIH0gPSByZXEuYm9keTtcclxuICAgIFxyXG4gICAgaWYgKCF3b3JrYm9va0lkKSB7XHJcbiAgICAgIHJldHVybiByZXMuc3RhdHVzKDQwMCkuanNvbih7IGVycm9yOiAnV29ya2Jvb2sgSUQgaXMgcmVxdWlyZWQnIH0pO1xyXG4gICAgfVxyXG4gICAgXHJcbiAgICAvLyBTaW11bGF0ZSBhbmFseXNpcyBwcm9jZXNzaW5nIHRpbWVcclxuICAgIGF3YWl0IG5ldyBQcm9taXNlKHJlc29sdmUgPT4gc2V0VGltZW91dChyZXNvbHZlLCAxNTAwKSk7XHJcbiAgICBcclxuICAgIC8vIEdlbmVyYXRlIGR5bmFtaWMgYW5hbHlzaXMgYmFzZWQgb24gd29ya2Jvb2sgaWYgcHJvdmlkZWRcclxuICAgIGNvbnN0IGFuYWx5c2lzOiBQYXJ0aWFsPEV4Y2VsQW5hbHlzaXM+ID0gZ2VuZXJhdGVEeW5hbWljQW5hbHlzaXMod29ya2Jvb2spO1xyXG4gICAgXHJcbiAgICByZXMuc3RhdHVzKDIwMCkuanNvbihhbmFseXNpcyk7XHJcbiAgfSBjYXRjaCAoZXJyb3IpIHtcclxuICAgIGNvbnNvbGUuZXJyb3IoJ0Vycm9yIGFuYWx5emluZyB3b3JrYm9vazonLCBlcnJvcik7XHJcbiAgICByZXMuc3RhdHVzKDUwMCkuanNvbih7IGVycm9yOiAnRmFpbGVkIHRvIGFuYWx5emUgd29ya2Jvb2snIH0pO1xyXG4gIH1cclxufVxyXG5cclxuZnVuY3Rpb24gZ2VuZXJhdGVEeW5hbWljQW5hbHlzaXMod29ya2Jvb2s6IGFueSk6IFBhcnRpYWw8RXhjZWxBbmFseXNpcz4ge1xyXG4gIGNvbnNvbGUubG9nKCdHZW5lcmF0aW5nIGR5bmFtaWMgYW5hbHlzaXMgZm9yIHdvcmtib29rOicsIHdvcmtib29rPy5uYW1lKTtcclxuICBcclxuICAvLyBEZWZhdWx0IHZhbHVlcyBmb3Igd2hlbiBubyB3b3JrYm9vayBpcyBwcm92aWRlZFxyXG4gIGxldCB0b3RhbFNoZWV0cyA9IDM7XHJcbiAgbGV0IHRvdGFsUm93cyA9IDEyNTA7XHJcbiAgbGV0IHRvdGFsQ29sdW1ucyA9IDEyO1xyXG4gIGxldCB0b3RhbEZvcm11bGFzID0gNDU7XHJcbiAgbGV0IGNvbXBsZXhpdHlTY29yZSA9IDcyO1xyXG4gIGxldCBhdXRvbWF0aW9uUG90ZW50aWFsOiAnbG93JyB8ICdtZWRpdW0nIHwgJ2hpZ2gnID0gJ2hpZ2gnO1xyXG4gIGxldCBkYXRhVHlwZXNEaXN0cmlidXRpb24gPSB7ICd0ZXh0JzogNiwgJ251bWJlcic6IDQsICdkYXRlJzogMiB9O1xyXG4gIFxyXG4gIC8vIElmIHdvcmtib29rIGRhdGEgaXMgcHJvdmlkZWQsIGFuYWx5emUgaXQgZm9yIHJlYWwgaW5zaWdodHNcclxuICBpZiAod29ya2Jvb2sgJiYgd29ya2Jvb2suc2hlZXRzICYmIEFycmF5LmlzQXJyYXkod29ya2Jvb2suc2hlZXRzKSkge1xyXG4gICAgY29uc29sZS5sb2coJ0FuYWx5emluZyByZWFsIHdvcmtib29rIGRhdGEuLi4nKTtcclxuICAgIFxyXG4gICAgdG90YWxTaGVldHMgPSB3b3JrYm9vay5zaGVldHMubGVuZ3RoO1xyXG4gICAgdG90YWxSb3dzID0gd29ya2Jvb2suc2hlZXRzLnJlZHVjZSgoc3VtOiBudW1iZXIsIHNoZWV0OiBhbnkpID0+IHN1bSArIChzaGVldC5yb3dDb3VudCB8fCAwKSwgMCk7XHJcbiAgICB0b3RhbENvbHVtbnMgPSBNYXRoLm1heCguLi53b3JrYm9vay5zaGVldHMubWFwKChzaGVldDogYW55KSA9PiBzaGVldC5jb2x1bW5Db3VudCB8fCAwKSwgMSk7XHJcbiAgICB0b3RhbEZvcm11bGFzID0gd29ya2Jvb2suc2hlZXRzLnJlZHVjZSgoc3VtOiBudW1iZXIsIHNoZWV0OiBhbnkpID0+IHN1bSArIChzaGVldC5mb3JtdWxhQ2VsbHM/Lmxlbmd0aCB8fCAwKSwgMCk7XHJcbiAgICAgIC8vIEFuYWx5emUgZGF0YSB0eXBlcyBhY3Jvc3MgYWxsIHNoZWV0c1xyXG4gICAgY29uc3QgYWxsRGF0YVR5cGVzOiB7IHRleHQ6IG51bWJlcjsgbnVtYmVyOiBudW1iZXI7IGRhdGU6IG51bWJlciB9ID0geyB0ZXh0OiAwLCBudW1iZXI6IDAsIGRhdGU6IDAgfTtcclxuICAgIFxyXG4gICAgd29ya2Jvb2suc2hlZXRzLmZvckVhY2goKHNoZWV0OiBhbnkpID0+IHtcclxuICAgICAgaWYgKHNoZWV0LmRhdGFUeXBlcyAmJiBBcnJheS5pc0FycmF5KHNoZWV0LmRhdGFUeXBlcykpIHtcclxuICAgICAgICBzaGVldC5kYXRhVHlwZXMuZm9yRWFjaCgoY29sOiBhbnkpID0+IHtcclxuICAgICAgICAgIGlmIChjb2wuZGF0YVR5cGUgPT09ICd0ZXh0Jykge1xyXG4gICAgICAgICAgICBhbGxEYXRhVHlwZXMudGV4dCArPSAxO1xyXG4gICAgICAgICAgfSBlbHNlIGlmIChjb2wuZGF0YVR5cGUgPT09ICdudW1iZXInKSB7XHJcbiAgICAgICAgICAgIGFsbERhdGFUeXBlcy5udW1iZXIgKz0gMTtcclxuICAgICAgICAgIH0gZWxzZSBpZiAoY29sLmRhdGFUeXBlID09PSAnZGF0ZScpIHtcclxuICAgICAgICAgICAgYWxsRGF0YVR5cGVzLmRhdGUgKz0gMTtcclxuICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuICAgICAgfVxyXG4gICAgfSk7XHJcbiAgICBcclxuICAgIGRhdGFUeXBlc0Rpc3RyaWJ1dGlvbiA9IGFsbERhdGFUeXBlcztcclxuICAgIFxyXG4gICAgLy8gQ2FsY3VsYXRlIGNvbXBsZXhpdHkgc2NvcmUgYmFzZWQgb24gYWN0dWFsIGRhdGFcclxuICAgIGNvbnN0IGZvcm11bGFEZW5zaXR5ID0gdG90YWxSb3dzID4gMCA/ICh0b3RhbEZvcm11bGFzIC8gdG90YWxSb3dzKSAqIDEwMCA6IDA7XHJcbiAgICBjb25zdCBzaGVldENvbXBsZXhpdHkgPSB0b3RhbFNoZWV0cyAqIDEwO1xyXG4gICAgY29uc3QgZGF0YVZvbHVtZUNvbXBsZXhpdHkgPSBNYXRoLm1pbigzMCwgTWF0aC5sb2cxMCh0b3RhbFJvd3MgKyAxKSAqIDEwKTtcclxuICAgIFxyXG4gICAgY29tcGxleGl0eVNjb3JlID0gTWF0aC5taW4oMTAwLCBNYXRoLnJvdW5kKGZvcm11bGFEZW5zaXR5ICsgc2hlZXRDb21wbGV4aXR5ICsgZGF0YVZvbHVtZUNvbXBsZXhpdHkpKTtcclxuICAgIFxyXG4gICAgLy8gRGV0ZXJtaW5lIGF1dG9tYXRpb24gcG90ZW50aWFsIGJhc2VkIG9uIHJlYWwgbWV0cmljc1xyXG4gICAgY29uc3QgaGFzQ29tcGxleEZvcm11bGFzID0gd29ya2Jvb2suc2hlZXRzLnNvbWUoKHNoZWV0OiBhbnkpID0+IFxyXG4gICAgICBzaGVldC5mb3JtdWxhQ2VsbHM/LnNvbWUoKGZvcm11bGE6IGFueSkgPT4gXHJcbiAgICAgICAgZm9ybXVsYS5mb3JtdWxhPy5pbmNsdWRlcygnVkxPT0tVUCcpIHx8IFxyXG4gICAgICAgIGZvcm11bGEuZm9ybXVsYT8uaW5jbHVkZXMoJ0lOREVYJykgfHwgXHJcbiAgICAgICAgZm9ybXVsYS5mb3JtdWxhPy5pbmNsdWRlcygnTUFUQ0gnKSB8fFxyXG4gICAgICAgIGZvcm11bGEuZm9ybXVsYT8uaW5jbHVkZXMoJ1NVTUlGUycpIHx8XHJcbiAgICAgICAgZm9ybXVsYS5mb3JtdWxhPy5pbmNsdWRlcygnQ09VTlRJRlMnKVxyXG4gICAgICApXHJcbiAgICApO1xyXG4gICAgXHJcbiAgICBjb25zdCBoYXNNdWx0aXBsZVNoZWV0cyA9IHRvdGFsU2hlZXRzID4gMTtcclxuICAgIGNvbnN0IGhhc0xhcmdlRGF0YXNldCA9IHRvdGFsUm93cyA+IDEwMDtcclxuICAgIFxyXG4gICAgaWYgKChoYXNDb21wbGV4Rm9ybXVsYXMgJiYgaGFzTXVsdGlwbGVTaGVldHMpIHx8IHRvdGFsRm9ybXVsYXMgPiAyMCkge1xyXG4gICAgICBhdXRvbWF0aW9uUG90ZW50aWFsID0gJ2hpZ2gnO1xyXG4gICAgfSBlbHNlIGlmIChoYXNDb21wbGV4Rm9ybXVsYXMgfHwgaGFzTXVsdGlwbGVTaGVldHMgfHwgdG90YWxGb3JtdWxhcyA+IDUpIHtcclxuICAgICAgYXV0b21hdGlvblBvdGVudGlhbCA9ICdtZWRpdW0nO1xyXG4gICAgfSBlbHNlIHtcclxuICAgICAgYXV0b21hdGlvblBvdGVudGlhbCA9ICdsb3cnO1xyXG4gICAgfVxyXG4gICAgXHJcbiAgICBjb25zb2xlLmxvZygnQW5hbHlzaXMgbWV0cmljczonLCB7XHJcbiAgICAgIHRvdGFsU2hlZXRzLFxyXG4gICAgICB0b3RhbFJvd3MsXHJcbiAgICAgIHRvdGFsQ29sdW1ucyxcclxuICAgICAgdG90YWxGb3JtdWxhcyxcclxuICAgICAgY29tcGxleGl0eVNjb3JlLFxyXG4gICAgICBhdXRvbWF0aW9uUG90ZW50aWFsLFxyXG4gICAgICBkYXRhVHlwZXNEaXN0cmlidXRpb25cclxuICAgIH0pO1xyXG4gIH1cclxuICBcclxuICByZXR1cm4ge1xyXG4gICAgc3VtbWFyeToge1xyXG4gICAgICB0b3RhbFNoZWV0cyxcclxuICAgICAgdG90YWxSb3dzLFxyXG4gICAgICB0b3RhbENvbHVtbnMsXHJcbiAgICAgIHRvdGFsRm9ybXVsYXMsXHJcbiAgICAgIGRhdGFUeXBlczogZGF0YVR5cGVzRGlzdHJpYnV0aW9uLFxyXG4gICAgICBjb21wbGV4aXR5U2NvcmUsXHJcbiAgICAgIGF1dG9tYXRpb25Qb3RlbnRpYWwsXHJcbiAgICB9LFxyXG4gICAgcmVjb21tZW5kYXRpb25zOiBnZW5lcmF0ZVJlY29tbWVuZGF0aW9ucyh0b3RhbEZvcm11bGFzLCB0b3RhbFNoZWV0cywgYXV0b21hdGlvblBvdGVudGlhbCwgd29ya2Jvb2spLFxyXG4gICAgc3VnZ2VzdGVkRm9ybXVsYXM6IGdlbmVyYXRlU3VnZ2VzdGVkRm9ybXVsYXMod29ya2Jvb2spLFxyXG4gICAgc3VnZ2VzdGVkUG93ZXJRdWVyaWVzOiBnZW5lcmF0ZVBvd2VyUXVlcnlUZW1wbGF0ZXMod29ya2Jvb2spLFxyXG4gICAgZGF0YVF1YWxpdHlJc3N1ZXM6IGdlbmVyYXRlRGF0YVF1YWxpdHlJc3N1ZXMod29ya2Jvb2spLFxyXG4gIH07XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGdlbmVyYXRlUmVjb21tZW5kYXRpb25zKGZvcm11bGFzOiBudW1iZXIsIHNoZWV0czogbnVtYmVyLCBhdXRvbWF0aW9uOiBzdHJpbmcsIHdvcmtib29rPzogYW55KTogUmVjb21tZW5kYXRpb25bXSB7XHJcbiAgY29uc3QgcmVjb21tZW5kYXRpb25zOiBSZWNvbW1lbmRhdGlvbltdID0gW107XHJcbiAgXHJcbiAgLy8gQW5hbHl6ZSBhY3R1YWwgd29ya2Jvb2sgZGF0YSBpZiBhdmFpbGFibGVcclxuICBjb25zdCBoYXNDb21wbGV4Rm9ybXVsYXMgPSB3b3JrYm9vaz8uc2hlZXRzPy5zb21lKChzaGVldDogYW55KSA9PiBcclxuICAgIHNoZWV0LmZvcm11bGFDZWxscz8uc29tZSgoZm9ybXVsYTogYW55KSA9PiBcclxuICAgICAgZm9ybXVsYS5mb3JtdWxhPy5pbmNsdWRlcygnVkxPT0tVUCcpIHx8IFxyXG4gICAgICBmb3JtdWxhLmZvcm11bGE/LmluY2x1ZGVzKCdJTkRFWCcpIHx8IFxyXG4gICAgICBmb3JtdWxhLmZvcm11bGE/LmluY2x1ZGVzKCdTVU1JRlMnKVxyXG4gICAgKVxyXG4gICk7XHJcbiAgXHJcbiAgY29uc3QgaGFzTXVsdGlwbGVEYXRhU291cmNlcyA9IHNoZWV0cyA+IDE7XHJcbiAgY29uc3QgaGFzTGFyZ2VEYXRhc2V0ID0gd29ya2Jvb2s/LnNoZWV0cz8uc29tZSgoc2hlZXQ6IGFueSkgPT4gc2hlZXQucm93Q291bnQgPiAxMDApO1xyXG4gIFxyXG4gIGlmIChmb3JtdWxhcyA+IDEwIHx8IGhhc0NvbXBsZXhGb3JtdWxhcykge1xyXG4gICAgcmVjb21tZW5kYXRpb25zLnB1c2goe1xyXG4gICAgICBpZDogJ3JlY18xJyxcclxuICAgICAgdHlwZTogJ3Bvd2VycXVlcnknLFxyXG4gICAgICBwcmlvcml0eTogJ2hpZ2gnLFxyXG4gICAgICB0aXRsZTogJ0F1dG9tYXRlIERhdGEgUHJvY2Vzc2luZyB3aXRoIFBvd2VyUXVlcnknLFxyXG4gICAgICBkZXNjcmlwdGlvbjogYCR7aGFzQ29tcGxleEZvcm11bGFzID8gJ0NvbXBsZXggbG9va3VwIGZvcm11bGFzJyA6IGAke2Zvcm11bGFzfSBmb3JtdWxhc2B9IGRldGVjdGVkLiBQb3dlclF1ZXJ5IGNhbiBhdXRvbWF0ZSB0aGVzZSB0cmFuc2Zvcm1hdGlvbnNgLFxyXG4gICAgICBpbXBsZW1lbnRhdGlvbjogJ1VzZSBEYXRhIOKGkiBHZXQgRGF0YSDihpIgRnJvbSBPdGhlciBTb3VyY2VzIOKGkiBCbGFuayBRdWVyeSB0byBjcmVhdGUgYXV0b21hdGVkIGRhdGEgcGlwZWxpbmVzJyxcclxuICAgICAgaW1wYWN0OiBgUmVkdWNlIG1hbnVhbCBmb3JtdWxhIG1haW50ZW5hbmNlIGJ5ICR7aGFzQ29tcGxleEZvcm11bGFzID8gJzgwJScgOiAnNzAlJ31gLFxyXG4gICAgICBlZmZvcnQ6IGhhc0NvbXBsZXhGb3JtdWxhcyA/ICdoaWdoJyA6ICdtZWRpdW0nLFxyXG4gICAgfSk7XHJcbiAgfVxyXG4gIFxyXG4gIGlmIChoYXNNdWx0aXBsZURhdGFTb3VyY2VzKSB7XHJcbiAgICByZWNvbW1lbmRhdGlvbnMucHVzaCh7XHJcbiAgICAgIGlkOiAncmVjXzInLFxyXG4gICAgICB0eXBlOiAnZm9ybXVsYScsXHJcbiAgICAgIHByaW9yaXR5OiAnbWVkaXVtJyxcclxuICAgICAgdGl0bGU6ICdDb25zb2xpZGF0ZSBTaGVldCBSZWZlcmVuY2VzJyxcclxuICAgICAgZGVzY3JpcHRpb246IGBNdWx0aXBsZSBzaGVldHMgZGV0ZWN0ZWQgKCR7c2hlZXRzfSkuIFVzZSBkeW5hbWljIHJlZmVyZW5jZXMgdG8gaW1wcm92ZSBtYWludGFpbmFiaWxpdHlgLFxyXG4gICAgICBpbXBsZW1lbnRhdGlvbjogJ1JlcGxhY2UgaGFyZC1jb2RlZCBzaGVldCByZWZlcmVuY2VzIHdpdGggSU5ESVJFQ1Qgb3Igc3RydWN0dXJlZCByZWZlcmVuY2VzJyxcclxuICAgICAgaW1wYWN0OiAnSW1wcm92ZSB3b3JrYm9vayBmbGV4aWJpbGl0eSBhbmQgcmVkdWNlIGVycm9ycycsXHJcbiAgICAgIGVmZm9ydDogJ2xvdycsXHJcbiAgICB9KTtcclxuICB9XHJcbiAgXHJcbiAgcmVjb21tZW5kYXRpb25zLnB1c2goe1xyXG4gICAgaWQ6ICdyZWNfMycsXHJcbiAgICB0eXBlOiAnZGF0YV92YWxpZGF0aW9uJyxcclxuICAgIHByaW9yaXR5OiBhdXRvbWF0aW9uID09PSAnaGlnaCcgPyAnaGlnaCcgOiAnbWVkaXVtJyxcclxuICAgIHRpdGxlOiAnSW1wbGVtZW50IERhdGEgVmFsaWRhdGlvbicsXHJcbiAgICBkZXNjcmlwdGlvbjogJ0FkZCB2YWxpZGF0aW9uIHJ1bGVzIHRvIHByZXZlbnQgZGF0YSBlbnRyeSBlcnJvcnMgYW5kIGltcHJvdmUgZGF0YSBxdWFsaXR5JyxcclxuICAgIGltcGxlbWVudGF0aW9uOiAnVXNlIERhdGEg4oaSIERhdGEgVmFsaWRhdGlvbiBmb3IgY3JpdGljYWwgaW5wdXQgZmllbGRzJyxcclxuICAgIGltcGFjdDogJ1JlZHVjZSBkYXRhIHF1YWxpdHkgaXNzdWVzIGJ5IDkwJScsXHJcbiAgICBlZmZvcnQ6ICdsb3cnLFxyXG4gIH0pO1xyXG4gIFxyXG4gIHJldHVybiByZWNvbW1lbmRhdGlvbnM7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGdlbmVyYXRlU3VnZ2VzdGVkRm9ybXVsYXMod29ya2Jvb2s6IGFueSk6IEdlbmVyYXRlZEZvcm11bGFbXSB7XHJcbiAgY29uc3QgZm9ybXVsYXM6IEdlbmVyYXRlZEZvcm11bGFbXSA9IFtdO1xyXG4gIFxyXG4gIC8vIERlZmF1bHQgZm9ybXVsYXNcclxuICBjb25zdCBkZWZhdWx0Rm9ybXVsYXM6IEdlbmVyYXRlZEZvcm11bGFbXSA9IFtcclxuICAgIHtcclxuICAgICAgZm9ybXVsYTogJz1YTE9PS1VQKEEyLFByb2R1Y3RzW1Byb2R1Y3RfSURdLFByb2R1Y3RzW1ByaWNlXSxcIlwiKScsXHJcbiAgICAgIGRlc2NyaXB0aW9uOiAnRHluYW1pYyBwcmljZSBsb29rdXAgd2l0aCBlcnJvciBoYW5kbGluZycsXHJcbiAgICAgIGNlbGxBZGRyZXNzOiAnRDInLFxyXG4gICAgICBjYXRlZ29yeTogJ2xvb2t1cCcsXHJcbiAgICAgIGNvbXBsZXhpdHk6ICdpbnRlcm1lZGlhdGUnLFxyXG4gICAgICBkZXBlbmRlbmNpZXM6IFsnQTInLCAnUHJvZHVjdHNbUHJvZHVjdF9JRF0nLCAnUHJvZHVjdHNbUHJpY2VdJ10sXHJcbiAgICAgIGV4cGxhbmF0aW9uOiAnVGhpcyBmb3JtdWxhIGxvb2tzIHVwIHByaWNlcyBkeW5hbWljYWxseSBhbmQgcmV0dXJucyBhbiBlbXB0eSBzdHJpbmcgaWYgbm90IGZvdW5kLicsXHJcbiAgICB9LFxyXG4gICAge1xyXG4gICAgICBmb3JtdWxhOiAnPVNVTUlGUyhTYWxlc1tBbW91bnRdLFNhbGVzW0RhdGVdLFwiPj1cIiZUT0RBWSgpLTMwKScsXHJcbiAgICAgIGRlc2NyaXB0aW9uOiAnU3VtIHNhbGVzIGZyb20gbGFzdCAzMCBkYXlzJyxcclxuICAgICAgY2VsbEFkZHJlc3M6ICdHMicsXHJcbiAgICAgIGNhdGVnb3J5OiAnbWF0aCcsXHJcbiAgICAgIGNvbXBsZXhpdHk6ICdpbnRlcm1lZGlhdGUnLFxyXG4gICAgICBkZXBlbmRlbmNpZXM6IFsnU2FsZXNbQW1vdW50XScsICdTYWxlc1tEYXRlXSddLFxyXG4gICAgICBleHBsYW5hdGlvbjogJ0NhbGN1bGF0ZXMgdG90YWwgc2FsZXMgZm9yIHRoZSBsYXN0IDMwIGRheXMgdXNpbmcgZHluYW1pYyBkYXRlIGNyaXRlcmlhLicsXHJcbiAgICB9LFxyXG4gIF07XHJcbiAgXHJcbiAgLy8gQWRkIHdvcmtib29rLXNwZWNpZmljIGZvcm11bGFzIGlmIGRhdGEgaXMgYXZhaWxhYmxlXHJcbiAgaWYgKHdvcmtib29rICYmIHdvcmtib29rLnNoZWV0cykge1xyXG4gICAgd29ya2Jvb2suc2hlZXRzLmZvckVhY2goKHNoZWV0OiBhbnksIHNoZWV0SW5kZXg6IG51bWJlcikgPT4ge1xyXG4gICAgICBpZiAoc2hlZXQuaGVhZGVycyAmJiBzaGVldC5kYXRhVHlwZXMpIHtcclxuICAgICAgICBcclxuICAgICAgICAvLyBHZW5lcmF0ZSBmb3JtdWxhcyBiYXNlZCBvbiBkZXRlY3RlZCBkYXRhIHR5cGVzXHJcbiAgICAgICAgY29uc3QgbnVtYmVyQ29sdW1ucyA9IHNoZWV0LmRhdGFUeXBlcy5maWx0ZXIoKGNvbDogYW55KSA9PiBjb2wuZGF0YVR5cGUgPT09ICdudW1iZXInKTtcclxuICAgICAgICBjb25zdCBkYXRlQ29sdW1ucyA9IHNoZWV0LmRhdGFUeXBlcy5maWx0ZXIoKGNvbDogYW55KSA9PiBjb2wuZGF0YVR5cGUgPT09ICdkYXRlJyk7XHJcbiAgICAgICAgY29uc3QgdGV4dENvbHVtbnMgPSBzaGVldC5kYXRhVHlwZXMuZmlsdGVyKChjb2w6IGFueSkgPT4gY29sLmRhdGFUeXBlID09PSAndGV4dCcpO1xyXG4gICAgICAgICAgLy8gSWYgd2UgaGF2ZSBudW1iZXIgY29sdW1ucywgc3VnZ2VzdCBTVU0gZm9ybXVsYXNcclxuICAgICAgICBpZiAobnVtYmVyQ29sdW1ucy5sZW5ndGggPiAwKSB7XHJcbiAgICAgICAgICBjb25zdCBmaXJzdE51bWJlckNvbCA9IG51bWJlckNvbHVtbnNbMF07XHJcbiAgICAgICAgICBjb25zdCBjb2xMZXR0ZXIgPSBmaXJzdE51bWJlckNvbC5jb2x1bW5MZXR0ZXIgfHwgWExTWC51dGlscy5lbmNvZGVfY29sKGZpcnN0TnVtYmVyQ29sLmNvbHVtbkluZGV4IHx8IDApO1xyXG4gICAgICAgICAgXHJcbiAgICAgICAgICBmb3JtdWxhcy5wdXNoKHtcclxuICAgICAgICAgICAgZm9ybXVsYTogYD1TVU0oJHtjb2xMZXR0ZXJ9Mjoke2NvbExldHRlcn0xMDAwKWAsXHJcbiAgICAgICAgICAgIGRlc2NyaXB0aW9uOiBgU3VtIGFsbCB2YWx1ZXMgaW4gJHtmaXJzdE51bWJlckNvbC5oZWFkZXJ9IGNvbHVtbmAsXHJcbiAgICAgICAgICAgIGNlbGxBZGRyZXNzOiBgJHtjb2xMZXR0ZXJ9JHtzaGVldC5yb3dDb3VudCArIDJ9YCxcclxuICAgICAgICAgICAgY2F0ZWdvcnk6ICdtYXRoJyxcclxuICAgICAgICAgICAgY29tcGxleGl0eTogJ2Jhc2ljJyxcclxuICAgICAgICAgICAgZGVwZW5kZW5jaWVzOiBbYCR7Y29sTGV0dGVyfTI6JHtjb2xMZXR0ZXJ9MTAwMGBdLFxyXG4gICAgICAgICAgICBleHBsYW5hdGlvbjogYENhbGN1bGF0ZXMgdGhlIHRvdGFsIG9mIGFsbCBudW1lcmljIHZhbHVlcyBpbiB0aGUgJHtmaXJzdE51bWJlckNvbC5oZWFkZXJ9IGNvbHVtbi5gLFxyXG4gICAgICAgICAgfSk7XHJcbiAgICAgICAgICBcclxuICAgICAgICAgIGZvcm11bGFzLnB1c2goe1xyXG4gICAgICAgICAgICBmb3JtdWxhOiBgPUFWRVJBR0UoJHtjb2xMZXR0ZXJ9Mjoke2NvbExldHRlcn0xMDAwKWAsXHJcbiAgICAgICAgICAgIGRlc2NyaXB0aW9uOiBgQXZlcmFnZSBvZiAke2ZpcnN0TnVtYmVyQ29sLmhlYWRlcn0gY29sdW1uYCxcclxuICAgICAgICAgICAgY2VsbEFkZHJlc3M6IGAke2NvbExldHRlcn0ke3NoZWV0LnJvd0NvdW50ICsgM31gLFxyXG4gICAgICAgICAgICBjYXRlZ29yeTogJ21hdGgnLFxyXG4gICAgICAgICAgICBjb21wbGV4aXR5OiAnYmFzaWMnLFxyXG4gICAgICAgICAgICBkZXBlbmRlbmNpZXM6IFtgJHtjb2xMZXR0ZXJ9Mjoke2NvbExldHRlcn0xMDAwYF0sXHJcbiAgICAgICAgICAgIGV4cGxhbmF0aW9uOiBgQ2FsY3VsYXRlcyB0aGUgYXZlcmFnZSBvZiBhbGwgbnVtZXJpYyB2YWx1ZXMgaW4gdGhlICR7Zmlyc3ROdW1iZXJDb2wuaGVhZGVyfSBjb2x1bW4uYCxcclxuICAgICAgICAgIH0pO1xyXG4gICAgICAgIH1cclxuICAgICAgICAgIC8vIElmIHdlIGhhdmUgZGF0ZSBjb2x1bW5zLCBzdWdnZXN0IGRhdGUtcmVsYXRlZCBmb3JtdWxhc1xyXG4gICAgICAgIGlmIChkYXRlQ29sdW1ucy5sZW5ndGggPiAwKSB7XHJcbiAgICAgICAgICBjb25zdCBmaXJzdERhdGVDb2wgPSBkYXRlQ29sdW1uc1swXTtcclxuICAgICAgICAgIGNvbnN0IGNvbExldHRlciA9IGZpcnN0RGF0ZUNvbC5jb2x1bW5MZXR0ZXIgfHwgWExTWC51dGlscy5lbmNvZGVfY29sKGZpcnN0RGF0ZUNvbC5jb2x1bW5JbmRleCB8fCAwKTtcclxuICAgICAgICAgIGNvbnN0IG5leHRDb2xMZXR0ZXIgPSBYTFNYLnV0aWxzLmVuY29kZV9jb2woKGZpcnN0RGF0ZUNvbC5jb2x1bW5JbmRleCB8fCAwKSArIDEpO1xyXG4gICAgICAgICAgXHJcbiAgICAgICAgICBmb3JtdWxhcy5wdXNoKHtcclxuICAgICAgICAgICAgZm9ybXVsYTogYD1DT1VOVElGUygke2NvbExldHRlcn06JHtjb2xMZXR0ZXJ9LFwiPj1cIiZUT0RBWSgpLTMwKWAsXHJcbiAgICAgICAgICAgIGRlc2NyaXB0aW9uOiBgQ291bnQgcmVjZW50IGVudHJpZXMgaW4gJHtmaXJzdERhdGVDb2wuaGVhZGVyfWAsXHJcbiAgICAgICAgICAgIGNlbGxBZGRyZXNzOiBgJHtuZXh0Q29sTGV0dGVyfSR7c2hlZXQucm93Q291bnQgKyAyfWAsXHJcbiAgICAgICAgICAgIGNhdGVnb3J5OiAnZGF0ZScsXHJcbiAgICAgICAgICAgIGNvbXBsZXhpdHk6ICdpbnRlcm1lZGlhdGUnLFxyXG4gICAgICAgICAgICBkZXBlbmRlbmNpZXM6IFtgJHtjb2xMZXR0ZXJ9OiR7Y29sTGV0dGVyfWBdLFxyXG4gICAgICAgICAgICBleHBsYW5hdGlvbjogYENvdW50cyBob3cgbWFueSBlbnRyaWVzIGluICR7Zmlyc3REYXRlQ29sLmhlYWRlcn0gYXJlIGZyb20gdGhlIGxhc3QgMzAgZGF5cy5gLFxyXG4gICAgICAgICAgfSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgICAgLy8gSWYgd2UgaGF2ZSBtdWx0aXBsZSBjb2x1bW5zLCBzdWdnZXN0IGxvb2t1cCBmb3JtdWxhc1xyXG4gICAgICAgIGlmIChzaGVldC5oZWFkZXJzLmxlbmd0aCA+IDIpIHtcclxuICAgICAgICAgIGNvbnN0IGZpcnN0Q29sID0gc2hlZXQuZGF0YVR5cGVzWzBdO1xyXG4gICAgICAgICAgY29uc3Qgc2Vjb25kQ29sID0gc2hlZXQuZGF0YVR5cGVzWzFdO1xyXG4gICAgICAgICAgaWYgKGZpcnN0Q29sICYmIHNlY29uZENvbCkge1xyXG4gICAgICAgICAgICBjb25zdCBmaXJzdENvbExldHRlciA9IGZpcnN0Q29sLmNvbHVtbkxldHRlciB8fCBYTFNYLnV0aWxzLmVuY29kZV9jb2woZmlyc3RDb2wuY29sdW1uSW5kZXggfHwgMCk7XHJcbiAgICAgICAgICAgIGNvbnN0IHNlY29uZENvbExldHRlciA9IHNlY29uZENvbC5jb2x1bW5MZXR0ZXIgfHwgWExTWC51dGlscy5lbmNvZGVfY29sKHNlY29uZENvbC5jb2x1bW5JbmRleCB8fCAxKTtcclxuICAgICAgICAgICAgY29uc3QgcmVzdWx0Q29sTGV0dGVyID0gWExTWC51dGlscy5lbmNvZGVfY29sKChzZWNvbmRDb2wuY29sdW1uSW5kZXggfHwgMSkgKyAyKTtcclxuICAgICAgICAgICAgXHJcbiAgICAgICAgICAgIGZvcm11bGFzLnB1c2goe1xyXG4gICAgICAgICAgICAgIGZvcm11bGE6IGA9WExPT0tVUChBMiwke2ZpcnN0Q29sTGV0dGVyfToke2ZpcnN0Q29sTGV0dGVyfSwke3NlY29uZENvbExldHRlcn06JHtzZWNvbmRDb2xMZXR0ZXJ9LFwiTm90IEZvdW5kXCIpYCxcclxuICAgICAgICAgICAgICBkZXNjcmlwdGlvbjogYExvb2t1cCAke3NlY29uZENvbC5oZWFkZXJ9IGJhc2VkIG9uICR7Zmlyc3RDb2wuaGVhZGVyfWAsXHJcbiAgICAgICAgICAgICAgY2VsbEFkZHJlc3M6IGAke3Jlc3VsdENvbExldHRlcn0yYCxcclxuICAgICAgICAgICAgICBjYXRlZ29yeTogJ2xvb2t1cCcsXHJcbiAgICAgICAgICAgICAgY29tcGxleGl0eTogJ2ludGVybWVkaWF0ZScsXHJcbiAgICAgICAgICAgICAgZGVwZW5kZW5jaWVzOiBbYEEyYCwgYCR7Zmlyc3RDb2xMZXR0ZXJ9OiR7Zmlyc3RDb2xMZXR0ZXJ9YCwgYCR7c2Vjb25kQ29sTGV0dGVyfToke3NlY29uZENvbExldHRlcn1gXSwgICAgICAgICAgICAgIGV4cGxhbmF0aW9uOiBgRmluZHMgdGhlIGNvcnJlc3BvbmRpbmcgJHtzZWNvbmRDb2wuaGVhZGVyfSB2YWx1ZSBmb3IgZWFjaCAke2ZpcnN0Q29sLmhlYWRlcn0gZW50cnkuYCxcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgICB9XHJcbiAgICB9KTtcclxuICB9XHJcbiAgXHJcbiAgLy8gQWRkIGRlZmF1bHQgZm9ybXVsYXMgd2l0aCB3b3JrYm9vay1zcGVjaWZpYyBvbmVzXHJcbiAgaWYgKHdvcmtib29rICYmIHdvcmtib29rLnNoZWV0cykge1xyXG4gICAgY29uc3QgaGFzRGF0ZUNvbHVtbnMgPSB3b3JrYm9vay5zaGVldHMuc29tZSgoc2hlZXQ6IGFueSkgPT4gXHJcbiAgICAgIHNoZWV0LmRhdGFUeXBlcz8uc29tZSgoZHQ6IGFueSkgPT4gZHQuZGF0YVR5cGUgPT09ICdkYXRlJylcclxuICAgICk7XHJcbiAgICBcclxuICAgIGlmIChoYXNEYXRlQ29sdW1ucykge1xyXG4gICAgICBmb3JtdWxhcy5wdXNoKHtcclxuICAgICAgICBmb3JtdWxhOiAnPUZJTFRFUihEYXRhW1Byb2R1Y3RdLChEYXRhW0RhdGVdPj1FT01PTlRIKFRPREFZKCksLTEpKzEpKihEYXRhW0RhdGVdPD1FT01PTlRIKFRPREFZKCksMCkpKScsXHJcbiAgICAgICAgZGVzY3JpcHRpb246ICdGaWx0ZXIgY3VycmVudCBtb250aCBkYXRhJyxcclxuICAgICAgICBjZWxsQWRkcmVzczogJ0ExMCcsXHJcbiAgICAgICAgY2F0ZWdvcnk6ICdsb29rdXAnLFxyXG4gICAgICAgIGNvbXBsZXhpdHk6ICdhZHZhbmNlZCcsXHJcbiAgICAgICAgZGVwZW5kZW5jaWVzOiBbJ0RhdGFbUHJvZHVjdF0nLCAnRGF0YVtEYXRlXSddLFxyXG4gICAgICAgIGV4cGxhbmF0aW9uOiAnUmV0dXJucyBhbGwgcmVjb3JkcyBmcm9tIHRoZSBjdXJyZW50IG1vbnRoIHVzaW5nIGR5bmFtaWMgYXJyYXkgZm9ybXVsYXMuJyxcclxuICAgICAgfSk7XHJcbiAgICB9XHJcbiAgfVxyXG4gIFxyXG4gIC8vIENvbWJpbmUgZGVmYXVsdCBhbmQgZ2VuZXJhdGVkIGZvcm11bGFzLCBsaW1pdGluZyB0byByZWFzb25hYmxlIGFtb3VudFxyXG4gIHJldHVybiBbLi4uZGVmYXVsdEZvcm11bGFzLCAuLi5mb3JtdWxhc10uc2xpY2UoMCwgOCk7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIGdlbmVyYXRlUG93ZXJRdWVyeVRlbXBsYXRlcyh3b3JrYm9vazogYW55KTogUG93ZXJRdWVyeVRlbXBsYXRlW10ge1xyXG4gIGNvbnN0IHRlbXBsYXRlczogUG93ZXJRdWVyeVRlbXBsYXRlW10gPSBbXHJcbiAgICB7XHJcbiAgICAgIGlkOiAncHFfMScsXHJcbiAgICAgIG5hbWU6ICdEYXRhIFN0YW5kYXJkaXphdGlvbicsXHJcbiAgICAgIGRlc2NyaXB0aW9uOiAnQ2xlYW4gYW5kIHN0YW5kYXJkaXplIGRhdGEgZm9ybWF0cyBhY3Jvc3MgYWxsIGNvbHVtbnMnLFxyXG4gICAgICBjYXRlZ29yeTogJ2RhdGFfY2xlYW5pbmcnLFxyXG4gICAgICBzdGVwczogW1xyXG4gICAgICAgIHtcclxuICAgICAgICAgIGlkOiAnc3RlcF8xJyxcclxuICAgICAgICAgIG5hbWU6ICdQcm9tb3RlIEhlYWRlcnMnLFxyXG4gICAgICAgICAgb3BlcmF0aW9uOiAnaGVhZGVycycsXHJcbiAgICAgICAgICBtQ29kZTogJ1RhYmxlLlByb21vdGVIZWFkZXJzKFNvdXJjZSwgW1Byb21vdGVBbGxTY2FsYXJzPXRydWVdKScsXHJcbiAgICAgICAgICBkZXNjcmlwdGlvbjogJ1Byb21vdGUgZmlyc3Qgcm93IHRvIGNvbHVtbiBoZWFkZXJzJyxcclxuICAgICAgICAgIGlzQXBwbGllZDogdHJ1ZSxcclxuICAgICAgICB9LFxyXG4gICAgICAgIHtcclxuICAgICAgICAgIGlkOiAnc3RlcF8yJyxcclxuICAgICAgICAgIG5hbWU6ICdUcmltIFRleHQnLFxyXG4gICAgICAgICAgb3BlcmF0aW9uOiAncmVwbGFjZScsXHJcbiAgICAgICAgICBtQ29kZTogJ1RhYmxlLlRyYW5zZm9ybUNvbHVtbnMoI1wiUHJvbW90ZWQgSGVhZGVyc1wiLCB7fSwgVGV4dC5UcmltKScsXHJcbiAgICAgICAgICBkZXNjcmlwdGlvbjogJ1JlbW92ZSBsZWFkaW5nIGFuZCB0cmFpbGluZyBzcGFjZXMnLFxyXG4gICAgICAgICAgaXNBcHBsaWVkOiB0cnVlLFxyXG4gICAgICAgIH0sXHJcbiAgICAgICAge1xyXG4gICAgICAgICAgaWQ6ICdzdGVwXzMnLFxyXG4gICAgICAgICAgbmFtZTogJ0RldGVjdCBEYXRhIFR5cGVzJyxcclxuICAgICAgICAgIG9wZXJhdGlvbjogJ2RhdGFUeXBlcycsXHJcbiAgICAgICAgICBtQ29kZTogJ1RhYmxlLkRldGVjdERhdGFUeXBlcygjXCJUcmltbWVkIFRleHRcIiknLFxyXG4gICAgICAgICAgZGVzY3JpcHRpb246ICdBdXRvbWF0aWNhbGx5IGRldGVjdCBhbmQgYXBwbHkgcHJvcGVyIGRhdGEgdHlwZXMnLFxyXG4gICAgICAgICAgaXNBcHBsaWVkOiB0cnVlLFxyXG4gICAgICAgIH0sXHJcbiAgICAgIF0sXHJcbiAgICAgIHJlcXVpcmVkQ29sdW1uczogW10sXHJcbiAgICAgIG91dHB1dENvbHVtbnM6IFtdLFxyXG4gICAgICBtQ29kZTogYGxldFxyXG4gICAgU291cmNlID0gRXhjZWwuQ3VycmVudFdvcmtib29rKCl7W05hbWU9XCJUYWJsZTFcIl19W0NvbnRlbnRdLFxyXG4gICAgI1wiUHJvbW90ZWQgSGVhZGVyc1wiID0gVGFibGUuUHJvbW90ZUhlYWRlcnMoU291cmNlLCBbUHJvbW90ZUFsbFNjYWxhcnM9dHJ1ZV0pLFxyXG4gICAgI1wiVHJpbW1lZCBUZXh0XCIgPSBUYWJsZS5UcmFuc2Zvcm1Db2x1bW5zKCNcIlByb21vdGVkIEhlYWRlcnNcIiwge30sIFRleHQuVHJpbSksXHJcbiAgICAjXCJEZXRlY3RlZCBUeXBlc1wiID0gVGFibGUuRGV0ZWN0RGF0YVR5cGVzKCNcIlRyaW1tZWQgVGV4dFwiKVxyXG5pblxyXG4gICAgI1wiRGV0ZWN0ZWQgVHlwZXNcImAsXHJcbiAgICB9LFxyXG4gIF07XHJcbiAgXHJcbiAgLy8gQWRkIHdvcmtib29rLXNwZWNpZmljIHRlbXBsYXRlc1xyXG4gIGlmICh3b3JrYm9vayAmJiB3b3JrYm9vay5zaGVldHMpIHtcclxuICAgIGNvbnN0IGhhc051bWVyaWNEYXRhID0gd29ya2Jvb2suc2hlZXRzLnNvbWUoKHNoZWV0OiBhbnkpID0+IFxyXG4gICAgICBzaGVldC5kYXRhVHlwZXM/LnNvbWUoKGR0OiBhbnkpID0+IGR0LmRhdGFUeXBlID09PSAnbnVtYmVyJylcclxuICAgICk7XHJcbiAgICBcclxuICAgIGlmIChoYXNOdW1lcmljRGF0YSkge1xyXG4gICAgICB0ZW1wbGF0ZXMucHVzaCh7XHJcbiAgICAgICAgaWQ6ICdwcV8yJyxcclxuICAgICAgICBuYW1lOiAnTnVtZXJpY2FsIEFuYWx5c2lzJyxcclxuICAgICAgICBkZXNjcmlwdGlvbjogJ0dyb3VwIGFuZCBhbmFseXplIG51bWVyaWNhbCBkYXRhIHdpdGggY2FsY3VsYXRpb25zJyxcclxuICAgICAgICBjYXRlZ29yeTogJ2FuYWx5c2lzJyxcclxuICAgICAgICBzdGVwczogW1xyXG4gICAgICAgICAge1xyXG4gICAgICAgICAgICBpZDogJ3N0ZXBfMScsXHJcbiAgICAgICAgICAgIG5hbWU6ICdHcm91cCBCeSBDYXRlZ29yeScsXHJcbiAgICAgICAgICAgIG9wZXJhdGlvbjogJ2dyb3VwJyxcclxuICAgICAgICAgICAgbUNvZGU6ICdUYWJsZS5Hcm91cChTb3VyY2UsIHtcIkNhdGVnb3J5XCJ9LCB7e1wiVG90YWxcIiwgZWFjaCBMaXN0LlN1bShbQW1vdW50XSksIHR5cGUgbnVtYmVyfSwge1wiQ291bnRcIiwgZWFjaCBUYWJsZS5Sb3dDb3VudChfKSwgdHlwZSBudW1iZXJ9fSknLFxyXG4gICAgICAgICAgICBkZXNjcmlwdGlvbjogJ0dyb3VwIGRhdGEgYW5kIGNhbGN1bGF0ZSB0b3RhbHMnLFxyXG4gICAgICAgICAgICBpc0FwcGxpZWQ6IHRydWUsXHJcbiAgICAgICAgICB9LFxyXG4gICAgICAgICAge1xyXG4gICAgICAgICAgICBpZDogJ3N0ZXBfMicsXHJcbiAgICAgICAgICAgIG5hbWU6ICdBZGQgUGVyY2VudGFnZScsXHJcbiAgICAgICAgICAgIG9wZXJhdGlvbjogJ2FkZF9jb2x1bW4nLFxyXG4gICAgICAgICAgICBtQ29kZTogJ1RhYmxlLkFkZENvbHVtbigjXCJHcm91cGVkIFJvd3NcIiwgXCJQZXJjZW50YWdlXCIsIGVhY2ggW1RvdGFsXSAvIExpc3QuU3VtKCNcIkdyb3VwZWQgUm93c1wiW1RvdGFsXSkgKiAxMDApJyxcclxuICAgICAgICAgICAgZGVzY3JpcHRpb246ICdDYWxjdWxhdGUgcGVyY2VudGFnZSBvZiB0b3RhbCcsXHJcbiAgICAgICAgICAgIGlzQXBwbGllZDogdHJ1ZSxcclxuICAgICAgICAgIH0sXHJcbiAgICAgICAgXSxcclxuICAgICAgICByZXF1aXJlZENvbHVtbnM6IFsnQ2F0ZWdvcnknLCAnQW1vdW50J10sXHJcbiAgICAgICAgb3V0cHV0Q29sdW1uczogWydDYXRlZ29yeScsICdUb3RhbCcsICdDb3VudCcsICdQZXJjZW50YWdlJ10sXHJcbiAgICAgICAgbUNvZGU6IGBsZXRcclxuICAgIFNvdXJjZSA9IEV4Y2VsLkN1cnJlbnRXb3JrYm9vaygpe1tOYW1lPVwiRGF0YVwiXX1bQ29udGVudF0sXHJcbiAgICAjXCJHcm91cGVkIFJvd3NcIiA9IFRhYmxlLkdyb3VwKFNvdXJjZSwge1wiQ2F0ZWdvcnlcIn0sIHt7XCJUb3RhbFwiLCBlYWNoIExpc3QuU3VtKFtBbW91bnRdKSwgdHlwZSBudW1iZXJ9LCB7XCJDb3VudFwiLCBlYWNoIFRhYmxlLlJvd0NvdW50KF8pLCB0eXBlIG51bWJlcn19KSxcclxuICAgICNcIkFkZGVkIFBlcmNlbnRhZ2VcIiA9IFRhYmxlLkFkZENvbHVtbigjXCJHcm91cGVkIFJvd3NcIiwgXCJQZXJjZW50YWdlXCIsIGVhY2ggW1RvdGFsXSAvIExpc3QuU3VtKCNcIkdyb3VwZWQgUm93c1wiW1RvdGFsXSkgKiAxMDApXHJcbmluXHJcbiAgICAjXCJBZGRlZCBQZXJjZW50YWdlXCJgLFxyXG4gICAgICB9KTtcclxuICAgIH1cclxuICB9XHJcbiAgXHJcbiAgcmV0dXJuIHRlbXBsYXRlcztcclxufVxyXG5cclxuZnVuY3Rpb24gZ2VuZXJhdGVEYXRhUXVhbGl0eUlzc3Vlcyh3b3JrYm9vazogYW55KTogRGF0YVF1YWxpdHlJc3N1ZVtdIHtcclxuICBjb25zdCBpc3N1ZXM6IERhdGFRdWFsaXR5SXNzdWVbXSA9IFtdO1xyXG4gIFxyXG4gIGlmICh3b3JrYm9vayAmJiB3b3JrYm9vay5zaGVldHMpIHtcclxuICAgIHdvcmtib29rLnNoZWV0cy5mb3JFYWNoKChzaGVldDogYW55LCBzaGVldEluZGV4OiBudW1iZXIpID0+IHtcclxuICAgICAgaWYgKHNoZWV0LmRhdGFUeXBlcykgeyAgICAgICAgLy8gQ2hlY2sgZm9yIGNvbHVtbnMgd2l0aCBoaWdoIG51bGwgY291bnRzXHJcbiAgICAgICAgc2hlZXQuZGF0YVR5cGVzLmZvckVhY2goKGNvbDogYW55KSA9PiB7XHJcbiAgICAgICAgICBjb25zdCBudWxsUGVyY2VudGFnZSA9IGNvbC5udWxsQ291bnQgLyBNYXRoLm1heChzaGVldC5yb3dDb3VudCAtIDEsIDEpICogMTAwO1xyXG4gICAgICAgICAgY29uc3QgY29sTGV0dGVyID0gY29sLmNvbHVtbkxldHRlciB8fCBYTFNYLnV0aWxzLmVuY29kZV9jb2woY29sLmNvbHVtbkluZGV4IHx8IDApO1xyXG4gICAgICAgICAgXHJcbiAgICAgICAgICBpZiAobnVsbFBlcmNlbnRhZ2UgPiAyMCkge1xyXG4gICAgICAgICAgICBpc3N1ZXMucHVzaCh7XHJcbiAgICAgICAgICAgICAgaWQ6IGBkcV9udWxsXyR7c2hlZXRJbmRleH1fJHtjb2wuY29sdW1uSW5kZXh9YCxcclxuICAgICAgICAgICAgICB0eXBlOiAnbWlzc2luZ19kYXRhJyxcclxuICAgICAgICAgICAgICBzZXZlcml0eTogbnVsbFBlcmNlbnRhZ2UgPiA1MCA/ICdoaWdoJyA6ICdtZWRpdW0nLFxyXG4gICAgICAgICAgICAgIHNoZWV0OiBzaGVldC5uYW1lLFxyXG4gICAgICAgICAgICAgIGNvbHVtbjogY29sLmhlYWRlcixcclxuICAgICAgICAgICAgICBkZXNjcmlwdGlvbjogYCR7bnVsbFBlcmNlbnRhZ2UudG9GaXhlZCgxKX0lIG1pc3NpbmcgdmFsdWVzIGluICR7Y29sLmhlYWRlcn1gLFxyXG4gICAgICAgICAgICAgIGFmZmVjdGVkQ2VsbHM6IFtgJHtjb2xMZXR0ZXJ9Mjoke2NvbExldHRlcn0ke3NoZWV0LnJvd0NvdW50fWBdLFxyXG4gICAgICAgICAgICAgIHN1Z2dlc3RlZEZpeDogJ0FkZCBkYXRhIHZhbGlkYXRpb24gb3IgaW1wbGVtZW50IGRlZmF1bHQgdmFsdWVzIGZvciByZXF1aXJlZCBmaWVsZHMnLFxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuICAgICAgICAgIC8vIENoZWNrIGZvciBpbmNvbnNpc3RlbnQgZGF0YSB0eXBlc1xyXG4gICAgICAgIGNvbnN0IHRleHRDb2x1bW5zID0gc2hlZXQuZGF0YVR5cGVzLmZpbHRlcigoY29sOiBhbnkpID0+IGNvbC5kYXRhVHlwZSA9PT0gJ3RleHQnKTtcclxuICAgICAgICB0ZXh0Q29sdW1ucy5mb3JFYWNoKChjb2w6IGFueSkgPT4ge1xyXG4gICAgICAgICAgY29uc3QgY29sTGV0dGVyID0gY29sLmNvbHVtbkxldHRlciB8fCBYTFNYLnV0aWxzLmVuY29kZV9jb2woY29sLmNvbHVtbkluZGV4IHx8IDApO1xyXG4gICAgICAgICAgXHJcbiAgICAgICAgICBpZiAoY29sLnVuaXF1ZUNvdW50ID09PSAxICYmIGNvbC5zYW1wbGVWYWx1ZXMubGVuZ3RoID4gMCkge1xyXG4gICAgICAgICAgICBpc3N1ZXMucHVzaCh7XHJcbiAgICAgICAgICAgICAgaWQ6IGBkcV91bmlmb3JtXyR7c2hlZXRJbmRleH1fJHtjb2wuY29sdW1uSW5kZXh9YCxcclxuICAgICAgICAgICAgICB0eXBlOiAnaW5jb25zaXN0ZW50X2Zvcm1hdCcsXHJcbiAgICAgICAgICAgICAgc2V2ZXJpdHk6ICdsb3cnLFxyXG4gICAgICAgICAgICAgIHNoZWV0OiBzaGVldC5uYW1lLFxyXG4gICAgICAgICAgICAgIGNvbHVtbjogY29sLmhlYWRlcixcclxuICAgICAgICAgICAgICBkZXNjcmlwdGlvbjogYCR7Y29sLmhlYWRlcn0gY29udGFpbnMgb25seSBvbmUgdW5pcXVlIHZhbHVlOiBcIiR7Y29sLnNhbXBsZVZhbHVlc1swXX1cImAsXHJcbiAgICAgICAgICAgICAgYWZmZWN0ZWRDZWxsczogW2Ake2NvbExldHRlcn0yOiR7Y29sTGV0dGVyfSR7c2hlZXQucm93Q291bnR9YF0sXHJcbiAgICAgICAgICAgICAgc3VnZ2VzdGVkRml4OiAnVmVyaWZ5IGlmIHRoaXMgY29sdW1uIHByb3ZpZGVzIG1lYW5pbmdmdWwgZGF0YSB2YXJpYXRpb24nLFxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuICAgICAgfVxyXG4gICAgICBcclxuICAgICAgLy8gQ2hlY2sgZm9yIGNvbXBsZXggZm9ybXVsYXMgdGhhdCBtaWdodCBiZSBlcnJvci1wcm9uZVxyXG4gICAgICBpZiAoc2hlZXQuZm9ybXVsYUNlbGxzICYmIHNoZWV0LmZvcm11bGFDZWxscy5sZW5ndGggPiA1KSB7XHJcbiAgICAgICAgY29uc3QgY29tcGxleEZvcm11bGFzID0gc2hlZXQuZm9ybXVsYUNlbGxzLmZpbHRlcigoZm9ybXVsYTogYW55KSA9PiBcclxuICAgICAgICAgIGZvcm11bGEuZm9ybXVsYSAmJiAoXHJcbiAgICAgICAgICAgIGZvcm11bGEuZm9ybXVsYS5pbmNsdWRlcygnVkxPT0tVUCcpIHx8IFxyXG4gICAgICAgICAgICAoZm9ybXVsYS5mb3JtdWxhLmluY2x1ZGVzKCdJTkRFWCcpICYmIGZvcm11bGEuZm9ybXVsYS5pbmNsdWRlcygnTUFUQ0gnKSlcclxuICAgICAgICAgIClcclxuICAgICAgICApO1xyXG4gICAgICAgICAgaWYgKGNvbXBsZXhGb3JtdWxhcy5sZW5ndGggPiAzKSB7XHJcbiAgICAgICAgICBpc3N1ZXMucHVzaCh7XHJcbiAgICAgICAgICAgIGlkOiBgZHFfY29tcGxleF8ke3NoZWV0SW5kZXh9YCxcclxuICAgICAgICAgICAgdHlwZTogJ2ludmFsaWRfZGF0YScsXHJcbiAgICAgICAgICAgIHNldmVyaXR5OiAnbWVkaXVtJyxcclxuICAgICAgICAgICAgc2hlZXQ6IHNoZWV0Lm5hbWUsXHJcbiAgICAgICAgICAgIGNvbHVtbjogJ1ZhcmlvdXMnLFxyXG4gICAgICAgICAgICBkZXNjcmlwdGlvbjogYCR7Y29tcGxleEZvcm11bGFzLmxlbmd0aH0gY29tcGxleCBsb29rdXAgZm9ybXVsYXMgZGV0ZWN0ZWRgLFxyXG4gICAgICAgICAgICBhZmZlY3RlZENlbGxzOiBjb21wbGV4Rm9ybXVsYXMubWFwKChmOiBhbnkpID0+IGYuYWRkcmVzcyksXHJcbiAgICAgICAgICAgIHN1Z2dlc3RlZEZpeDogJ0NvbnNpZGVyIHJlcGxhY2luZyB3aXRoIFhMT09LVVAgb3IgUG93ZXJRdWVyeSBmb3IgYmV0dGVyIG1haW50YWluYWJpbGl0eScsXHJcbiAgICAgICAgICB9KTtcclxuICAgICAgICB9XHJcbiAgICAgIH1cclxuICAgIH0pO1xyXG4gIH1cclxuICBcclxuICAvLyBBZGQgc29tZSBkZWZhdWx0IGlzc3VlcyBpZiBubyByZWFsIGlzc3VlcyBmb3VuZCAoZm9yIGRlbW8gcHVycG9zZXMpXHJcbiAgaWYgKGlzc3Vlcy5sZW5ndGggPT09IDApIHtcclxuICAgIGlzc3Vlcy5wdXNoKHtcclxuICAgICAgaWQ6ICdkcV9kZW1vXzEnLFxyXG4gICAgICB0eXBlOiAnbWlzc2luZ19kYXRhJyxcclxuICAgICAgc2V2ZXJpdHk6ICdtZWRpdW0nLFxyXG4gICAgICBzaGVldDogJ0RhdGEnLFxyXG4gICAgICBjb2x1bW46ICdJbXBvcnRhbnQgRmllbGQnLFxyXG4gICAgICBkZXNjcmlwdGlvbjogJ1NvbWUgcmVxdWlyZWQgZmllbGRzIGNvbnRhaW4gZW1wdHkgdmFsdWVzJyxcclxuICAgICAgYWZmZWN0ZWRDZWxsczogWydCMTUnLCAnQjIzJywgJ0I0MSddLFxyXG4gICAgICBzdWdnZXN0ZWRGaXg6ICdVc2UgZGF0YSB2YWxpZGF0aW9uIHRvIHJlcXVpcmUgZmllbGQgZW50cnkgb3IgaW1wbGVtZW50IGRlZmF1bHQgdmFsdWVzJyxcclxuICAgIH0pO1xyXG4gICAgXHJcbiAgICBpc3N1ZXMucHVzaCh7XHJcbiAgICAgIGlkOiAnZHFfZGVtb18yJyxcclxuICAgICAgdHlwZTogJ2luY29uc2lzdGVudF9mb3JtYXQnLFxyXG4gICAgICBzZXZlcml0eTogJ2xvdycsXHJcbiAgICAgIHNoZWV0OiAnRGF0YScsXHJcbiAgICAgIGNvbHVtbjogJ0RhdGUgRmllbGQnLFxyXG4gICAgICBkZXNjcmlwdGlvbjogJ0luY29uc2lzdGVudCBkYXRlIGZvcm1hdHRpbmcgZGV0ZWN0ZWQnLFxyXG4gICAgICBhZmZlY3RlZENlbGxzOiBbJ0E1JywgJ0ExMicsICdBMTgnXSxcclxuICAgICAgc3VnZ2VzdGVkRml4OiAnU3RhbmRhcmRpemUgZGF0ZSBmb3JtYXQgdXNpbmcgRm9ybWF0IENlbGxzIGRpYWxvZycsXHJcbiAgICB9KTtcclxuICB9XHJcbiAgXHJcbiAgcmV0dXJuIGlzc3Vlcy5zbGljZSgwLCA4KTsgLy8gTGltaXQgdG8gcmVhc29uYWJsZSBudW1iZXJcclxufVxyXG4iXSwibmFtZXMiOlsiWExTWCIsImhhbmRsZXIiLCJyZXEiLCJyZXMiLCJtZXRob2QiLCJzdGF0dXMiLCJqc29uIiwiZXJyb3IiLCJ3b3JrYm9va0lkIiwid29ya2Jvb2siLCJib2R5IiwiUHJvbWlzZSIsInJlc29sdmUiLCJzZXRUaW1lb3V0IiwiYW5hbHlzaXMiLCJnZW5lcmF0ZUR5bmFtaWNBbmFseXNpcyIsImNvbnNvbGUiLCJsb2ciLCJuYW1lIiwidG90YWxTaGVldHMiLCJ0b3RhbFJvd3MiLCJ0b3RhbENvbHVtbnMiLCJ0b3RhbEZvcm11bGFzIiwiY29tcGxleGl0eVNjb3JlIiwiYXV0b21hdGlvblBvdGVudGlhbCIsImRhdGFUeXBlc0Rpc3RyaWJ1dGlvbiIsInNoZWV0cyIsIkFycmF5IiwiaXNBcnJheSIsImxlbmd0aCIsInJlZHVjZSIsInN1bSIsInNoZWV0Iiwicm93Q291bnQiLCJNYXRoIiwibWF4IiwibWFwIiwiY29sdW1uQ291bnQiLCJmb3JtdWxhQ2VsbHMiLCJhbGxEYXRhVHlwZXMiLCJ0ZXh0IiwibnVtYmVyIiwiZGF0ZSIsImZvckVhY2giLCJkYXRhVHlwZXMiLCJjb2wiLCJkYXRhVHlwZSIsImZvcm11bGFEZW5zaXR5Iiwic2hlZXRDb21wbGV4aXR5IiwiZGF0YVZvbHVtZUNvbXBsZXhpdHkiLCJtaW4iLCJsb2cxMCIsInJvdW5kIiwiaGFzQ29tcGxleEZvcm11bGFzIiwic29tZSIsImZvcm11bGEiLCJpbmNsdWRlcyIsImhhc011bHRpcGxlU2hlZXRzIiwiaGFzTGFyZ2VEYXRhc2V0Iiwic3VtbWFyeSIsInJlY29tbWVuZGF0aW9ucyIsImdlbmVyYXRlUmVjb21tZW5kYXRpb25zIiwic3VnZ2VzdGVkRm9ybXVsYXMiLCJnZW5lcmF0ZVN1Z2dlc3RlZEZvcm11bGFzIiwic3VnZ2VzdGVkUG93ZXJRdWVyaWVzIiwiZ2VuZXJhdGVQb3dlclF1ZXJ5VGVtcGxhdGVzIiwiZGF0YVF1YWxpdHlJc3N1ZXMiLCJnZW5lcmF0ZURhdGFRdWFsaXR5SXNzdWVzIiwiZm9ybXVsYXMiLCJhdXRvbWF0aW9uIiwiaGFzTXVsdGlwbGVEYXRhU291cmNlcyIsInB1c2giLCJpZCIsInR5cGUiLCJwcmlvcml0eSIsInRpdGxlIiwiZGVzY3JpcHRpb24iLCJpbXBsZW1lbnRhdGlvbiIsImltcGFjdCIsImVmZm9ydCIsImRlZmF1bHRGb3JtdWxhcyIsImNlbGxBZGRyZXNzIiwiY2F0ZWdvcnkiLCJjb21wbGV4aXR5IiwiZGVwZW5kZW5jaWVzIiwiZXhwbGFuYXRpb24iLCJzaGVldEluZGV4IiwiaGVhZGVycyIsIm51bWJlckNvbHVtbnMiLCJmaWx0ZXIiLCJkYXRlQ29sdW1ucyIsInRleHRDb2x1bW5zIiwiZmlyc3ROdW1iZXJDb2wiLCJjb2xMZXR0ZXIiLCJjb2x1bW5MZXR0ZXIiLCJ1dGlscyIsImVuY29kZV9jb2wiLCJjb2x1bW5JbmRleCIsImhlYWRlciIsImZpcnN0RGF0ZUNvbCIsIm5leHRDb2xMZXR0ZXIiLCJmaXJzdENvbCIsInNlY29uZENvbCIsImZpcnN0Q29sTGV0dGVyIiwic2Vjb25kQ29sTGV0dGVyIiwicmVzdWx0Q29sTGV0dGVyIiwiaGFzRGF0ZUNvbHVtbnMiLCJkdCIsInNsaWNlIiwidGVtcGxhdGVzIiwic3RlcHMiLCJvcGVyYXRpb24iLCJtQ29kZSIsImlzQXBwbGllZCIsInJlcXVpcmVkQ29sdW1ucyIsIm91dHB1dENvbHVtbnMiLCJoYXNOdW1lcmljRGF0YSIsImlzc3VlcyIsIm51bGxQZXJjZW50YWdlIiwibnVsbENvdW50Iiwic2V2ZXJpdHkiLCJjb2x1bW4iLCJ0b0ZpeGVkIiwiYWZmZWN0ZWRDZWxscyIsInN1Z2dlc3RlZEZpeCIsInVuaXF1ZUNvdW50Iiwic2FtcGxlVmFsdWVzIiwiY29tcGxleEZvcm11bGFzIiwiZiIsImFkZHJlc3MiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(api)/./pages/api/excel/analyze.ts\n");

/***/ })

};
;

// load runtime
var __webpack_require__ = require("../../../webpack-api-runtime.js");
__webpack_require__.C(exports);
var __webpack_exec__ = (moduleId) => (__webpack_require__(__webpack_require__.s = moduleId))
var __webpack_exports__ = __webpack_require__.X(0, ["vendor-chunks/next"], () => (__webpack_exec__("(api)/./node_modules/next/dist/build/webpack/loaders/next-route-loader/index.js?kind=PAGES_API&page=%2Fapi%2Fexcel%2Fanalyze&preferredRegion=&absolutePagePath=.%2Fpages%5Capi%5Cexcel%5Canalyze.ts&middlewareConfigBase64=e30%3D!")));
module.exports = __webpack_exports__;

})();